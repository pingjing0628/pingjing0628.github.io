<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PinJing&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pingjing0628.github.io/"/>
  <updated>2022-12-11T14:20:24.851Z</updated>
  <id>https://pingjing0628.github.io/</id>
  
  <author>
    <name>PinJing Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PSM-Learning</title>
    <link href="https://pingjing0628.github.io/2022/12/11/PSM-Learning/"/>
    <id>https://pingjing0628.github.io/2022/12/11/PSM-Learning/</id>
    <published>2022-12-11T14:17:57.000Z</published>
    <updated>2022-12-11T14:20:24.851Z</updated>
    
    <content type="html"><![CDATA[<h1>PSM Learning</h1><h2>Role</h2><h2>Step</h2><h2>Noun</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;PSM Learning&lt;/h1&gt;
&lt;h2&gt;Role&lt;/h2&gt;
&lt;h2&gt;Step&lt;/h2&gt;
&lt;h2&gt;Noun&lt;/h2&gt;

      
    
    </summary>
    
    
      <category term="Learning" scheme="https://pingjing0628.github.io/categories/Learning/"/>
    
      <category term="PSM" scheme="https://pingjing0628.github.io/categories/Learning/PSM/"/>
    
    
      <category term="PSM" scheme="https://pingjing0628.github.io/tags/PSM/"/>
    
      <category term="Scrum" scheme="https://pingjing0628.github.io/tags/Scrum/"/>
    
      <category term="Sprint" scheme="https://pingjing0628.github.io/tags/Sprint/"/>
    
  </entry>
  
  <entry>
    <title>Caddy - Installation </title>
    <link href="https://pingjing0628.github.io/2022/12/11/Caddy-Installation/"/>
    <id>https://pingjing0628.github.io/2022/12/11/Caddy-Installation/</id>
    <published>2022-12-11T13:27:27.000Z</published>
    <updated>2022-12-11T14:19:15.478Z</updated>
    
    <content type="html"><![CDATA[<h1>Caddy Installation</h1><h2>Build Caddy</h2><ol><li><p>Download the &lt;a href = 'https://github.com/caddyserver/caddy/releases'&gt;lastest version &lt;/a&gt; of Caddy.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;caddyserver&#x2F;caddy&#x2F;releases&#x2F;download&#x2F;v2.0.0-rc.3&#x2F;caddy_2.0.0-rc.3_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure></p></li><li><p>Unzip<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf caddy_2.0.0-rc.3_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure></p></li><li><p>Move execution file to <code>/usr/bin/</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv caddy &#x2F;usr&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure></p></li></ol><h2>Install Caddy</h2><ol><li><p>Create the group<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd --system caddy</span><br></pre></td></tr></table></figure></p></li><li><p>Create a new user<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd --system \</span><br><span class="line">    --gid caddy \</span><br><span class="line">    --create-home \</span><br><span class="line">    --home-dir &#x2F;var&#x2F;lib&#x2F;caddy \</span><br><span class="line">    --shell &#x2F;usr&#x2F;sbin&#x2F;nologin \</span><br><span class="line">    --comment &quot;Caddy web server&quot; \</span><br><span class="line">    caddy</span><br></pre></td></tr></table></figure></p></li></ol><h2>Log</h2><ol><li><p>Create folder to save logs<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir &#x2F;var&#x2F;log&#x2F;caddy</span><br></pre></td></tr></table></figure></p></li><li><p>Modified folder authority<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R caddy:caddy &#x2F;var&#x2F;log&#x2F;caddy</span><br></pre></td></tr></table></figure></p></li></ol><h2>Create caddyfile</h2><p>Caddy reads its configuration from a file called Caddyfile, stored under /etc/caddy.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">your_domain &#123;</span><br><span class="line">    root * &#x2F;var&#x2F;www</span><br><span class="line">    encode gzip</span><br><span class="line">    file_server</span><br><span class="line">    </span><br><span class="line">    log &#123;</span><br><span class="line">        output file &#x2F;var&#x2F;log&#x2F;caddy&#x2F;service_access.log</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>Service</h2><ol><li><code>/etc/systemd/system</code> create a folder file <code>caddy.service</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Caddy</span><br><span class="line">Documentation&#x3D;https:&#x2F;&#x2F;caddyserver.com&#x2F;docs&#x2F;</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User&#x3D;caddy</span><br><span class="line">Group&#x3D;caddy</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;caddy run --environ --config &#x2F;etc&#x2F;caddy&#x2F;Caddyfile</span><br><span class="line">ExecReload&#x3D;&#x2F;usr&#x2F;bin&#x2F;caddy reload --config &#x2F;etc&#x2F;caddy&#x2F;Caddyfile</span><br><span class="line">TimeoutStopSec&#x3D;5s</span><br><span class="line">LimitNOFILE&#x3D;1048576</span><br><span class="line">LimitNPROC&#x3D;512</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line">ProtectSystem&#x3D;full</span><br><span class="line">AmbientCapabilities&#x3D;CAP_NET_BIND_SERVICE</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li></ol><h2>Caddy system command</h2><ol><li><p>Reload the systemd daemon<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure></p></li><li><p>Automatic start caddy<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable caddy</span><br></pre></td></tr></table></figure></p></li><li><p>Active caddy<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start caddy</span><br></pre></td></tr></table></figure></p></li><li><p>Caddy status<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status caddy</span><br></pre></td></tr></table></figure></p></li><li><p>Reload caddy<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload caddy</span><br></pre></td></tr></table></figure></p></li><li><p>Stop caddy<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop caddy</span><br></pre></td></tr></table></figure></p></li></ol><h2>Functions</h2><h3>Log</h3><p>Enables access logging; the log directive can still be used in v2, but all logs are structured, encoded as JSON, by default.</p><ul><li><p>v1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log access.log</span><br></pre></td></tr></table></figure></p></li><li><p>v2<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log &#123;</span><br><span class="line">output file         access.log</span><br><span class="line">format single_field common_log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><h3>Reverse_proxy</h3><ul><li><p>v1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy &#x2F; localhost:9005</span><br></pre></td></tr></table></figure></p></li><li><p>v2<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse_proxy localhost:9005</span><br></pre></td></tr></table></figure></p></li></ul><h2>SSL certificate</h2><p>Caddy root content is <code>/var/lib/caddy/</code>, where SSL certificate is at<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;caddy&#x2F;.local&#x2F;share&#x2F;caddy&#x2F;certificates</span><br></pre></td></tr></table></figure></p><p>Force update SSL certificate, need delete SSL certificate, and restart Caddy<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;lib&#x2F;caddy&#x2F;.local&#x2F;share&#x2F;caddy&#x2F;certificates&#x2F;acme-v02.api.letsencrypt.org-directory</span><br><span class="line">rm -rf example.com</span><br><span class="line">systemctl restart caddy</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Caddy Installation&lt;/h1&gt;
&lt;h2&gt;Build Caddy&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Download the &amp;lt;a href = &#39;https://github.com/caddyserver/caddy/releases&#39;&amp;gt;l
      
    
    </summary>
    
    
      <category term="Environment" scheme="https://pingjing0628.github.io/categories/Environment/"/>
    
      <category term="Caddy" scheme="https://pingjing0628.github.io/categories/Environment/Caddy/"/>
    
    
      <category term="Caddy" scheme="https://pingjing0628.github.io/tags/Caddy/"/>
    
      <category term="Ubuntu" scheme="https://pingjing0628.github.io/tags/Ubuntu/"/>
    
      <category term="Web server" scheme="https://pingjing0628.github.io/tags/Web-server/"/>
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Advance Tree 高等樹</title>
    <link href="https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Advance-Tree-%E9%AB%98%E7%AD%89%E6%A8%B9/"/>
    <id>https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Advance-Tree-%E9%AB%98%E7%AD%89%E6%A8%B9/</id>
    <published>2022-12-11T13:15:55.000Z</published>
    <updated>2022-12-11T13:15:55.388Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Hashing 雜湊法</title>
    <link href="https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Hashing-%E9%9B%9C%E6%B9%8A%E6%B3%95/"/>
    <id>https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Hashing-%E9%9B%9C%E6%B9%8A%E6%B3%95/</id>
    <published>2022-12-11T13:15:26.000Z</published>
    <updated>2022-12-11T13:15:26.603Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Search &amp; Sort</title>
    <link href="https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Search-Sort/"/>
    <id>https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Search-Sort/</id>
    <published>2022-12-11T13:14:59.000Z</published>
    <updated>2022-12-11T13:14:59.791Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Graph 圖形</title>
    <link href="https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Graph-%E5%9C%96%E5%BD%A2/"/>
    <id>https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Graph-%E5%9C%96%E5%BD%A2/</id>
    <published>2022-12-11T13:14:37.000Z</published>
    <updated>2022-12-11T13:14:37.876Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Binary Tree &amp; Tree</title>
    <link href="https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Binary-Tree-Tree/"/>
    <id>https://pingjing0628.github.io/2022/12/11/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Binary-Tree-Tree/</id>
    <published>2022-12-11T13:13:45.000Z</published>
    <updated>2022-12-11T13:13:45.902Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Linked List 鏈結串列</title>
    <link href="https://pingjing0628.github.io/2022/12/05/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Linked-List-%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97/"/>
    <id>https://pingjing0628.github.io/2022/12/05/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Linked-List-%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97/</id>
    <published>2022-12-05T15:30:28.000Z</published>
    <updated>2022-12-05T15:32:50.246Z</updated>
    
    <content type="html"><![CDATA[<h1>6.4 Linked List 鏈結串列</h1><h2>Linked List</h2><ul><li>Def:</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;6.4 Linked List 鏈結串列&lt;/h1&gt;
&lt;h2&gt;Linked List&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Def:&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="資料結構" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"/>
    
    
      <category term="array" scheme="https://pingjing0628.github.io/tags/array/"/>
    
      <category term="陣列" scheme="https://pingjing0628.github.io/tags/%E9%99%A3%E5%88%97/"/>
    
      <category term="Linked List" scheme="https://pingjing0628.github.io/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Stack and Queue 堆疊與佇列</title>
    <link href="https://pingjing0628.github.io/2022/09/22/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Stack-and-Queue-%E5%A0%86%E7%96%8A%E8%88%87%E4%BD%87%E5%88%97/"/>
    <id>https://pingjing0628.github.io/2022/09/22/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Stack-and-Queue-%E5%A0%86%E7%96%8A%E8%88%87%E4%BD%87%E5%88%97/</id>
    <published>2022-09-22T15:49:06.000Z</published>
    <updated>2022-12-05T15:29:22.596Z</updated>
    
    <content type="html"><![CDATA[<h1>6.3 Stack and Queue 堆疊與佇列</h1><h2>Stack 堆疊</h2><ul><li>Def:</li><li>Stack 基本操作: <strong>ADT(Abstract Data Type)只定義不實作</strong><ol><li>create(s):</li><li>push(i, s):</li><li>isEmpty(s):</li><li>isFull(s):</li><li>top(s):</li><li>pop(i, s):</li></ol></li><li>Ex1:</li><li>Ex2:</li><li>Ex3:</li><li>應用:</li></ul><h3>Stack 的應用</h3><ol><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ol><h3>Stack 之 ADT 的製作方式</h3><h4>以 array 製作 stack</h4><ul><li>資料結構:</li><li>implement:</li></ul><ol><li><p>create<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li><li><p>isEmpty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">3. isFull</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. push</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. pop</span><br></pre></td></tr></table></figure></p></li></ol><pre><code>## Queue 佇列* Def: 為一組元素, 具下列特性 (有序串列):    1. FIFO 之特質    2. 插入(於 rear 尾端)跟刪除(於 front 前端)於不同端點### 提供的基本操作1. create(Q):  2. add(item, Q):  3. delete(item, Q):  4. isEmpty(Q):  5. isFull(Q):  * Ex:  ### Queue 的種類1. 一般的佇列:    * FIFO    * 前端刪除尾端加入  2. Priority queue (Heap)優先權佇列    * 提供:      1. 加入任意值元素      2. 刪除最大(Max-heap)或最小值(Min-heap)元素  3. double ended queue 雙邊佇列    指於 front 和 rear 端皆可做插入跟刪除  4. double ended priority queue 雙邊優先佇列    * 提供:      1. 插入任意元素      2. 刪除最大鍵值元素      3. 刪除最大鍵值元素  ### Queue 的應用1.  2.  3.  4.  ### Queue 之 ADT 製作方式* 資料結構:  * implement    1. create    2. isEmpty    3. isFull    4. add    5. delete  * Note: 上述做法有下列問題  * Ex:    * 思考:      * implement:        1. create:        2. add:        3. delete:    * 特質:      1.      2.      3.    * Note:    * 結論:  ### 中序, 前序, 中序1. **中序式 (infix)**    * Def:    * 適合    * 對  2. **後序式 (postfix)**    * 優點:  3. **前序式 (prefix)**    * 優點:  ### compare### 中序轉後序的方式: 1. 括號法  2. 將之用 binary tree 表示, 再以後序追蹤  3. 利用 stack algorithm  #### 括號法#### 反向考題#### 後序式計算 (同 stack algorithm)* Ex:  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;6.3 Stack and Queue 堆疊與佇列&lt;/h1&gt;
&lt;h2&gt;Stack 堆疊&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Def:&lt;/li&gt;
&lt;li&gt;Stack 基本操作: &lt;strong&gt;ADT(Abstract Data Type)只定義不實作&lt;/strong&gt;
&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="資料結構" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"/>
    
    
      <category term="array" scheme="https://pingjing0628.github.io/tags/array/"/>
    
      <category term="特殊矩陣" scheme="https://pingjing0628.github.io/tags/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%99%A3/"/>
    
      <category term="陣列" scheme="https://pingjing0628.github.io/tags/%E9%99%A3%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Array</title>
    <link href="https://pingjing0628.github.io/2022/09/18/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Array/"/>
    <id>https://pingjing0628.github.io/2022/09/18/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Array/</id>
    <published>2022-09-18T14:33:38.000Z</published>
    <updated>2022-12-05T15:04:59.432Z</updated>
    
    <content type="html"><![CDATA[<h1>6.2 Array</h1><hr><h2>陣列 Array</h2><ul><li>Def: array 用來表示 orderlist 的一種資料結構, 又可稱為 dense list 或 sequential list</li><li>概念: 將 data 的第 i 格元素存到第 i 格子之中</li><li>圖:</li><li>特色: (選擇居多)<ol><li>佔用連續的 mem. space</li><li>array 中放置相同型態的元素, 沒有彈性</li><li>需事先宣告 array 大小, 沒有彈性</li><li>同時支援 random access (O(1)) 及 sequential access (O(n))</li></ol></li></ul><h2>陣列儲存位址計算</h2><ul><li>一維陣列<ol><li>宣告方式1: <code>A[1.....n]</code></li><li>宣告方式2: <code>A[l.....u]</code></li><li>Ex: array: <code>A(-3...9), l0 = 100, d = 4</code>, 問 <code>A[5]</code> 之 location</li></ol><ul><li>Sol: <code>l0 + (i - l) * d = 100 + ( 5-(-3)) * 4 = 132</code></li></ul></li><li>二維陣列<ol><li>宣告方式1: <code>A[1...m, 1...n]</code> -&gt; m列, n行</li></ol><ul><li>計算 <code>A[i, j]</code> 之 location<ol><li><strong>Row Major</strong>:</li></ol><ul><li>公式: <code>l0+[(i-l1)*(u2-l2+1)+(j-l2)]*d</code></li></ul><ol start="2"><li><strong>Column Major</strong>:</li></ol><ul><li>公式: <code>l0+[(j-l2)*(u1-l1+1)+(i-l1)]*d</code></li></ul></li></ul><ol start="2"><li>宣告方式2: <code>A[l1...u1, l2...u2]</code> -&gt; u1-l1+1列, u2-l2+1行</li><li>Ex:</li></ol></li><li>常見題型<ol><li>給定所有值, 求算 <code>A[i, j]</code> 之 location</li></ol><ul><li>Ex: <code>array: A[-3....8, -5....14], l0=100, d=2</code>, 問 <code>A[3, 8]</code> 之 location; 以 Row Major and Column Major<br>Sol:<ol><li>Row Major<br><code>= l0+[(i-l1)*(u2-l2+1)+(j-l2)]*d</code><br><code>= 100+[(3-(-3))*(14-(-5)+1)+(8-(-5))]*2</code><br><code>= 366</code></li><li>Column Major<br><code>= l0+[(j-l2)*(u1-l1+1)+(i-l1)]*d</code><br><code>= 100+[(8-(-5))*(8-(-3)+1)+(3-(-3))]*2</code><br><code>= 424</code></li></ol></li></ul><ol start="2"><li>給予2個已知量: <code>A[i1, j1], A[i2, j2]</code>, 求 <code>A[i, j]</code> 之 location</li></ol><ul><li>Note: 無法取得 <code>l0, d</code>, 而已知 <code>A[i1, j1] &lt; A[i2, j2]</code>, 則<ol><li>Row Major:<br><code>A[i2, j2] = A[i1, j1] + [(i2-i1)*n+(j2-j1)]*1</code></li><li>Column Major:<br><code>A[i2, j2] = A[i1, j1] + [(j2-j1)*m+(i2-i1)]*1</code></li></ol></li><li>Row Major 中可以推得 <strong>&quot;行&quot;</strong>, &quot;列&quot;不得而知</li><li>Column Major 中可以推得 <strong>&quot;列&quot;</strong>, &quot;行&quot;不得而知</li><li>Ex: <code>A[4, 2]</code> 之 address = 1978, <code>A[2, 3]</code> 之 address = 1986, 問 <code>A[3, 8]</code> 之 address = ?<br>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Step1: check Row Major or Column Major</span><br><span class="line">A[4, 2] &#x3D; 1978</span><br><span class="line">A[2, 3] &#x3D; 1986  &#x2F;&#x2F; Column Major</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Step2: </span><br><span class="line">&#x2F;&#x2F; 求 行 &#x3D;&gt; 當為 Row Major, 可求得行數 </span><br><span class="line">&#x2F;&#x2F; 求 列 &#x3D;&gt; 當為 Column Major, 可求得列數 </span><br><span class="line">A[2, 3] &#x3D; A[4, 2] + [(3-2) * m + (2-4)]*1</span><br><span class="line">1986 &#x3D; 1978+m-2</span><br><span class="line">m &#x3D; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Step3: 求 A[i, j]</span><br><span class="line">A[3, 8] &#x3D; A[4, 2] + [(8-2)*10+(3-4)]*1</span><br><span class="line">        &#x3D; 1978+59</span><br><span class="line">        &#x3D; 2037</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>同題型2, 但無法判別 Row Major or Column Major</li></ol><ul><li>Ex: <code>A[3, 3]</code> 之 address = 121, <code>A[6, 4]</code> 之 address = 159, 問 <code>A[4, 9]</code> 之 address = ?<br>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Step1: check Row Major or Column Major</span><br><span class="line">A[3, 3] &#x3D; 121</span><br><span class="line">A[6, 4] &#x3D; 159  &#x2F;&#x2F; Row Major or Column Major 皆有可能</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Step2: </span><br><span class="line">&#x2F;&#x2F; 1. Row Major</span><br><span class="line">A[6, 4] &#x3D; A[2, 2] + [(6-3) * n + (4-3)]*1</span><br><span class="line">159 &#x3D; 121+3n+1</span><br><span class="line">n &#x3D; 37&#x2F;3 &#x3D; 12.33333 &#x2F;&#x2F;不符合</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. Column Major</span><br><span class="line">A[6, 4] &#x3D; A[2, 2] + [(4-3) * m + (6-3)]*1</span><br><span class="line">159 &#x3D; 121+m+3</span><br><span class="line">m &#x3D; 35 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Step3: 求 A[i, j], 以 Column Major</span><br><span class="line">A[4, 9] &#x3D; A[3, 3] + [(9-3)*35+(4-3)]*1</span><br><span class="line">        &#x3D; 121+211</span><br><span class="line">        &#x3D; 332</span><br></pre></td></tr></table></figure></li></ul></li><li>三維陣列<ul><li>宣告方式: <code>A(1...u1, 1...u2, 1...u3)</code></li><li>計算:<ol><li>Row Major <code>A[i, j, k] 之 location</code></li></ol><ul><li>公式: <code>l0+[(i-1)*u2*u3+(j-1)*u3+(k-1)]*d</code></li></ul><ol start="2"><li>Column Major <code>A[i, j, k] 之 location</code></li></ol><ul><li>公式: <code>l0+[(k-1)*u2*u1+(j-1)*u1+(i-1)]*d</code></li></ul></li></ul></li></ul><h2>多項式的資料結構</h2><ul><li>方法:<ol><li>依指數由高 -&gt; 低, 依序儲存其係數</li></ol><ul><li>Ex: 當多項式的最高係數為 n 時, 需準備 n+2 格<br>-&gt; 缺點: 若非0項極少時不適用, <code>f(x) = 2^1000 +9 =&gt; k=2</code> =&gt; 準備 <code>A[1...5]</code></li></ul><ol start="2"><li>只存放非零項次的係數與指數</li></ol><ul><li>作法: 若非0項有 &quot;k&quot; 個 -&gt; 準備 2k+1 個格子</li></ul><ol start="3"><li>利用 linked list 表示</li></ol></li></ul><h2>特殊矩陣</h2><h3>稀疏矩陣</h3><ul><li>指矩陣的非零項元素很少</li><li>Ex: 矩陣 A4x3</li><li>3-turple<ul><li>說明: 準備一二維陣列 <code>A(0...k, 1...3)</code>, 其中 k 代表非零項的數量</li><li>以上例而言, k = 3, 故準備 <code>A[0...3, 1...3]</code></li></ul></li></ul><h3>上三角, 下三角矩陣</h3><ul><li>說明:<ul><li>上三角: 即對角線以下的元素皆0, aij = 0, if i &gt; j</li><li>下三角: 即對角線以上的元素皆0, aij = 0, if i &lt; j</li></ul></li><li>特色: 一 n * n 的上或下三角矩陣其元素共有:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1+2+...+n &#x3D; n(n+1) &#x2F; 2</span><br><span class="line">&#x3D;&gt; 若採用 &quot;二維陣列&quot;, 則</span><br><span class="line">&#x3D;&gt; 浪費 space n^2-n(n+1)&#x2F;2</span><br><span class="line"></span><br><span class="line">Solution:</span><br><span class="line">利用一維陣列 B[1....n(n+1)&#x2F;2]</span><br><span class="line">來將上 下三角之資料一一對應</span><br></pre></td></tr></table></figure></li><li>上三角<ul><li>Row Major</li><li>Column Major</li></ul></li><li>下三角<ul><li>Row Major</li><li>Column Major</li></ul></li></ul><h3>對稱矩陣</h3><ul><li>定義: 一矩陣 An*n: 若 Aij = Aji謂之, 有效率地存放方式, 只存上 or 下三角即可</li><li>上三角: <code>aij : k = j(j-1)/2 +i</code></li><li>下三角: <code>k = i()i-1/2 + i</code></li><li>合併為單一公式: <code>max(i, j) * (max(i, j)-1)/2 + min(i, j)</code></li><li>Ex:</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;6.2 Array&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;陣列 Array&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Def: array 用來表示 orderlist 的一種資料結構, 又可稱為 dense list 或 sequential list&lt;/li&gt;
&lt;li&gt;概念: 將 data 
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="資料結構" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"/>
    
    
      <category term="array" scheme="https://pingjing0628.github.io/tags/array/"/>
    
      <category term="特殊矩陣" scheme="https://pingjing0628.github.io/tags/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%99%A3/"/>
    
      <category term="陣列" scheme="https://pingjing0628.github.io/tags/%E9%99%A3%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Algorithm&#39;s Time Complexity and Recursive Program</title>
    <link href="https://pingjing0628.github.io/2022/06/20/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Algorithm-s-Time-Complexity-and-Recursive-Program/"/>
    <id>https://pingjing0628.github.io/2022/06/20/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Algorithm-s-Time-Complexity-and-Recursive-Program/</id>
    <published>2022-06-19T16:24:09.000Z</published>
    <updated>2022-09-22T15:40:45.792Z</updated>
    
    <content type="html"><![CDATA[<h1>6.1 Algorithm 的時間複雜度及遞迴程式</h1><hr><h2>algorithm 演算法</h2><ul><li>為指令之集合, 用以達到某一特定之任務</li><li>需滿足:<ol><li>input ≥ 0 個</li><li>output ≥ 1 個</li><li>definiteness 明確性: 指令皆是清楚且不模糊的</li><li>finiteness 有限性: 在有限的指令數之後會求得結果</li><li>effectiveness 有效性: 只可利用紙,筆即可追蹤</li></ol></li><li>Note:<br>Program vs Algorothm =&gt; 差別在於4, Program 可以有無窮迴圈</li></ul><h2>Time Complexity 時間複雜度</h2><ul><li><p>Def:</p><ul><li>用來衡量 algorithm 執行時間</li><li>利用時間函數: <code>T(n)</code> 表示 <strong>隨著資料量的成長, 所需的執行次數之變動</strong></li></ul></li><li><p>Ex1: 時間函數計算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 1;</span><br><span class="line">while (i &lt;&#x3D; n)</span><br><span class="line">&#123;</span><br><span class="line">  x &#x3D; x+1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 問 line 4 執行次數?</span><br><span class="line">&#x2F;&#x2F; Sol: T(n) &#x3D; n</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">  for(j &#x3D; i+1; j &lt;&#x3D; n; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    x &#x3D; x+1;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 問 line5 的執行次數?</span><br><span class="line">&#x2F;&#x2F; Sol: T(n) &#x3D; n(n-1) &#x2F; 2</span><br></pre></td></tr></table></figure></p></li></ul><table><thead><tr><th>i</th><th>1</th><th>2...</th><th>n</th></tr></thead><tbody><tr><td>j</td><td>2~n</td><td>3~n</td><td>n+1~n</td></tr><tr><td>x=x+1</td><td>n-1</td><td>n-2</td><td>0</td></tr></tbody></table><ul><li>思考:<br>2n+1<br>2n-1<br>n+2<br>n+100<br><code>n大到一定程度, +1 -1....不重要</code></li></ul><h2>漸進式表示法 asymptotic notation</h2><ul><li>於 Time Complexity 中, 常用漸進式來表示一 algo 的時間的成長漸進曲線, 以便快速了解 algo 之複雜程度</li><li>衡量方式:<ol><li>Big Oh: upper bound of <code>ƒ(n)</code></li><li>Omega: lower bound of <code>ƒ(n)</code></li><li>Theta: more precision than Big Oh and Omega</li></ol></li><li>概念:</li></ul><h3>Big Oh</h3><ul><li>Def: 若 <code>ƒ(n)</code> 為一時間函數, 則 <code>ƒ(n) = O(g(n))</code> , if and only if 存在兩正數 c 和 n0, 使得 <code>ƒ(n) ≤ c * g(n)</code> , for all n ≥ n0</li><li>Ex1: <code>ƒ(n) = 3n + 2</code>  =&gt; <strong>O(n)</strong> , 因為存在 2 正數, <code>c = 4, n0 = 2</code>, 此時, <code>3n+2 ≤ 4*n</code>, for all n ≥ 2</li></ul><blockquote><p>定理： <code>ƒ(n) = am*n^m + am-1*n^m-1 +...+ a1*n^1 + a0*n^0</code>, 其中 m 為最高指數項, 則 <code>ƒ(n) = O(n^m)</code></p></blockquote><ul><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ƒ(n) &#x3D; 3n^5 + 2n^3 + 1000 &#x3D;&gt; O(n^5)</span><br><span class="line">ƒ(n) &#x3D; 2^n + 1000 &#x3D;&gt; O(2^n)</span><br><span class="line">ƒ(n) &#x3D; 100 &#x3D;&gt; O(1) 常數</span><br></pre></td></tr></table></figure></p></li><li><p>Ex3: O(logn^2) vs O(n) 誰大?<br><code>= 2log n &lt; O(n)</code><br>2 常數不看</p></li></ul><ul><li><p>常見的 Big Oh: 由小 -&gt; 大排序O(1) &lt; O(log n) &lt; O(n) &lt; O(nlog n) &lt; O(n^2) &lt; O(n^3) &lt;...&lt; O(n^c) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)<br>越大越複雜</p></li><li><p>Proof: <code>ƒ(n) = am*n^m + ...+ a1*n^1 + a0*n^0 = O(n^m)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D; ∑ai*n^i ≤ ∑|ai|n^i</span><br><span class="line">          ≤ n^m * ∑|ai|n^i-m</span><br><span class="line">          ≤ n^m * ∑|ai|1</span><br><span class="line">          , for all n ≥ 1</span><br><span class="line">所以故為 O(n^m)</span><br></pre></td></tr></table></figure></p></li></ul><h3>Omega</h3><ul><li>Def: 若 ƒ(n) 為一時間函數, 則 <code>ƒ(n) = O(g(n))</code>, if and only if 存在兩正數 C 和 n0, 使得 <code>ƒ(n) ≥ c * g(n)</code>, for all n ≥ n0</li></ul><h2>常見的 Time complexity 求算</h2><ul><li><p>Ex1: <code>T(n) = T(n-1) + n</code> -&gt; 快速排序的 worst case<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">T(n) &#x3D; T(n-1) + n</span><br><span class="line">     &#x3D; [T(n-2) + n-1] + n</span><br><span class="line">     &#x3D; [T(n-3) + n-2] + n-1 + n</span><br><span class="line">     &#x3D; [T(n-4) + n-3] + n-2 + n-1 + n</span><br><span class="line">     ....</span><br><span class="line">     &#x3D; T(n-n) +1+2+...+n</span><br><span class="line">     &#x3D; (n(n+1))&#x2F;2</span><br><span class="line">     &#x3D; (n^2+n)&#x2F;2</span><br><span class="line">     &#x3D;&gt; O(n^2)</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2: <code>T(n) = 2T(n/2)+n</code>, 求 O(?) -&gt; 快速排序的 Best case<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">T(n) &#x3D; 2T(n&#x2F;2) + n</span><br><span class="line">     &#x3D; 2[2T(n&#x2F;4) + n&#x2F;2] + n</span><br><span class="line">     &#x3D; 4T(n&#x2F;4) + 2n</span><br><span class="line">     &#x3D; 4[2T(n&#x2F;8) + n&#x2F;4] + 2n</span><br><span class="line">     &#x3D; 8T(n&#x2F;8) + 3n</span><br><span class="line">     ....</span><br><span class="line">     &#x3D; nT(n&#x2F;n) + logn*n</span><br><span class="line">     &#x3D; n + nlogn</span><br><span class="line">     &#x3D;&gt; O(nlogn)</span><br></pre></td></tr></table></figure></p></li><li><p>Ex3: <code>T(n) = T(n/2) + 1</code>, 求 O(?)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T(n) &#x3D; T(n&#x2F;2) + 1 &#x2F;&#x2F; Binary Search</span><br><span class="line">     &#x3D; [T(n&#x2F;4) + 1] + 1</span><br><span class="line">     &#x3D; T(n&#x2F;4) + 2</span><br><span class="line">     &#x3D; [T(n&#x2F;8) + 1] + 2</span><br><span class="line">     &#x3D; T(n&#x2F;8) + 3</span><br><span class="line">     ...</span><br><span class="line">     &#x3D; T(n&#x2F;n) + log2 n</span><br><span class="line">     &#x3D;&gt; O(log n)</span><br></pre></td></tr></table></figure></p></li></ul><h2>Recursive 遞迴</h2><ul><li><p>Def: 指函式執行過程反覆呼叫自身函式 =&gt; <strong>self-calling</strong></p></li><li><p>種類:</p><ol><li><p><strong>直接 recursive</strong>: 在程式中直接呼叫自身<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fun() &#x2F;&#x2F; self-calling</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><strong>間接 recursive</strong>: 在程式中先呼叫其他函式, 再由他呼叫到原本的程式</p></li></ol><ul><li>Note: 不建議採用, 易發生後續維護上的不易性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">funA()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  funB()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funB()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  funA()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; calling cycle</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>尾端 recursive</strong>: 函式會在最後再次呼叫自身</li></ol><ul><li>建議改採用 &quot;iterative&quot;(non-recursive) 方式撰寫, 以提高效能 -&gt; 做 loop 快, 比做 context-switching 快, 節省時間和空間</li><li>Note:<ul><li>recursive 會採用到系統的「stack」 後進先出</li><li>recursive &amp; non-recursive 適用性, 沒有誰好誰壞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3>Recursive vs Non-Recursive (iterative/loop)</h3><ul><li>Recursive<ul><li>優點:<ul><li>特性:<ul><li>程式精簡 -&gt; 程式較省 space</li><li>易理解</li><li>表達力更佳</li></ul></li><li>Space<ul><li>暫存變數需求少 (int, temp...)</li></ul></li></ul></li><li>缺點:<ul><li>Space<ul><li>執行時需耗用 &quot;stack&quot; 空間 -&gt; 需系統 stack 支援(會一直追加 Mem.)</li></ul></li><li>Time<ul><li>執行時間較久 -&gt; 效率較差(因為需做 function calling)</li></ul></li></ul></li></ul></li><li>Non-recursive<ul><li>優點:<ul><li>Space<ul><li>執行時不需耗用 &quot;stack&quot; 空間</li></ul></li><li>Time<ul><li>執行時間較快 -&gt; 效率較好</li></ul></li></ul></li><li>缺點:<ul><li>特性:<ul><li>程式冗長</li><li>不易理解</li><li>表達力較差</li></ul></li><li>Space<ul><li>暫存變數需求多</li></ul></li></ul></li></ul></li></ul><h3>常見的 Recursive</h3><h4>Example1: N!</h4><ul><li>提示:<ul><li>N! = 1, if N = 0</li><li>N! = N * (N-1)!. if N ≥ 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int F(int N) </span><br><span class="line">&#123;</span><br><span class="line">  if (N &#x3D;&#x3D; 0)</span><br><span class="line">    return 1;</span><br><span class="line">  else</span><br><span class="line">    return N * F(N-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>呈上例: 問 <code>F(3)</code> = ? 又呼叫 <code>F()</code> 幾次?</li><li>Sol: <code>F(3) -&gt; 3*F(2) -&gt; 2*F(1) -&gt; 1 * F(0)</code>, <code>F(3) = 6</code>, 呼叫 <code>F()</code> 4次</li><li>iterative:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum(int n)</span><br><span class="line">int sum &#x3D; 1, i;</span><br><span class="line">&#123;</span><br><span class="line">  for (i&#x3D;1; i ≤ n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum &#x3D; sum * i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4>Example2: Sum(n) = 1+2+...+n 寫出其 Recursive algo.</h4><ul><li>提示:<ul><li>sum(n) = 0, if n = 0</li><li>sum(n-1) + n, if n = 1, otherwise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int sum(n)</span><br><span class="line">&#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 0)</span><br><span class="line">    return 0;</span><br><span class="line">  else</span><br><span class="line">    return sum(n-1) + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; iterative</span><br><span class="line">int sum(int n)</span><br><span class="line">int sum &#x3D; 0, i;</span><br><span class="line">&#123;</span><br><span class="line">  for (i&#x3D;1; i ≤ n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum &#x3D; sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4>Example3: 費氏數列 (Fibonacci Number)</h4><ul><li>提示:<ul><li>Fn = 0, if n = 0</li><li>Fn = 1, if n = 1</li><li>Fn = Fn-1 + Fn-2, otherwise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int F(int n)</span><br><span class="line">&#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 0)</span><br><span class="line">    return 0;</span><br><span class="line">  else if (n &#x3D;&#x3D; 1)</span><br><span class="line">    return 1;</span><br><span class="line">  else</span><br><span class="line">    return F(n-1) + F(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><table><thead><tr><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>Fn</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td><td>55</td></tr></tbody></table><ul><li><p>呈上例, 問 <code>F(5)</code> = ? 又呼叫 <code>F()</code> 幾次?</p></li><li><p>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F(5) &#x3D; F(4) + F(3)</span><br><span class="line">     &#x3D; F(3) + F(2) + F(2) + F(1)</span><br><span class="line">     &#x3D; F(2) + F(1) + F(1) + F(0) + F(1) + F(0)</span><br><span class="line">     &#x3D; F(1) + F(0) + F(1) + F(1) + F(0) + F(1) + F(0)</span><br><span class="line">&#x2F;&#x2F; F(5) &#x3D; 5, 含 F(5) 本身共呼叫 15 次</span><br></pre></td></tr></table></figure></p></li><li><p>Note: 變形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1)</span><br><span class="line"> return 1;</span><br><span class="line">else</span><br><span class="line">  return F(n-1) + F(n-2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Non-recursive algo</span><br><span class="line">int F(int n)</span><br><span class="line">&#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 0)</span><br><span class="line">    return 0;</span><br><span class="line">  else if (n &#x3D;&#x3D; 1)</span><br><span class="line">    return 1;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    int a &#x3D; 0, b &#x3D; 1, c, i;</span><br><span class="line">    for (i&#x3D;2; i ≤ n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      c &#x3D; a + b;</span><br><span class="line">      a &#x3D; b;</span><br><span class="line">      b &#x3D; c;</span><br><span class="line">      &#x2F;&#x2F; O(n)</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><table><thead><tr><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>Fn</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td><td>55</td><td>89</td></tr></tbody></table><ul><li>若 n 輸入 -3, 問結果?<ul><li>因為 recursive 會耗用 stack, 而 -3 無法收斂, 故 stack 會耗盡 -&gt; stack out of memory</li></ul></li></ul><h4>Example4: G.C.D (Greatest Common Divison) 最大公因數</h4><ul><li><p>提示:</p><ul><li>G.C.D(A, B) = B, if (A mod B) = 0</li><li>G.C.D(A, B) = GCD(B, A mod B), if (A mod B) 不等於 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int GCD(int A, int B)</span><br><span class="line">&#123;</span><br><span class="line">  if (A % B &#x3D;&#x3D; 0)</span><br><span class="line">    return B;</span><br><span class="line">  else</span><br><span class="line">    return GCD(B, A % B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>呈上例, GCD(12, 9) = ?</p></li><li><p>Sol: GCD(12, 9) -&gt; GCD(9, 3) -&gt; 3</p></li><li><p>又 GCD(9, 12) = ?</p></li><li><p>Sol: GCD(9, 12) -&gt; GCD(12, 9) -&gt; GCD(9, 3) -&gt; 3</p></li><li><p>iterative<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int GCD (int A, int B)</span><br><span class="line">&#123;</span><br><span class="line">  while (A !&#x3D; 0 &amp;&amp; B !&#x3D; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    if (A &gt; B)</span><br><span class="line">      A &#x3D; A % B; &#x2F;&#x2F; 把餘數給 A, 一直到有一數為 0</span><br><span class="line">    else</span><br><span class="line">      B &#x3D; B % A</span><br><span class="line">  &#125;</span><br><span class="line">  if (A &#x3D;&#x3D; 0)</span><br><span class="line">    return B;</span><br><span class="line">  else</span><br><span class="line">    return A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><h4>Example5: Binomial coefficient 二項式係數</h4><ul><li><p>說明:<br><img src="Binomial1.png" alt=""></p></li><li><p>提示:<br><img src="Binomial2.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int B(int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">  if (m &#x3D;&#x3D; 0 || n &#x3D;&#x3D; m)</span><br><span class="line">    return 1;</span><br><span class="line">  else</span><br><span class="line">    return B(n-1, m) + B(n-1, m-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex1:<br><img src="Binomial3.png" alt=""></p></li><li><p>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">B(5, 2) &#x3D; B(4, 2) + B(4, 1)</span><br><span class="line">        &#x3D; B(3, 2) + B(3, 1) + B(3, 1) + B(3, 0)</span><br><span class="line">        &#x3D; B(2, 2) + B(2, 1) + B(2, 1) + B(2, 0) + B(2, 1) + B(2, 0)</span><br><span class="line">        &#x3D; B(1, 1) + B(1, 0) + B(1, 1) + B(1, 0) + B(1, 1) + B(1, 0)</span><br><span class="line">&#x2F;&#x2F; B(5, 2) &#x3D; 10</span><br><span class="line">&#x2F;&#x2F; 含 B(5, 2) 本身就呼叫 19 次</span><br></pre></td></tr></table></figure></p></li><li><p>思考: 請用更有效率的方法 iterative<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int B(int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">  int a &#x3D; 1, b &#x3D; 1, c &#x3D; 1;</span><br><span class="line">  for (int i &#x3D; 1; i ≤ n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    a &#x3D; a * i; &#x2F;&#x2F;n!</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 1; i ≤ m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    b &#x3D; b * i; &#x2F;&#x2F; m!</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 1; i ≤ n-m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    c &#x3D; c * i; &#x2F;&#x2F; (n-m)!</span><br><span class="line">  &#125;</span><br><span class="line">  return a&#x2F;(b*c);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 易有 overflow</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Solution:</span><br><span class="line">&#x2F;&#x2F; k &#x3D; max(n-m, m)</span><br><span class="line">for (int i &#x3D; n; i &gt; k; i--)</span><br><span class="line">&#123;</span><br><span class="line">  a &#x3D; a * i;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 1; i ≤ n-k; i++)</span><br><span class="line">&#123;</span><br><span class="line">  b &#x3D; b * i;</span><br><span class="line">&#125;</span><br><span class="line">return a &#x2F; b;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 將後面剔除可減少, 但不知哪個數值較大, 因此需要找出較大值, 將其除掉</span><br></pre></td></tr></table></figure></p></li></ul><h4>Example6: Ackerman's</h4><ul><li><p>背: <code>A(1, 2) = 4, A(2, 1) = 5, A(2, 2) = 7</code></p></li><li><p>提示:</p><ul><li><code>A(m, n) = n+1, if m = 0</code></li><li><code>A(m-1, 1), if n = 0</code></li><li><code>A(m-1, A(m, n-1)), otherwise</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int A(int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">  if (m &#x3D;&#x3D; 0)</span><br><span class="line">    return n+1;</span><br><span class="line">  else if</span><br><span class="line">    return A(m-1, 1);</span><br><span class="line">  else</span><br><span class="line">    return A(m-1, A(m, n-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>呈上例: <code>A(2, 2)</code> = ?, 又 <code>A()</code> 呼叫幾次?</p></li><li><p>Sol: 7, 呼叫27次</p></li></ul><h4>Example7: Tower of Hanoi (河內塔)</h4><ul><li><p>說明: 3 pegs(柱子) problem</p></li><li><p>Recursive algorithm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Hanoi (n:disc, A, B, C:pegs)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; A 來源, B 中繼, C 目的</span><br><span class="line">  if (n &#x3D;&#x3D; 1)</span><br><span class="line">    move disc from A to C;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    Hanoi(n-1, A, C, B); &#x2F;&#x2F; 1</span><br><span class="line">    move the disc n from A to C; &#x2F;&#x2F; 2</span><br><span class="line">    Hanoi(n-1, B, A, C); &#x2F;&#x2F; 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex1: 試列出 n = 3 的移動順序</p></li><li><p>Sol:</p><ol><li>move 1 from A to C</li><li>move 2 from A to B</li><li>move 1 from C to B</li><li>move 3 from A to C</li><li>move 1 from B to A</li><li>move 2 from B to C</li><li>move 1 from A to C</li></ol></li><li><p>Ex2: 令<code>T(n)</code>為搬動 n 個 disc, 所需的次數, 則 <code>T(n) = T(n-1) + 1 + T(n-1)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T(n) &#x3D; T(n-1) + 1 + T(n-1)</span><br><span class="line">     &#x3D; 2T(n-1) + 1</span><br><span class="line">     &#x3D; 2[2T(n-2) + 1] + 1</span><br><span class="line">     &#x3D; 4T(n-2) + 3</span><br><span class="line">     &#x3D; 4[2T(n-3) + 1] + 3</span><br><span class="line">     &#x3D; 8T(n-3) + 7</span><br><span class="line">     ...</span><br><span class="line">     &#x3D; 2^n * T(n-n) + 2^n - 1</span><br><span class="line">     &#x3D; 2^n - 1</span><br><span class="line">&#x2F;&#x2F; 時間複雜度為 O(2^n)</span><br></pre></td></tr></table></figure></p></li></ul><h4>Example8: Permutation (排列組合)</h4><ul><li><p>概念:</p><ul><li>n個 data 會有 n! 種組合</li><li>Ex: data a, b, c 之 permutation, 若有 3 筆data =&gt; 3! = 3 * 2 * 1 = 6</li><li>abc, acb, bac, bca, cab, cba</li></ul></li><li><p>思考: <code>Perm(a, b, c)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a + perm(b, c)</span><br><span class="line">b + perm(a, c)</span><br><span class="line">c + perm(b, a)</span><br></pre></td></tr></table></figure></p></li><li><p>Recursive (in C)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void perm (char list[], int i , int n)</span><br><span class="line">&#123;</span><br><span class="line">  if (i &#x3D;&#x3D; n)</span><br><span class="line">  &#123;</span><br><span class="line">    for (int j &#x3D; 1; j ≤ n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;%c&quot;, list[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    for (int j &#x3D; i; j ≤ n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      swap(list[i], list[j]);</span><br><span class="line">      perm(list, i+1, n);</span><br><span class="line">      swap(list[i], list[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;6.1 Algorithm 的時間複雜度及遞迴程式&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;algorithm 演算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;為指令之集合, 用以達到某一特定之任務&lt;/li&gt;
&lt;li&gt;需滿足:
&lt;ol&gt;
&lt;li&gt;input ≥ 0 個&lt;/li&gt;
&lt;li&gt;outp
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="資料結構" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"/>
    
    
      <category term="algorithm" scheme="https://pingjing0628.github.io/tags/algorithm/"/>
    
      <category term="漸進式表示法" scheme="https://pingjing0628.github.io/tags/%E6%BC%B8%E9%80%B2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    
      <category term="時間複雜度" scheme="https://pingjing0628.github.io/tags/%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6/"/>
    
      <category term="遞迴" scheme="https://pingjing0628.github.io/tags/%E9%81%9E%E8%BF%B4/"/>
    
      <category term="費氏數列" scheme="https://pingjing0628.github.io/tags/%E8%B2%BB%E6%B0%8F%E6%95%B8%E5%88%97/"/>
    
      <category term="Ackermans" scheme="https://pingjing0628.github.io/tags/Ackermans/"/>
    
      <category term="河內塔" scheme="https://pingjing0628.github.io/tags/%E6%B2%B3%E5%85%A7%E5%A1%94/"/>
    
      <category term="排列組合" scheme="https://pingjing0628.github.io/tags/%E6%8E%92%E5%88%97%E7%B5%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-JAVA</title>
    <link href="https://pingjing0628.github.io/2022/06/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-JAVA/"/>
    <id>https://pingjing0628.github.io/2022/06/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-JAVA/</id>
    <published>2022-06-19T16:16:31.000Z</published>
    <updated>2022-09-20T14:42:05.793Z</updated>
    
    <content type="html"><![CDATA[<h1>5.5 JAVA</h1><hr><h2>Java VS C++</h2><table><thead><tr><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>Pure O.O language, 因為主程式都在 class 中</td><td>較不 pure</td></tr><tr><td>No pointer</td><td>有 pointer</td></tr><tr><td>Single Inheritance</td><td>Multiple Inheritance</td></tr><tr><td><strong>利用 garbage collection</strong>, 不需有destructor</td><td><strong>沒有 garbage collection</strong>, 需有destructor</td></tr><tr><td>interpret language, speed 較慢</td><td>compile language, speed 較快</td></tr><tr><td>Cross platform</td><td>沒有跨平台</td></tr><tr><td>安全性佳, 因為JVM (有類別驗證器)</td><td>安全性較差</td></tr><tr><td>support open source 較多</td><td>較少</td></tr></tbody></table><blockquote><p>Garbage Collection(垃圾回收): 指不要的 Mem. 會由系統來進行自動回收的機制 =&gt; 回收 programmer 不需介入, 所以不須 destructorNote: java 中的 thread 的環境有較妥善的機制和方便 api 供 user 使用</p></blockquote><h2>Class 格式</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class class_name</span><br><span class="line">&#123;</span><br><span class="line">  constructor -&gt; object initial</span><br><span class="line">  att -&gt; 變數宣告</span><br><span class="line">  method -&gt; function define</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>Ex:</li></ul><h2>Constructor (建構子)</h2><ul><li>和 C++ 概念相似</li><li>O.O 中所有物件皆需 <strong>&quot;初始化&quot;</strong> =&gt; 一定要呼叫 constructor</li><li>當 class 無 constructor, 系統會補上 <strong>預設建構子</strong><ul><li>Default constructor:<ol><li>權限同 class</li><li>Parameter list 為空</li><li>Constructor code 為空</li></ol></li></ul></li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class A </span><br><span class="line">&#123;</span><br><span class="line">  public A () &#123;&#125; &#x2F;&#x2F; 自動補上 default constructor</span><br><span class="line">  &#x2F;&#x2F; public 1</span><br><span class="line">  &#x2F;&#x2F; () 2</span><br><span class="line">  &#x2F;&#x2F; &#123;&#125; 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>主程式</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">  public static void main(string [] args)</span><br><span class="line">  &#123;</span><br><span class="line">    ...  &#x2F;&#x2F;進入點</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">  public static void main() &#x2F;&#x2F; ()非主程式</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1. compile error</span><br><span class="line">2. runtime error</span><br><span class="line">3. No error</span><br><span class="line">Ans: 2</span><br><span class="line">出現 &quot;main method not found&quot;</span><br></pre></td></tr></table></figure></p><h2>配置物件 Mem.space =&gt; &quot;new&quot;</h2><ul><li>格式： <code>class object = new class 建構子 (...欲傳入的參數);</code></li><li>Ex:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person p &#x3D; new Person();</span><br><span class="line">&#x2F;&#x2F; new 正式做 Memory allocation</span><br><span class="line">&#x2F;&#x2F; Person() 呼叫 class Person 不帶參數的 constructor</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.height &#x3D; 180;</span><br><span class="line">&#x2F;&#x2F; in C ,Yes</span><br><span class="line">&#x2F;&#x2F; in Java , 尚未配置 Mem space</span><br></pre></td></tr></table></figure></li><li>Note: 物件操作方式同 C++, <code>object.att</code> or <code>object.op</code></li></ul><h2>Inheritance 繼承</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>downcasting 向下轉型</th><th>upcasting 向上轉型</th></tr></thead><tbody><tr><td>將父類別物件視為子類別型態</td><td>相反</td></tr><tr><td>有 risk, compiler 擋掉</td><td>沒有 risk</td></tr></tbody></table><ul><li>圖：</li><li>EX:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p &#x3D; new Superman(); &#x2F;&#x2F; superman upcasting</span><br><span class="line">Superman s &#x3D; new Person(); &#x2F;&#x2F; person downcasting</span><br><span class="line">Superman s &#x3D; new Xman(); &#x2F;&#x2F; X</span><br></pre></td></tr></table></figure></li></ul><h2>Overriding</h2><ul><li><p>子類別把父類別的函式重新定義<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public void iam()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;I am a Person&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Superman extends Person</span><br><span class="line">&#123;</span><br><span class="line">  public void iam()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;I am a Superman&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>注意：</p><ol><li><strong>method signature 方法簽章</strong> 要一樣</li></ol><ul><li>return type + method name + (parameter list)</li><li>Ex:<ul><li>superclass: double getValue()... <code>// compile error 多型會錯</code></li><li>subclass: string getValue()...</li></ul></li><li>Ex2:<ul><li>superclass: void print(int i)... <code>沒有 overriding 為 overloading, compile OK</code></li><li>subclass void print()...</li></ul></li></ul><ol start="2"><li>Subclass 的存取權限要 <strong>≥</strong> superclass 的存取權限, 為避免多型有誤</li></ol><ul><li>Note: <code>public &gt; protected &gt; private</code></li></ul></li></ul><h2>this, super</h2><ul><li>概念同 C++, 但 <strong>Java 中 this, super 非 pointer</strong>, 其用法同一般物件, <code>this/super.att/method</code></li><li>圖：</li><li>Ex:</li></ul><h2>Constructor 的進一步介紹 (constructor 的延伸)</h2><ul><li><p>constructor 不會被繼承</p></li><li><p>在 inheritance之下, subclass 的 constructor 第一行需呼叫 &quot;super(...)&quot; (若無, 系統會自動加上&quot;super()&quot; 呼叫 parent, 不帶任何參數的 constructor) =&gt; 呼叫父類別的建構子產生 parent object</p></li><li><p>處理的順序(初始化時)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">  public A() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line">  public B() &#123;</span><br><span class="line">    super();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>常見陷阱題：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">  public A(int a)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A</span><br><span class="line">&#123;</span><br><span class="line">  public B() &#x2F;&#x2F; default constructor</span><br><span class="line">  &#123;</span><br><span class="line">    super(); &#x2F;&#x2F; 系統補上的, 找不到不帶參數的建構子</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Result: compile error</span><br></pre></td></tr></table></figure></p></li><li><p>Summary:</p><ol><li>No constructor =&gt; 補上 default constructor</li><li>若為 subclass 之 constructor 第一行無 &quot;super(...)&quot;, 自動補上 &quot;super(...)&quot; (不帶任何參數的)</li></ol></li><li><p>Ex:</p></li></ul><h2>Java 的例外處理 (Exception Handler)</h2><ul><li>於 Java 中採用 try...catch...finally 來做例外處理</li><li>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  &#x2F;&#x2F; 嘗試執行的動作</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">  &#x2F;&#x2F; 做例外捕捉後的 exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  &#x2F;&#x2F; 最後需執行的動作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>說明：<ol><li>try 一定存在, catch 跟 finally 至少需有1個</li><li>try 若遇到 Exception, 則之後的 statement 不做, 拋出 Exception object</li><li>catch 會捕捉 Exception, 並加以處理</li><li>try or catch 結束後, 會執行 finally block</li><li>若只有 try, finally , 當發生 exception 時, 會：</li><li>先執行 finally block</li><li>再將 Exception 往外拋</li></ol></li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">  exception occurs; &#x2F;&#x2F; 1</span><br><span class="line">  System.out.println(&quot;1&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123; &#x2F;&#x2F; 2 </span><br><span class="line">  System.out.println(&quot;2&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  System.out.println(&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Q1: output &#x3D; ? 2, 3</span><br><span class="line">&#x2F;&#x2F; Q2: 拿掉 1, output &#x3D; ? 1, 3</span><br><span class="line">&#x2F;&#x2F; Q3: 拿掉 2, output &#x3D; ? 3, runtime exception</span><br></pre></td></tr></table></figure></p><h2>array 初始化</h2><ul><li>in O.O 所有物件皆需 <strong>初始化</strong> (呼叫建構子)</li><li>in Java array 即為物件, 所以需初始化</li><li>不同型別的初始值<ul><li>基本型別: boolean, char, byte, int, long, short, float, double</li><li>物件型別: &quot;null&quot;</li></ul></li></ul><h2>Java 中的 array 宣告</h2><ul><li>type 陣列 name[] = new type [size];</li><li>ex: int a[] = new int[3];</li><li>ex1: double d() = new double[3];</li><li>主程式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s[] &#x3D; new String[3];</span><br><span class="line">s[s.length - 1] &#x3D; &quot;hello&quot;;</span><br><span class="line">System.out.println(&quot;s[1]&quot;);</span><br></pre></td></tr></table></figure></li><li>Note: 若為 &quot;基本型別&quot;, 且為 &quot;區域變數&quot;, 則：系統不會幫忙初始化, 需自行設預設值, <strong>若無則處理時會有compile error</strong></li><li>Ex:</li></ul><h2>static keyword</h2><blockquote><p>類別 -&gt; 靜態, 物件 -&gt; 動態</p></blockquote><ul><li><p>說明: static 修飾詞可用於 attribute, method 宣告中, 代表此 attribute, method 為 class 所有, 非 object 的</p></li><li><p>Note: data member 可分為:</p><ul><li>attribute:<ul><li>class variable (static)</li><li>instance variable (non-static)</li></ul></li><li>method<ul><li>class method (static)</li><li>instance method (non-static)</li></ul></li></ul></li><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">  public static int x;</span><br><span class="line">  public int y;</span><br><span class="line">&#125;</span><br><span class="line">A a1 &#x3D; new A();</span><br><span class="line">A a2 &#x3D; new A();</span><br></pre></td></tr></table></figure></p></li><li><p>成大: 一公司有員工的類別, 有下列屬性, 何者適合宣告為 static:</p><ol><li>姓名</li><li>手機</li><li>住址</li><li>配偶</li><li>CEO V</li></ol></li></ul><h2>static 注意事項</h2><ol><li>static method 只能存取 static 的 attribute 及 method, 無法用 Non-static 之 attribute 及 method</li></ol><ul><li><p>Ex1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先有類別, 才有物件</span><br><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">  public static int x;</span><br><span class="line">  public int y; &#x2F;&#x2F; non-static</span><br><span class="line">  public static void count()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(x+y); &#x2F;&#x2F; y compile error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">  public void get X()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void get()</span><br><span class="line">  &#123;</span><br><span class="line">    get x(); &#x2F;&#x2F; compile error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><ol start="2"><li>static method 不可被 override (因為 static method 為靜態的, 故無法達多型(Dynamic Binding))之效)</li></ol><h2>final keyword</h2><p>可用來修飾:</p><ol><li>class: 代表此 class 不可再被<strong>繼承</strong></li></ol><ul><li>ex:<ul><li>父: <code>final class A {}</code></li><li>子: <code>calss B extends A{}</code> compile error</li></ul></li></ul><ol start="2"><li>method: 此 method 不可<strong>被 override</strong></li></ol><ul><li>ex:<ul><li>superclass: <code>public final void print() {}</code></li><li>subclass: <code>public void print(){}</code> compile error, 因為 final 不能被 override</li></ul></li></ul><ol start="3"><li>attribute: 代表此attribute 的值為 <strong>常數</strong></li></ol><ul><li>ex:<ul><li><code>public final int x = 10;.....x = 50;</code> compile error, 因為常數不能被更改</li></ul></li></ul><h2>polymorphism in Java</h2><ul><li><p>Java 的多型不需有 &quot;virtual&quot; 的 keyword, 因為在 java 中所有的 method 皆具 virtual function 功能, 不需額外宣告, 亦即 method 皆可達 Dynamic Binding 之效</p></li><li><p>說明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">  public void walk()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;An.walk&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person extends Animal</span><br><span class="line">&#123;</span><br><span class="line">  public void walk()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;Person walk&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">  public void walk()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;Dog walk&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">Polymorphism:</span><br><span class="line">inheritance</span><br><span class="line">+</span><br><span class="line">overriding</span><br><span class="line">+</span><br><span class="line">upcasting</span><br><span class="line">把子類別的物件, 向上看成父類別的型態</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></p></li><li><p>Note:</p><ul><li>在 C++, 中做多型要有 virtual</li><li>在 java 中的 method 所有都是 virtual, 除了 static 的</li></ul></li><li><p>應用:</p></li></ul><h2>Abstract method</h2><ul><li>Def: 當 method 沒有 implement 謂之 abstract method</li><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract void walk()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; implement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2>Abstract class</h2><ul><li><p>Def:</p><ol><li>當 class 中具 ≥ 1 個 abstract method, 即需定義為 abstract class</li><li>abstract class 不能產生出實體(即無法 &quot;new&quot; 出 instance)</li><li>繼承 abstract class, 並將其 abstract method override 掉的謂之 concrete class</li></ol></li><li><p>Ex1:</p></li><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal a &#x3D; new Animal(); &#x2F;&#x2F; X 抽象類別不能 new</span><br><span class="line">Person p &#x3D; new Person(); &#x2F;&#x2F; O</span><br><span class="line">Animal a &#x3D; new Person(); &#x2F;&#x2F; O 實際上產生具象, Person 做 upcasting -&gt; 準備做多型</span><br></pre></td></tr></table></figure></p></li><li><p>Ex3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal</span><br><span class="line">&#123;</span><br><span class="line">  public abstract void walk();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; compile error</span><br><span class="line">class Person extends Animal &#x2F;&#x2F; Solution1: 前方加上 abstract </span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; solution 2</span><br><span class="line">  public void walk() </span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;Person walk&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Note: 1, 2 擇一, 皆無時, 會有 compile error</p></li><li><p>用 1 不用 2 時, 代表 Person 為 abstract, 代表此層不會是最後一層</p></li><li><p>Sol: 既然不知道它該怎麼寫幹嘛定義? (第一個 abstract)</p></li><li><p>ANS: 拿掉就好, 但它如果定義出來, 他會具備規範的效果, 若定義走路是抽象, 若以後繼承我, 一定要把走路做完, 否則 compile 會提醒, 程式少漏洞</p></li></ul><h2>interface</h2><ul><li>通常是規格規範的動作 (根本不會產生物件, 所以也陪有 non-static 的問題)</li><li>格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface name</span><br><span class="line">&#123;</span><br><span class="line">  public static final attribute_name;</span><br><span class="line"></span><br><span class="line">  public abstract method signature;</span><br><span class="line">  &#x2F;&#x2F; public static or public abstract 可省略, 但系統會自動加上</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>方法全部都是抽象的, 就代表根本沒辦法實體化, 沒辦法產生物件, 幹嘛產生建構子, 建構子是用來做初始化的動作, 不會產生物件, 所以就不用有建構子了</p></blockquote><h3>Why interface?</h3><ul><li>利用 interface 讓 Java 模擬出 Multiple Inheritance</li><li>圖：</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Flyer</span><br><span class="line">&#123;</span><br><span class="line">  public static void fly(); &#x2F;&#x2F; 若只寫這樣也會過, 括號內連寫都沒寫, implement 是把它補起來, override 是重新定義</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Superman extends Person implements Flyer &#x2F;&#x2F; 介面可以實作很多個</span><br><span class="line">&#123;</span><br><span class="line">  public void fly()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;flying&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>抽象類別只要有一個是抽象就是, 介面就是全部</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.5 JAVA&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Java VS C++&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Java&lt;/th&gt;
&lt;th&gt;C++&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Pure O.O languag
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="建構子" scheme="https://pingjing0628.github.io/tags/%E5%BB%BA%E6%A7%8B%E5%AD%90/"/>
    
      <category term="Overriding" scheme="https://pingjing0628.github.io/tags/Overriding/"/>
    
      <category term="繼承" scheme="https://pingjing0628.github.io/tags/%E7%B9%BC%E6%89%BF/"/>
    
      <category term="多型" scheme="https://pingjing0628.github.io/tags/%E5%A4%9A%E5%9E%8B/"/>
    
      <category term="Interface" scheme="https://pingjing0628.github.io/tags/Interface/"/>
    
      <category term="Java" scheme="https://pingjing0628.github.io/tags/Java/"/>
    
      <category term="Exception" scheme="https://pingjing0628.github.io/tags/Exception/"/>
    
      <category term="Static" scheme="https://pingjing0628.github.io/tags/Static/"/>
    
      <category term="Final" scheme="https://pingjing0628.github.io/tags/Final/"/>
    
      <category term="Abstract" scheme="https://pingjing0628.github.io/tags/Abstract/"/>
    
      <category term="this" scheme="https://pingjing0628.github.io/tags/this/"/>
    
      <category term="super" scheme="https://pingjing0628.github.io/tags/super/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-C++程式語言介紹</title>
    <link href="https://pingjing0628.github.io/2022/06/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C-%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E4%BB%8B%E7%B4%B9/"/>
    <id>https://pingjing0628.github.io/2022/06/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C-%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E4%BB%8B%E7%B4%B9/</id>
    <published>2022-06-19T16:15:34.000Z</published>
    <updated>2022-09-19T12:56:16.348Z</updated>
    
    <content type="html"><![CDATA[<h1>5.4 C++ 程式語言介紹</h1><hr><h2>C++ Language</h2><p>Class:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式: class class_name</span><br><span class="line">&#123;</span><br><span class="line">    Constructor &#x2F;&#x2F; 建構子</span><br><span class="line">    Destructor &#x2F;&#x2F; 解構子</span><br><span class="line">    Attribute &#x2F;&#x2F; 變數宣告</span><br><span class="line">    Operation &#x2F;&#x2F; 函式定義</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2>Object 宣告, 操作</h2><p><code>class _ object;</code><br>操作：<br>object.att.<br>object.op.</p><ul><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    Person P;</span><br><span class="line">    p.height &#x3D; 180;</span><br><span class="line">    p.weight &#x3D; 80;</span><br><span class="line">    p.walk(); &#x2F;&#x2F; 印出 &quot;Person walk&quot;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2>建構子 (Construtor)</h2><ul><li>Def:<ul><li>對 object 做 <strong>初始化</strong> 的動作</li><li>於 object 產生時呼叫</li><li>Constructor name 和 <strong>class name 相同, 且 No return type</strong></li><li>Constructor 可有很多個</li></ul></li><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public:</span><br><span class="line">    &#x2F;&#x2F;建構子</span><br><span class="line">    A() &#123;</span><br><span class="line">        cout &lt;&lt;&quot;con.A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;解構子</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        cout &lt;&lt;&quot;del.A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2>解構子 (Destructor)</h2><ul><li>Def:<ul><li>於 constructor 之前加上 <strong>&quot;~&quot;</strong></li><li>Destructor <strong>不接收參數</strong> parameter list 為空</li><li>class 中 destructor <strong>只會有一個</strong></li><li>於 object 被回收時呼叫<br><img src="%E8%A7%A3%E6%A7%8B%E5%AD%90.png" alt=""></li></ul></li><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    public: </span><br><span class="line">    A() &#123;</span><br><span class="line">        cout &lt;&lt;&quot;con.A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        cout &lt;&lt;&quot;del.A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    A a1; a1 屬於 A</span><br><span class="line">    A a2;</span><br><span class="line">    return 0;</span><br><span class="line">&#125; &#x2F;&#x2F; 結束前呼叫解構子 output?</span><br></pre></td></tr></table></figure></li></ul><h2>變數種類</h2><p>格式：<code>static _ type _ variable;</code><br><code>static int x;</code></p><ul><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    fun();</span><br><span class="line">    fun();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void fun() &#123;</span><br><span class="line">    static int i &#x3D; 20;</span><br><span class="line">    i++;</span><br><span class="line">    cout &lt;&lt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Note:</p><ul><li>靜態變數存於靜態區塊中, <strong>&quot;不會隨著所屬 block 結束而回收&quot;</strong>, 於程式結束回收</li><li>靜態變數之宣告只於第一次執行, 之後忽略之</li></ul></li><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public:</span><br><span class="line">    int oid; &#x2F;&#x2F; att</span><br><span class="line">    &#x2F;&#x2F; 建構子</span><br><span class="line">    A(int i) &#123;</span><br><span class="line">        oid &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;解構子</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        cout &lt;&lt;oid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int main() &#123;</span><br><span class="line">        A a1(1); &#x2F;&#x2F; 給建構子的參數</span><br><span class="line">        fun();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    void fun() &#123;</span><br><span class="line">        A a2(2);</span><br><span class="line">        static A a3(3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li></ul><p>問 output is?<br><img src="%E8%AE%8A%E6%95%B8%E7%A8%AE%E9%A1%9EEX1.png" alt=""></p><h2>C++ 參考變數 Reference Variable</h2><p>格式：<br><code>type **&amp;**var = **被參考變數** (不可省略)</code><br><code>int &amp;count = x;</code> -&gt; 替 x 取別名叫 count</p><blockquote><p>注意事項：</p><ol><li>int count; (X) 替某人取綽號叫 count, 但某人不存在</li><li>int &amp;count = 3; (X) 常數(No mem space)</li></ol></blockquote><h3>宣告時</h3><p><code>int x;</code> <strong>=&gt; call by value</strong> (一般)<br><code>int *x;</code> <strong>=&gt; call by address</strong> (指標)<br><code>int &amp;x;</code> <strong>=&gt; call by reference</strong> (參數)</p><h3>操作時</h3><p><code>x</code><strong>=&gt; 取內容</strong><br><code>*x</code><strong>=&gt; 取指標指向的值</strong><br><code>&amp;x</code><strong>=&gt; 取所在 address</strong></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    cout &lt;&lt;a&lt;&lt;b;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int x, int y) &#123;</span><br><span class="line">    int &amp;x &#x3D; a;</span><br><span class="line">    int temp;</span><br><span class="line">    temp &#x3D; x;</span><br><span class="line">    x &#x3D; y;</span><br><span class="line">    y &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Q:<br>1. a, b 呼叫 swap 後為何 No change? (call - by value)<br>2. How to modifiy?</p><h2>C++ 的 Inheritance</h2><p><img src="%E7%B9%BC%E6%89%BF.png" alt=""></p><ul><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public: &#x2F;&#x2F; 若改為 private, 此時 B會有 compile error</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line">class B: Public A &#123; &#x2F;&#x2F;: 繼承</span><br><span class="line">    public:</span><br><span class="line">    B (inta, int b) &#123;</span><br><span class="line">        x &#x3D; a;</span><br><span class="line">        y &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    void print() &#123;</span><br><span class="line">        cout &lt;&lt;x&lt;&lt;y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    B objB(2, 5);</span><br><span class="line">    objB.print();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>補充：繼承的存取權限<img src="%E8%A3%9C%E5%85%85%E7%B9%BC%E6%89%BF.png" alt=""></p></blockquote><h2>Overriding 覆載</h2><ul><li>子類別將父類別的<strong>函式重新定義</strong>以符合自身所需<br><img src="%E8%A6%86%E8%BC%89.png" alt=""></li></ul><h2>Overloading 多載</h2><p>分為：</p><ol><li>function overloading<ol><li>藉由接收多數串列的<strong>數量</strong>或<strong>型別不同</strong>以達到共用相同的函式名稱<ul><li><p>Ex1:</p><ul><li>對 user 而言較方便, 不需記過多的 function name</li><li>對 programmer 而言命名 function 亦可簡化其原則<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(2); -&gt; void print(int i)</span><br><span class="line">print(3.5); -&gt; void print(double d)</span><br><span class="line">print(&quot;abc&quot;); -&gt; void print(char *s)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    public:</span><br><span class="line">    Person() &#123;...&#125;            &#x2F;&#x2F; 建構子</span><br><span class="line">    Person(int h) &#123;...&#125;       &#x2F;&#x2F; 建構子</span><br><span class="line">    Person(inth, int w) &#123;...&#125; &#x2F;&#x2F; 建構子  Overloading</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul></li></ol></li></ol><ol start="2"><li>operator overloading<ul><li>Def: 藉由接收的運算元型別不同, 以達<strong>共用相同的運算子(operator)符號</strong></li><li>概念：<ul><li>3 + 5 =&gt; int + int</li><li>2.3 + 5.5 =&gt; double + double</li><li>matrix + matrix</li></ul></li></ul></li></ol><h2>this vs super</h2><ul><li>為 C++ 內建提供的物件指標</li><li>其中：<ul><li>this 會指向物件本身</li><li>super 會指向物件的 parent class</li></ul></li><li>說明：<br><img src="this&amp;super.png" alt=""></li></ul><h2>物件指標</h2><ol><li>物件指標指向 attribute or operator<br>ex: this -&gt; i;</li><li>(*物件指標).attribute or operator<br>ex: (*this).i;</li></ol><ul><li>Ex: this.i ... 錯誤 (成大)<br>因為 <strong>&quot;.&quot;</strong> priority &gt; <em><em>&quot;</em>&quot;</em>*<br>所以 括號不能拿掉<br><code>(*(&amp;(*this))).i; = (*this).i</code><ul><li>為從 address 拿回值<br>&amp; 為拿出 address</li></ul></li></ul><p><img src="%E7%89%A9%E4%BB%B6%E6%8C%87%E6%A8%99.png" alt=""></p><ul><li>EX:<br><img src="%E7%89%A9%E4%BB%B6%E6%8C%87%E6%A8%99Ex1.png" alt=""></li><li>EX2 (政大):<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void A(int V1, int V2)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; V2, V2 &#x3D; V1 - 3, V1 &#x3D; t + 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pA(int *V1, int *V2)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; *V2;</span><br><span class="line">    *V2 &#x3D; *V1 + 2;</span><br><span class="line">    *V1 &#x3D; t - 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rA(int &amp;V1, int &amp;V2)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; V2;</span><br><span class="line">    V2 &#x3D; V1 + 4;</span><br><span class="line">    V1 &#x3D; t - 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i &#x3D; 1, j &#x3D; 2;</span><br><span class="line">    cout &lt;&lt;i&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    A(i, j);      &#x2F;&#x2F; call-by value</span><br><span class="line">    cout &lt;&lt;i&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    pA(&amp;i, &amp;i);   &#x2F;&#x2F; call-by address</span><br><span class="line">    cout &lt;&lt;i&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    rA(i, j);     &#x2F;&#x2F; call-by reference (取綽號, c++ 獨有)</span><br><span class="line">    cout &lt;&lt;i&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Ans: </span><br><span class="line">&#x2F;&#x2F; 1 2 </span><br><span class="line">&#x2F;&#x2F; 1 2</span><br><span class="line">&#x2F;&#x2F; -2 3</span><br><span class="line">&#x2F;&#x2F; -2 2</span><br></pre></td></tr></table></figure><img src="%E6%8C%87%E6%A8%99Ex.png" alt=""></li></ul><h2>Polymorphism 多型</h2><ul><li>Def :<ul><li>多型主要是於<strong>執行時期</strong>利用<strong>動態繫結</strong>的方式來呼叫需執行的 function =&gt; <strong>執行時才動態決定</strong></li><li>C++ 中一般的函式呼叫於 compile time (state binding)已決定, 其呼叫位址 =&gt; <strong>故無法達到多型</strong></li><li>在 C++ 中多加入一keyword <strong>virtual</strong> 來註明函式為 virtual function =&gt; <strong>已達多型之效</strong></li></ul></li><li>圖：<br><img src="%E5%A4%9A%E5%9E%8B.png" alt=""></li></ul><ol><li>利用父類別型態 <strong>(須為指標或參數, 不能為一般變數)</strong></li><li>接收不同子類別的物件</li><li>做相同的動作</li><li>引發不同的行為(同名異式)</li></ol><ul><li><p>Ex1:</p></li><li><p>NOTE: Polymorphism =&gt; Inheritance(:) + Overriding + Virtual function<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Virtual 一抽掉, 就永遠印出 An.walk</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void walk()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;An.walk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Person:public Animal</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void walk()  &#x2F;&#x2F; 子類別的 virtual 可省略</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Person walk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog: public Animal</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void walk()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Dog walk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    &#x2F;&#x2F; 一定要指標或參考</span><br><span class="line">    Animzl *aPtr &#x3D; 0; &#x2F;&#x2F; 一開始是 0</span><br><span class="line">    Person p;</span><br><span class="line">    aPtr &#x3D; &amp;p;  &#x2F;&#x2F; 指標接收住址</span><br><span class="line">    aPtr-&gt; walk(); &#x2F;&#x2F; &quot;Person&quot; walk</span><br><span class="line">    Dog d;</span><br><span class="line">    aPtr &#x3D; &amp;d;</span><br><span class="line">    aPtr -&gt; walk(); &#x2F;&#x2F; &quot;dog&quot; walk</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2: 政大<br><img src="%E5%A4%9A%E5%9E%8BEx1.png" alt=""><img src="%E5%A4%9A%E5%9E%8BEx2.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">    public: </span><br><span class="line">    virtual void iam()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Base \n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>問：</p></li></ul><ol><li>Derive two class from Base(繼承), and for each define iam() to write out the name of the class (override).<br>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class D1: public Base</span><br><span class="line">&#123;</span><br><span class="line">    public: </span><br><span class="line">    virtual void iam()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;D1 \n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D2: public Base</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void iam()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;D2 \n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>Create objects of these classes(物件宣告), and call iam() for them(物件操作).<br>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    D1 d1;</span><br><span class="line">    D2 d2;</span><br><span class="line">    b.iam();</span><br><span class="line">    d1.iam();</span><br><span class="line">    d2.iam();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Assign pointers to objects of the derived class to Base *pointers and call iam() through those pointers.<br>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *b1, *b2;</span><br><span class="line">    D1 d1;</span><br><span class="line">    b1 &#x3D; &amp;d1;</span><br><span class="line">    b1 -&gt; iam(); &#x2F;&#x2F; 印出 &quot;D1&quot;</span><br><span class="line">    D2 d2;</span><br><span class="line">    b2 &#x3D; &amp;d2;</span><br><span class="line">    b2 -&gt; iam(); &#x2F;&#x2F; 印出 &quot;D2&quot;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.4 C++ 程式語言介紹&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;C++ Language&lt;/h2&gt;
&lt;p&gt;Class:
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="C++" scheme="https://pingjing0628.github.io/tags/C/"/>
    
      <category term="建構子" scheme="https://pingjing0628.github.io/tags/%E5%BB%BA%E6%A7%8B%E5%AD%90/"/>
    
      <category term="解構子" scheme="https://pingjing0628.github.io/tags/%E8%A7%A3%E6%A7%8B%E5%AD%90/"/>
    
      <category term="Overriding" scheme="https://pingjing0628.github.io/tags/Overriding/"/>
    
      <category term="Overloading" scheme="https://pingjing0628.github.io/tags/Overloading/"/>
    
      <category term="物件指標" scheme="https://pingjing0628.github.io/tags/%E7%89%A9%E4%BB%B6%E6%8C%87%E6%A8%99/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-物件導向概論</title>
    <link href="https://pingjing0628.github.io/2022/04/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E6%A6%82%E8%AB%96/"/>
    <id>https://pingjing0628.github.io/2022/04/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E6%A6%82%E8%AB%96/</id>
    <published>2022-04-20T15:00:18.000Z</published>
    <updated>2022-09-19T12:56:04.088Z</updated>
    
    <content type="html"><![CDATA[<h1>5.3 物件導向概論</h1><hr><h2>Object Oriented:</h2><p>int x; (type 變數)<br>person P; (類別 物件)</p><ul><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person p;</span><br><span class="line">p.h &#x3D; 180</span><br><span class="line">p.w &#x3D; 80;</span><br><span class="line">p.walk();</span><br></pre></td></tr></table></figure></li></ul><h3>why O.O</h3><ul><li>可用以反應出真實世界的情況, 使程式的可讀性更佳, 日後的可維護性亦更好</li><li><strong>彈性好, 但 performance 差</strong></li></ul><h2>物件(object)</h2><ul><li>Def:<ul><li>an object is an instance of a class =&gt; 指物件為類別的實體</li><li>each object 是獨立的, 滿足唯一性(unique)</li></ul></li><li>就程式而言物件是<ol><li>參與程式執行的單位</li><li>為一變數會佔用 Mem.space</li><li><strong>dynamic</strong>: 指會隨執行而更動其狀態</li></ol></li></ul><h2>類別(class)</h2><ul><li>Def:<ul><li>將具相同屬性及行為的 object 加以抽象化定義</li></ul></li><li>其中：<ul><li>attribute: 靜態描述(特徵值), height, weight, 單眼皮, 雙眼皮</li><li>behavior(operation in c++, method in java): 動態描述 =&gt; 作用在屬性上</li></ul></li><li>就程式而言類別是：<ul><li>ADT (Abstract Data Type)</li><li>為靜態單位, 只佔用一份 Mem. space</li><li>為物件的實施藍圖</li></ul></li><li>概念：<ul><li>圖：<img src="%E5%80%9F%E6%9B%B8.png" alt=""></li><li>Note: Object 之間溝通採用 <strong>&quot;Message Passing&quot;</strong> (因為物件間是獨立的, 無共享Mem.)</li></ul></li></ul><h2>Object Oriented 四大特色</h2><ol><li>Data Abstraction 資料抽象化<ul><li>將物件細節排除, 擷取共通的 attribute 及 operation, 加以抽象化定義</li><li>在定義(抽象化)過程, 會忽略和問題無關的部分</li></ul></li><li>Encapsulation 封裝<ul><li>Def:<ul><li>可將 class 中部分的 attribute 及 operation 隱藏, 避免外界直接取用</li><li>一般會用一公開的管道使外界可做間接存取, 以便管控正確性</li></ul></li><li>優點：<ol><li>確保私有 data 不受外界影響 =&gt; 可避免不當操作發生, 如 ....heart</li><li>適時將製作的細節封裝, 如此可在改變時, 減少對外操作的影響 =&gt; ripple effect 低, 可維護性高(如程式碼2)</li></ol></li></ul></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person                   外界</span><br><span class="line">setHeight(int h)         height &#x3D; -30; (Can&#39;t use)</span><br><span class="line">&#123;                        setHeight(-30);</span><br><span class="line">    if (h &lt; 0) error;</span><br><span class="line">    height &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;今日有一客戶需一排序程式</span><br><span class="line">BubbleSort(data) &#123;</span><br><span class="line">    ...             &#x2F;&#x2F;但由於資料愈來愈多嫌太慢</span><br><span class="line">&#125;</span><br><span class="line">QuickSort(data) &#123;</span><br><span class="line">    ...             &#x2F;&#x2F;卻發現舊系統中都是 bubble sort, 無法執行 quick sort</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所以當初應</span><br><span class="line">Sort(data) &#123;</span><br><span class="line">    BubbleSort(data) &#x2F;&#x2F; 改成</span><br><span class="line">    QuickSort(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>Inheritance 繼承<ul><li>Def:<ul><li>子類別(Child class) 可以繼承 父類別 (parent class) 的屬性及運作, 亦可加入 child class 自訂的屬性及運作</li></ul></li><li>圖：<br><img src="%E7%B9%BC%E6%89%BF1.png" alt=""></li><li>優點：<ol><li>支援 software reuse (軟體再利用) =&gt; <strong>省下重複開發成本</strong></li><li>支援 component base software developments (以元件為基礎的軟體開發方式) =&gt; VB , 品質好, 速度快</li></ol></li><li>缺點：<ol><li>當繼承深且複雜的時候, 會使 compiler 的 performance 下降, 耗費時間去找尋各 data 的來源<br><img src="%E7%B9%BC%E6%89%BF.png" alt=""></li><li>readable 及 maintainable 的程度下降, 因為太多層, 所以視窗太多, 要找時也困難</li><li>有 Naming Conflicting 的議題(命名衝突), 又稱 &quot;ambiguous calling&quot; (模糊呼叫)<br><img src="%E5%91%BD%E5%90%8D%E8%A1%9D%E7%AA%81.png" alt=""></li><li>重複繼承的問題<br><img src="%E9%87%8D%E8%A4%87%E7%B9%BC%E6%89%BF.png" alt=""></li></ol></li></ul></li></ol><blockquote><p>補充 Encapsulation 存取權限：<br><img src="%E5%B0%81%E8%A3%9D%E5%AD%98%E5%8F%96%E6%AC%8A%E9%99%90.png" alt=""><br>Note:</p><ol><li>在 c++中額外提供 &quot;friendly&quot; 權限, 當 class A, B 2者設為 friend, 即可取用之</li><li>在 java 中若沒宣稱權限, 則為 default 權限, <strong>此時只有 class 本身及同 package(類似目錄的概念) 下方可使用</strong></li></ol></blockquote><ol start="4"><li>Polymorphism 多型<ul><li>Def: O.O 程式於 &quot;執行期間&quot; (Runtime 才決定呼叫的 function 之所在 -&gt; Dynamic Binding), 不同型別之物件, 接收到同一訊息 <strong>(同名)</strong>, 會有不同的行為 <strong>(異式)</strong>, 反應謂之「多型」</li><li>Note: binding<br><img src="%E5%A4%9A%E5%9E%8B2.png" alt=""></li><li>Ex:<br><img src="%E5%A4%9A%E5%9E%8B1.png" alt=""></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.3 物件導向概論&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Object Oriented:&lt;/h2&gt;
&lt;p&gt;int x; (type 變數)&lt;br&gt;
person P; (類別 物件)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ex:&lt;br&gt;
&lt;figure class=&quot;highlight p
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="物件導向" scheme="https://pingjing0628.github.io/tags/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91/"/>
    
      <category term="繼承" scheme="https://pingjing0628.github.io/tags/%E7%B9%BC%E6%89%BF/"/>
    
      <category term="多型" scheme="https://pingjing0628.github.io/tags/%E5%A4%9A%E5%9E%8B/"/>
    
      <category term="封裝" scheme="https://pingjing0628.github.io/tags/%E5%B0%81%E8%A3%9D/"/>
    
      <category term="抽象" scheme="https://pingjing0628.github.io/tags/%E6%8A%BD%E8%B1%A1/"/>
    
      <category term="類別" scheme="https://pingjing0628.github.io/tags/%E9%A1%9E%E5%88%A5/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-C語言重點</title>
    <link href="https://pingjing0628.github.io/2021/07/08/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C%E8%AA%9E%E8%A8%80%E9%87%8D%E9%BB%9E/"/>
    <id>https://pingjing0628.github.io/2021/07/08/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C%E8%AA%9E%E8%A8%80%E9%87%8D%E9%BB%9E/</id>
    <published>2021-07-08T09:10:18.000Z</published>
    <updated>2022-09-20T14:44:14.734Z</updated>
    
    <content type="html"><![CDATA[<h1>5.2 C 語言重點</h1><hr><h2>C Language</h2><ul><li>結構<ul><li>xxx.c</li><li>header: 表頭</li><li>body: object code</li></ul></li><li>Ex:<code># include &lt;stdio.h&gt;</code> =&gt; stdio.h 為 linker, 外部函式庫之 header file</li></ul><h2>變數 vs 常數</h2><table><thead><tr><th>Variable</th><th>Constant</th></tr></thead><tbody><tr><td>會隨著執行而更動的數值</td><td>不變</td></tr><tr><td>佔用 memory space 來存取</td><td>不需</td></tr><tr><td>int x;</td><td>ex: 'a' or 100</td></tr></tbody></table><ul><li>Note: 常數變數 (constant variable)<br>Define: <code>const int x = 10;</code></li></ul><h2>變數宣告</h2><p>格式： <code>type (space) variable;</code><br>ex: int x;</p><h2>Compare Static typed and Dynamic typed</h2><table><thead><tr><th>Static typed</th><th>Dynamic typed</th></tr></thead><tbody><tr><td>宣告時, 即需決定 data 之型態</td><td>不需, runtime 才決定</td></tr><tr><td>int x;</td><td>var x; x = 100;</td></tr><tr><td>java, C, C++</td><td>javascript, ruby</td></tr></tbody></table><h2>常見的 data type 介紹</h2><ol><li>boolean (布林):</li></ol><ul><li>只有兩種狀態:<ul><li>true</li><li>false</li></ul></li><li>Ex: <code>bool flag;</code></li></ul><ol start="2"><li>character (字元):</li></ol><ul><li>利用 &quot;ASCII&quot; 來存放</li><li>佔用 1 byte memory space</li><li>常見字元編碼<ul><li>'0' =&gt; (48)10</li><li>'A' =&gt; (65)10</li><li>'a' =&gt; (97)10</li></ul></li><li>Ex: <code>char c1;</code></li><li>Note:</li></ul><table><thead><tr><th>character</th><th>string</th></tr></thead><tbody><tr><td>由一字母或數字組成</td><td>由 1~多個組成</td></tr><tr><td>用單引號括住</td><td>用雙引號括住</td></tr><tr><td>'a', 'B'(對), &quot;B&quot;(錯)</td><td>&quot;hello&quot;(對), 'hello'(錯)</td></tr></tbody></table><ol start="3"><li>integer (整數):</li></ol><ul><li>利用 4 bytes 表示</li><li>Ex: <code>int x;</code></li><li>除法:<ul><li>&quot;/&quot; =&gt; 取商, <code>x = 6/4</code></li><li>&quot;%&quot; =&gt; 取餘, <code>y = 6%4</code></li></ul></li><li>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">char a1 &#x3D; &#39;a&#39;;</span><br><span class="line">x &#x3D; a1;</span><br><span class="line">a1 &#x3D; a1 + 3;</span><br><span class="line">printf(&quot;%d&quot;, x); &#x2F;&#x2F; x &#x3D; 97</span><br><span class="line">printf(&quot;%c&quot;, a1); &#x2F;&#x2F; a1 &#x3D; 100</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>浮點數:</li></ol><table><thead><tr><th>float</th><th>double</th></tr></thead><tbody><tr><td>single precision</td><td>double precision</td></tr><tr><td>32 bits, 佔用 4 bytes</td><td>使用 8 bytes</td></tr><tr><td>float f;</td><td>double d;</td></tr></tbody></table><ul><li>ex:<ol><li><code>float f1 = 3.2/4;</code> =&gt; 0.8</li><li><code>float f2 = 5/4;</code> =&gt; 1.0</li><li><code>float f3 = 5.0/4;</code> =&gt; 1.25</li><li><code>float f4 = (float)5/4;</code> =&gt; 1.25 =&gt; 強制將 5 視為浮點數, <strong>強制轉型 casting</strong></li></ol></li><li>Note:<ol><li>在 c, c++中, 運算是會以最大型別來求得結果<ul><li>ex: int(隱含轉型 -&gt; double) * double + float = ? =&gt; output <strong>double</strong></li></ul></li><li>浮點數, 預設為 <strong>double</strong> 之型態 (因為失真少, 結尾誤差少)<ul><li>ex: 3.14 * 2.56 + 3.2 =&gt; double</li></ul></li></ol></li></ul><blockquote><p>NOTE: type range =&gt; byte &lt; short &lt; int &lt; long &lt; float &lt; double</p></blockquote><h2>變數種類</h2><table><thead><tr><th>local variable</th><th>global variable</th></tr></thead><tbody><tr><td>於 block 或 函式之中宣告</td><td>於 block 或 函式之外宣告</td></tr><tr><td>僅能在所屬的 block 之內使用</td><td>全部block都可用</td></tr><tr><td>於 block 一結束, 即清除</td><td>整個程式結束才清除</td></tr></tbody></table><ul><li>static variable</li></ul><h2>變數的存取順序</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">全域變數</span><br><span class="line">3.&#123;</span><br><span class="line">    2.&#123;</span><br><span class="line">        1.&#123;</span><br><span class="line">            print(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>先找自身區塊</li><li>若 1 無, 往外層找</li><li>若 2 無, 往 global 找</li></ol><ul><li><p>Note: dynamic scoping =&gt; 依程式執行時的呼叫順序 (runtime) 來決定找尋順序, <code>main() -&gt; A() -&gt; B()</code> =&gt; 找B找不到, 找A, 在找不到找 main</p></li><li><p>Ex1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 10; &#x2F;&#x2F;global</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    int y &#x3D; 5;</span><br><span class="line">    &#123;</span><br><span class="line">        int x &#x3D; 20;</span><br><span class="line">        int z &#x3D; 8;</span><br><span class="line">        printf(&quot;%d&quot;, x); &#x2F;&#x2F; x&#x3D;20, 用完即清除</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, x); &#x2F;&#x2F; x&#x3D;10</span><br><span class="line">    printf(&quot;%d&quot;, z); &#x2F;&#x2F; compile error</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 20;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int y &#x3D; 10;</span><br><span class="line">    fun(y);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">void fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int y &#x3D; 30;</span><br><span class="line">    printf(&quot;%d, %d&quot;, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Ans: (20, 30)</p></li><li><p>Note: 在 C 語言裡, 只要不是指標, 就是 call by-value</p></li><li><p>local variable =&gt; 與 function 一樣, 用 stack 放 =&gt; 後進先出</p></li></ul><h2>Standard I/O library 標準輸出/輸入函式庫</h2><h3>程式欲使用須引入： <code>#include &lt;stdio.h&gt;</code></h3><h3>常用函式：</h3><ol><li><p><code>printf</code> =&gt; 標準輸出<br>格式： <code>printf(&quot;格式字串&quot;, var1, var2...);</code><br>Note:</p><ol><li>var 可省略</li><li>若有 var, 需在格式字串中, 有對應的 <strong>格式碼</strong></li></ol><blockquote><p>格式碼：<br>%d 整數<br>%f 浮點數<br>%c 字元<br>%s 字串</p></blockquote><p>EX:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;hello&quot;);</span><br><span class="line">int x;</span><br><span class="line">printf(&quot;x is %d&quot;, x);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; x is 100</span><br></pre></td></tr></table></figure></p></li><li><p><code>scanf</code> =&gt; 標準輸入<br>從外界 key in 值, 接收到程式<br>格式： <code>scanf(&quot;格式字串&quot;, &amp;var1, &amp;var2...); // &amp;位址</code><br>Note: 格式碼與 <code>printf</code> 相同<br>EX:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">scanf(&quot;input: %d&quot;, &amp;x);</span><br></pre></td></tr></table></figure></p><p>EX:<br><code>Sum = 1+2+3+4...+N</code>, N 為輸入值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    int N, sum &#x3D; 0, i;</span><br><span class="line">    scanf(&quot;input: %d&quot;, &amp;N);</span><br><span class="line">    for(i &#x3D; 1; i ≤ N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum &#x3D; sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;total:%d&quot;, sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2>運算子</h2><table><thead><tr><th>Operator</th><th>Priority</th><th>Associative</th></tr></thead><tbody><tr><td>(), []</td><td><strong>高</strong></td><td>右結合</td></tr><tr><td>!, ~, -(負), ++, --</td><td></td><td>左結合</td></tr><tr><td>*, /, +, - (<strong>算數1</strong>)</td><td></td><td>左結合</td></tr><tr><td>&lt;&lt;, &gt;&gt;</td><td></td><td>左結合</td></tr><tr><td>&lt;, &gt;, ≤, ≥ (<strong>關係2</strong>)</td><td></td><td>左結合</td></tr><tr><td>位元 (<strong>3</strong>)</td><td></td><td>左結合</td></tr><tr><td>logical (<strong>4</strong>)</td><td></td><td>左結合</td></tr><tr><td>= (assign)</td><td><strong>低</strong></td><td>右結合</td></tr></tbody></table><ul><li>Note:<ol><li><p>1&gt;2&gt;3&gt;4</p></li><li><p>多個 operator 之運算, 先看 priority, 若相同在看 associate</p></li><li><p>Associative 分為：</p><ul><li>左結合 ((3+5)+8)</li><li>右結合 (3+(5+8))</li></ul></li><li><p>operator 分為：</p><ol><li>unary operator (單元)<br>ex: -5, !flag</li><li>binary operator (二元)<br>ex: 3+5, 6-4, 7*8</li><li>trinary operator (三元)<br><code>條件式 ? x : y</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (條件式)</span><br><span class="line">&#123;</span><br><span class="line">    x</span><br><span class="line">&#125; else </span><br><span class="line">&#123;</span><br><span class="line">    y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>=</strong>: assign , <strong>==</strong>: equals</p></li></ol></li></ul><h2>++, --</h2><table><thead><tr><th>前置式</th><th>後置式</th></tr></thead><tbody><tr><td>先做++, --, 再取值</td><td>先取值, 再做++, --</td></tr><tr><td>++x, --x</td><td>x++, x--</td></tr></tbody></table><ul><li><p>Ex1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 5, y&#x3D;5;</span><br><span class="line">int A, B;</span><br><span class="line">A &#x3D; x++;</span><br><span class="line">B &#x3D; ++y;</span><br><span class="line">print(A, B, x, y);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5, 6, 6, 6</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2:<br><code>a = 3, b = 6</code>, 則 <code>39/-++a+-20%b--</code><br>Sol:<br><code>39/(-4)+(-29)%6</code> = <code>-9 + (-5)</code> = <code>-14</code></p></li></ul><h2>位元運算</h2><ul><li>概念：先將資料化成 2 進制, 再開始進行運算</li></ul><ol><li>AND (&amp;)</li><li>OR (|)</li><li>XOR (^)</li><li>&lt;&lt;</li><li>&quot;&gt;&gt;&quot;</li></ol><ul><li>EX1:  <code>int x = 8 &amp; 6;</code>, <code>(0 0 0 0)2 = 0</code>, 同時為 1 才成立, <strong>像 (．)</strong></li><li>EX2: <code>int x = 8 | 6;</code>, <code>(1 1 1 0)2 = 14</code>, <strong>像 (+)</strong></li><li>EX3: <code>int x = 8 ^ 6;</code>, <code>(1 1 1 0 )2 = 14</code>, <strong>相同為 0, 相異為 1</strong></li><li>EX4: &lt;&lt; 左移, <code>x &lt;&lt; n</code> =&gt; 將 x 左移 n 個 bits,<br>作法：在右邊加上 n 個 0 (具備 <strong>乘法</strong> 效果)<br>例如：<code>int x = 8 &lt;&lt; 2;</code>, (1000<strong>00</strong>)2 = 32</li><li>EX5: &gt;&gt; 右移, <code>x &gt;&gt; n</code> =&gt; 將 x 右移 n 個 bits,<br>作法：<ul><li>step1 =&gt; 將右邊<strong>砍掉</strong> n 個 bits <strong>維持 sign bit</strong></li><li>step2 =&gt; 在左邊補上<ol><li>正 =&gt; 0 (n 個)</li><li>負 =&gt; 1 (n 個)<br>（具備 <strong>除法</strong> 效果)例如：<code>int x = 8 &gt;&gt; 2;</code>, (<strong>00</strong>1000)2 = 2</li></ol></li></ul></li></ul><h2>Logical</h2><h3>NOT (!)</h3><ul><li>false -&gt; true</li><li>true -&gt; false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool flag &#x3D; true;</span><br><span class="line">&#x3D;&gt; !flag &#x3D;&gt; false</span><br></pre></td></tr></table></figure></li></ul><h3>AND (&amp;&amp;) and OR (||)</h3><ul><li><strong>布林運算式最佳化</strong>  =&gt; <strong>短路現象</strong> =&gt; <strong>shortcut 捷徑運算</strong></li><li>A, B 均為 conditional (條件式)<br><code>if(A &amp;&amp; B)</code>, A = false, B 不做, 結果必為 false<br><code>if(A || B)</code>, A = true, B 不做, 結果必為 true</li></ul><h2>if - else</h2><ul><li><p>格式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (cond 1) &#123;</span><br><span class="line">    true (2)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    false (3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>1 ? 2 : 3</p></li><li><p>格式二：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (cond) &#123;</span><br><span class="line">    true 1</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        true 2</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        false 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">if (cond) &#123;</span><br><span class="line">    1</span><br><span class="line">&#125;else if (cond) &#123;</span><br><span class="line">    2</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Note: 當 if ... else 沒有 block 時, 則只會影響到下一個 statement (敘述)</p></li><li><p>ex1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 1;</span><br><span class="line">if (x &lt; 5) &#123;</span><br><span class="line">    x--;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line">x++;</span><br><span class="line">printf(&quot;%d&quot;, x);</span><br></pre></td></tr></table></figure></p></li><li><p>ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 10;</span><br><span class="line">&#x2F;*</span><br><span class="line">    說明, 此程式在判別 x 是否大於 5 後, 再行動行</span><br><span class="line">*&#x2F;</span><br><span class="line">if (x &gt; 5) </span><br><span class="line">    x &#x3D; x + 5;</span><br><span class="line">else </span><br><span class="line">    x &#x3D; x - 5;</span><br><span class="line">printf(&quot;%d&quot;, x);</span><br></pre></td></tr></table></figure></p></li></ul><blockquote><p>Note: 註解可分, // =&gt; 單行, /<em>...</em>/ =&gt; 多行註解</p></blockquote><ul><li>ex3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 3, j &#x3D; 5;</span><br><span class="line">if (cond) &#123;</span><br><span class="line">    printf(&quot;%d&quot;, i);</span><br><span class="line">    printf(&quot;%d&quot;, j);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    printf(&quot;false&quot;);</span><br><span class="line">    printf(&quot;%d, %d&quot;, i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Q: cond 為：<ol><li>(i = 0) &amp;&amp; (j = 4), false, 0, 5 =&gt; Ans</li><li>i == 2 &amp;&amp; j == 4, false, 3, 5</li><li>(i = 0) &amp; (j = 4), false, 0, 4</li><li>(i = 2) || (j = 4), 2, 5</li></ol></li></ul><h2>switch...case</h2><ul><li><p>思考：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(c1)</span><br><span class="line">else if (c2)</span><br><span class="line">else if (c3)</span><br><span class="line">else</span><br><span class="line">&#x2F;&#x2F; 當 else if 太多時，採用 switch...case 較清楚</span><br></pre></td></tr></table></figure></p></li><li><p>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(變數 or 運算式)</span><br><span class="line">&#123;</span><br><span class="line">    case 符合文 or 數字：</span><br><span class="line">        statement;</span><br><span class="line">    case ...:</span><br><span class="line">        statement;</span><br><span class="line">    case ...:</span><br><span class="line">        ...;</span><br><span class="line">    default: &#x2F;&#x2F;當所有 case 皆不成立, 則於此</span><br><span class="line">        statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>執行方式：</p><ul><li>step1: 從 switch 的變數去比對哪個 case 符合條件</li><li>step2: 從符合的 case 之 statement 往下做, 直到 break 或 block 結束才停止</li></ul></li><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch(x) &#123;</span><br><span class="line">    default:</span><br><span class="line">        printf(&quot;No match&quot;);</span><br><span class="line">    case 1:</span><br><span class="line">        printf(&quot;1&quot;);</span><br><span class="line">    case 2:</span><br><span class="line">        printf(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1. x &#x3D; 2 &#x3D;&gt; 印出 2</span><br><span class="line">&#x2F;&#x2F; 2. x &#x3D; 5 &#x3D;&gt; 印出 No match 1 2</span><br></pre></td></tr></table></figure></p></li></ul><h2>重複 =&gt; loop in C 常用 loop 語法</h2><h3>for</h3><ul><li><p>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for ( exp1(1); exp2(2); exp3(4)) </span><br><span class="line">&#123;</span><br><span class="line">    statement(3);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1. initial: 只做一次，於進入時做</span><br><span class="line">&#x2F;&#x2F; 2. conditional: 成立，做 3, 接著 4, 再回到 2。不成立，跳出 for loop</span><br><span class="line">----------------------------------</span><br><span class="line">&#x2F;&#x2F; special case:</span><br><span class="line">for ( ; (true); ;)</span><br><span class="line">[</span><br><span class="line">    &#x2F;&#x2F; 無窮迴圈</span><br><span class="line">]</span><br><span class="line">&#x3D;&gt;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex: 1+2+3....+10, 用 for 寫<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0, i;</span><br><span class="line">for(i &#x3D; 1; i ≤ 10; i++) &#123;</span><br><span class="line">    sum &#x3D; sum + i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;sum&#x3D;%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 55, i &#x3D; 11 最終跑到 11 不成立</span><br></pre></td></tr></table></figure></p></li></ul><h3>while</h3><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 承上題</span><br><span class="line">int sum &#x3D; 0, i;</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">while (i ≤ 10)</span><br><span class="line">&#123;</span><br><span class="line">    sum &#x3D; sum + i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;sum&#x3D;%d&quot;, sum);</span><br></pre></td></tr></table></figure></li></ul><h3>do...while</h3><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do(1)</span><br><span class="line">&#123;</span><br><span class="line">(3)</span><br><span class="line">(4)</span><br><span class="line">&#125;while(2);</span><br></pre></td></tr></table></figure></li></ul><h3>Compare 前測式 VS 後測式</h3><table><thead><tr><th>前測式</th><th>後測式</th></tr></thead><tbody><tr><td>先做測試，成立才做 statement =&gt; 最少做 0 次</td><td>先做，再做測試 =&gt; 最少做 1 次</td></tr><tr><td>while, for loop</td><td>do-while</td></tr></tbody></table><ul><li>Note: C語言和 C++ 中, 所有關鍵字都是小寫</li></ul><h3>Compare counted loop VS conditional loop</h3><table><thead><tr><th>counted loop (計數式)</th><th>conditional loop(條件式)</th></tr></thead><tbody><tr><td>執行次數明確</td><td>執行次數不明確，在一特定的條件，成立或不成立才終止</td></tr><tr><td>ex: 1+2+....+100</td><td>linked list 長度</td></tr><tr><td>for loop</td><td>while loop</td></tr></tbody></table><h3>continue &amp; break</h3><table><thead><tr><th>continue</th><th>break</th></tr></thead><tbody><tr><td>遇到時，則之後的敘述不做，直接進入 loop 的下一回合</td><td>遇到時，直接跳出所屬的 loop</td></tr></tbody></table><ul><li><p>ex:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 2; i ≤ 10; i+&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &#x3D;&#x3D; 6) continue;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; i  2 4 6 8  10 12</span><br><span class="line">&#x2F;&#x2F;sum 2 6 X 14 24 stop</span><br><span class="line">&#x2F;&#x2F;sum &#x3D; 24</span><br></pre></td></tr></table></figure></p></li><li><p>ex2: 承上題 若 continue 改為 break<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 2; i ≤ 10; i+&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &#x3D;&#x3D; 6) break;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; i  2 4 6 </span><br><span class="line">&#x2F;&#x2F;sum 2 6 X </span><br><span class="line">&#x2F;&#x2F;sum &#x3D; 6</span><br></pre></td></tr></table></figure></p></li><li><p>ex3: 呈例 2, 將 <strong>==</strong> 改為 <strong>=</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 2; i ≤ 10; i+&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &#x3D; 6) break;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sum &#x3D; 0</span><br></pre></td></tr></table></figure></p></li></ul><h2>Pointer (指標)</h2><ul><li>說明：</li></ul><table><thead><tr><th>一般變數</th><th>指標變數</th></tr></thead><tbody><tr><td>int x;</td><td>int *p;</td></tr></tbody></table><ul><li><p>Ex:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 5;</span><br><span class="line">&#x2F;&#x2F; 下面兩行為 int *p &#x3D; &amp;x</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; &amp;x;</span><br><span class="line">*p &#x3D; *p + 1; &#x2F;&#x2F; 利用指標間接操作指向的內容</span><br><span class="line">printf(&quot;%d&quot;, x)</span><br></pre></td></tr></table></figure></p></li><li><p>Ex: 一學生採 C language coding 如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    printf(&quot;%d, %d&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp &#x3D; x;</span><br><span class="line">    x &#x3D; y;</span><br><span class="line">    y &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Q:</p><ol><li>為何呼叫 swap 後, a, b 沒變動？<br>由於此時 swap 的參數傳遞是採用 call by value, 而非 call by address, 故沒有 side effect, 因此 x, y 的變動, a, b 不受影響</li><li>How to modify the program?<br>in C =&gt; 用 pointer 以改成 call by address<br>in C++ =&gt; 用 pointer or 用 call by reference<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">    swap(&amp;a, &amp;b);</span><br><span class="line">    printf(&quot;%d, %d&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int *x, int *y)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp &#x3D; *x;</span><br><span class="line">    *x &#x3D; *y;</span><br><span class="line">    *y &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2>陣列(Array)</h2><ul><li><p>宣告方式：<br>type 變數 [size];<br>int  A  [5];</p></li><li><p>Note: 在 C, C++ 中, 陣列名稱本身為 <strong>一固定(其內容不可更動)指標</strong>, 永遠指向第 [0]格</p></li><li><p>Ex:</p><ol><li>A[0] = 10</li><li>A = 1000</li><li>*A = 10</li><li>&amp;A[0] = 1000</li><li>A[2] = 30</li><li>&amp;A[2] = 1008</li><li>*(A+1) = 20 -&gt; A(陣列指標)+1 =&gt; 往下一格</li><li>*(A++) = compile error (因為試圖去更動A, 但A的內容不可更動) -&gt; A++ =&gt; A=A+1</li></ol></li><li><p>Ex1:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int A[5];</span><br><span class="line">int *p;</span><br><span class="line">for ( i &#x3D; 0; ≤ 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">    A[i] &#x3D; 5 - i;</span><br><span class="line">&#125;</span><br><span class="line">p &#x3D; A; &#x2F;&#x2F; A為何不用&amp;, 因為A已經是 address 所以不須加</span><br></pre></td></tr></table></figure><img src="pointer.png" alt=""></p></li></ul><p>Q:<br>1. printf(*p);  5<br>2. printf(<em>p++);  5 // 先取值再往下一格<br>3. printf(</em>++p);  3<br>4. printf(++*p);  4<br>5. printf((<em>p++));  4<br>6. printf(</em>--p);  4</p><ul><li>Note:<br>p++ or ++p =&gt; p=p+1 往下一格<br>p-- or --p =&gt; p=p-1 往上一格</li></ul><p>(*p)++ or ++*p =&gt; *p=*p+1 將p指向的內容+1<br>(*p)-- or --*p =&gt; *p=*p-1 將p指向的內容-1</p><h2>雙重指標</h2><ul><li><p>宣告：<br>type  **變數名稱<br>指標的指標<br>=&gt; 需 &quot;2次&quot; 的 Mem. access 才可取得data</p></li><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 5;</span><br><span class="line">int *p &#x3D; &amp;x;</span><br><span class="line">int **q &#x3D; &amp;p;</span><br></pre></td></tr></table></figure><img src="double_pointer.png" alt=""></p></li><li><p>Q:</p><ol><li>q = ?  2000</li><li>&amp;q = ?  3000</li><li>*q = ?  1000</li><li>**q = ?  5</li></ol></li></ul><h2>字串的處理方式</h2><ul><li>C 語言中無 string 之 data type =&gt; 拿 &quot;字元陣列&quot; 來存字串</li><li>ex: cahr a[10];<br>a = &quot;hello&quot;;</li><li>ex1:<br>char *S = &quot;hello&quot;;<ul><li>Q:<ol><li>S[0] = ?</li><li>*(S+4) = ?</li><li>printf(&quot;%s&quot;, S+2);?</li></ol></li><li>Sol:<ol><li>h</li><li>o</li><li>llo</li></ol></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.2 C 語言重點&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;C Language&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;結構
&lt;ul&gt;
&lt;li&gt;xxx.c&lt;/li&gt;
&lt;li&gt;header: 表頭&lt;/li&gt;
&lt;li&gt;body: object code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="C" scheme="https://pingjing0628.github.io/tags/C/"/>
    
      <category term="運算子" scheme="https://pingjing0628.github.io/tags/%E9%81%8B%E7%AE%97%E5%AD%90/"/>
    
      <category term="位元運算" scheme="https://pingjing0628.github.io/tags/%E4%BD%8D%E5%85%83%E9%81%8B%E7%AE%97/"/>
    
      <category term="Pointer" scheme="https://pingjing0628.github.io/tags/Pointer/"/>
    
      <category term="雙重指標" scheme="https://pingjing0628.github.io/tags/%E9%9B%99%E9%87%8D%E6%8C%87%E6%A8%99/"/>
    
      <category term="Structure Programming Language" scheme="https://pingjing0628.github.io/tags/Structure-Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-基本介紹</title>
    <link href="https://pingjing0628.github.io/2021/07/05/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/"/>
    <id>https://pingjing0628.github.io/2021/07/05/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/</id>
    <published>2021-07-05T09:30:35.000Z</published>
    <updated>2022-09-20T14:41:56.494Z</updated>
    
    <content type="html"><![CDATA[<h1>5.1 基本介紹</h1><hr><h2>Programming Language 程式語言</h2><table><thead><tr><th>年代</th><th>特徵1</th><th>特徵2</th><th>特徵3</th><th>特徵4</th><th>特徵5</th></tr></thead><tbody><tr><td>1GL (Machine Language)<strong>低階語言</strong></td><td>由 0, 1 組成</td><td>為機器能直接執行的語言</td><td>user 不易理解</td><td></td><td></td></tr><tr><td>2GL (Assembly Language)<strong>低階語言</strong></td><td>提供簡易的符號供 user 使用</td><td>用 &quot;assembler&quot; 將之轉成 object code</td><td>Ex: ADD R1 3 <strong>=&gt; 將 3 加到 Register R1 中</strong></td><td></td><td></td></tr><tr><td>3GL (High-Level Language)<strong>高階語言</strong></td><td>提供更多貼近 user 的指令</td><td>多為程序導向的程式語言 (procedural language -&gt; tell &quot;how&quot; to do)</td><td>Ex: <code>int i = 3 + 5;</code></td><td>代表：C (具 self-compile), PASCAL, FURTRAN, COBOL, BASIC, C++, JAVA, .NET</td><td>C 語言：  1. compile 完的 object code, 不能跨平台  2. 此邊是語法, 故可跨平台</td></tr><tr><td>4GL (Non-procedural Language) 非程序導向<strong>高階語言</strong></td><td>又稱為<strong>宣告式語言 (Declaractive Language)</strong> -&gt; tell &quot;what&quot; to do</td><td>代表：SQL, report generator</td><td>Ex: <code>Select height From student where height ≥ 180</code></td><td></td><td></td></tr><tr><td>5GL (Natural Language) 自然語言<strong>高階語言</strong></td><td>使用到人工智慧的技術</td><td>為機器能直接執行的語言</td><td>代表：LISP, PROLOG</td><td></td><td></td></tr></tbody></table><h3>種類</h3><table><thead><tr><th>種類</th><th>代表性程式語言</th><th>備註</th></tr></thead><tbody><tr><td>Interpreter language 直譯</td><td>Basic, Java, Javascript, ASP, PHP, JSP, ruby, groovy, python</td><td></td></tr><tr><td>Compile language 編譯</td><td>C, C++, FURTRAN, PASCAL, COBAL -&gt; 先編譯成 object code</td><td>java, javascript 沒有關係</td></tr><tr><td>先 compile, 後 interpreter -&gt; p-code, java</td><td>跨平台 (cross-platform)</td><td></td></tr><tr><td>Object Oriented Programming (OOP)</td><td>java, C++, C#, .NET, javascript, ruby, python, groovy, VB, smalltalk, Ada</td><td></td></tr><tr><td>Functional Programming Language (函式編程語言) FPL</td><td>LISP, ML, F#</td><td>適用於平行運算, 以 function 為 first class, 各 function 間 No side effect</td></tr></tbody></table><h2>funtion (函式) =&gt; C, C++, Java</h2><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return type   function name  parameter list</span><br><span class="line">&#123;</span><br><span class="line">    function code (body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>return type</code> : 回傳型態 <strong>output</strong></li><li><code>function name</code>: in c, c++ 中 main 代表主程式</li><li><code>parameter List</code>: 參數串列, 接收外界呼叫時須引入的參數 <strong>input</strong></li><li><code>function code</code> <strong>process</strong></li></ol><h2>funtion calling (呼叫)</h2><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">funA()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    ...</span><br><span class="line">    funcB(a, b) &#x2F;&#x2F; (a, b 為 actual parameter 實際參數 AP)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funB(x, y) &#x2F;&#x2F; (x, y 為 foraml parameter 型式參數 FP)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>參數傳遞 (funcB in funcA)</li><li>funcB execute</li><li>funcB return</li></ol><h2>參數傳遞種類</h2><table><thead><tr><th>Call by value</th><th>Call by address</th><th>Call by name</th><th>Call by value-result</th></tr></thead><tbody><tr><td>AP 跟 FP 佔用不同的 memory space</td><td>操作相同 Memory space</td><td>AP 會直接取代 FP 之所在</td><td>在 function 最後結束時, 將 FP 寫回對應 AP 之內容</td></tr><tr><td>No side effect</td><td>有</td><td>有</td><td>有</td></tr><tr><td>binding 速度慢 (最慢)</td><td>最快</td><td>居中</td><td></td></tr><tr><td>不適合用於結構型資料的參數傳遞</td><td>適合</td><td></td><td></td></tr></tbody></table><ul><li>Ex1:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">    fun(a, b);</span><br><span class="line">    print(a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    x &#x3D; 3;</span><br><span class="line">    y &#x3D; 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>問分別採 1. call by value 2. call by address 3. call by value result, output = ? a = ? b = ?<br><strong>Sol:</strong></p><ol><li>a=10, b=20</li><li>x, y 為記錄 a, b 的位址, 並指回原變數。Ans: a=3, b=6</li><li><strong>最後結束時會將 FP 寫回對應 AP 之內容</strong>, 具 side effect(砍掉前，將最後的值抓回)。Ans: a=3, b=6</li></ol><ul><li>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 4, b &#x3D; 6;</span><br><span class="line">    fun(a, b, a+b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">    x &#x3D; 7;</span><br><span class="line">    y &#x3D; 10;</span><br><span class="line">    int t &#x3D; z * z;</span><br><span class="line">    printf(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>問採 1. call by name? 2. call by address?<br><strong>Sol:</strong></p><ol><li>87, 需注意 <code>a+b*a+b</code>先乘除後加減</li><li>100</li></ol><ul><li>Note:<br>採 <code>call by-address</code> 時, 若有運算式, 則此採 <strong>call by-value</strong> 來接收<br><code>call by-reference</code> 一般而言相同, 但在 c++ 中, 2 者完全不同<br><code>call by-name</code> 多做一件事, 所以居中</li></ul><h2>結構化程式三要求 Structure Programming Language SPL</h2><p>三要素：</p><ol><li>循序 sequential<br>指令會依序一一往下執行</li><li>選擇 selective/conditional<br>利用 &quot;判別式&quot; 來決定接下來的執行步驟為何<br><code>if...else...</code><br><code>switch...case...</code></li><li>重複 repeat/iteractive<br>利用 &quot;loop&quot; 來反覆執行部分的 step<br><code>for loop</code><br><code>while</code><br><code>do...while</code></li></ol><ul><li>SPL 中避免使用 &quot;跳躍&quot; 指令或動作<br><code>jump</code>, <code>goto</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.1 基本介紹&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Programming Language 程式語言&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;年代&lt;/th&gt;
&lt;th&gt;特徵1&lt;/th&gt;
&lt;th&gt;特徵2&lt;/th&gt;
&lt;th&gt;特徵3&lt;/th&gt;
&lt;th&gt;特徵4&lt;/t
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="Structure Programming Language" scheme="https://pingjing0628.github.io/tags/Structure-Programming-Language/"/>
    
      <category term="OOP" scheme="https://pingjing0628.github.io/tags/OOP/"/>
    
      <category term="Call by value" scheme="https://pingjing0628.github.io/tags/Call-by-value/"/>
    
      <category term="Call by address" scheme="https://pingjing0628.github.io/tags/Call-by-address/"/>
    
      <category term="Call by name" scheme="https://pingjing0628.github.io/tags/Call-by-name/"/>
    
      <category term="Call by value result" scheme="https://pingjing0628.github.io/tags/Call-by-value-result/"/>
    
  </entry>
  
  <entry>
    <title>Chapter4-系統程式-part2</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part2/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part2/</id>
    <published>2021-07-02T15:21:54.000Z</published>
    <updated>2022-09-19T12:55:55.920Z</updated>
    
    <content type="html"><![CDATA[<h1>4 系統程式 (System Program)</h1><hr><h2>補充 - Linking 的種類</h2><ul><li>Static Linking (like MACRO)</li><li>Dynamic Linking (like Subroutine)</li></ul><h3>Static Linking</h3><ul><li>指在 linking 時會將外部參考的函式皆搬到程式中, 成為程式的一部份, 故<strong>程式將較佔 space, 但後續執行不需去呼叫外部函式</strong></li><li>巨集 =&gt; 程式碼被撐大</li><li>Static Linking =&gt; 執行檔會被撐大</li><li>圖：<img src="staticLinking.png" alt=""></li></ul><h3>Dynamic Linking</h3><ul><li>Linking 時, 只將外部參考和外部函式所在做繫結, 不將外部函式載入, 故執行時在動態呼叫之</li><li>Ex: .dll =&gt; Dynamic Linking Library</li></ul><h3>Compare</h3><table><thead><tr><th>Static Linking</th><th>Dynamic Linking</th></tr></thead><tbody><tr><td>可執行檔較大</td><td>較小</td></tr><tr><td>不需外部呼叫 =&gt; 快</td><td>需要 =&gt; 慢</td></tr><tr><td>若外部程式改 =&gt; 需 relinking</td><td>不需</td></tr><tr><td>不受外在影響 =&gt; 較安全</td><td>受影響 (駭客可以改, 由於動態呼叫, 因此會被影響) =&gt; 較不安全</td></tr></tbody></table><h2>P-code compiler</h2><ul><li>Def: 為 pesudo-machine 之 object code<ul><li>類似中間碼</li><li>與機器獨立</li><li>高可攜性 =&gt; <strong>具跨平台 cross platform</strong></li></ul></li><li>圖：<img src="p-code.png" alt=""></li><li>優點：只要機器上有 P-code interpreter 即可執行 =&gt; 具可攜性</li><li>缺點：P-code 使用 interpreter 執行, 所以執行速度較慢</li><li>中間碼：類似目的碼, 由 0, 1 組成, 但和機器獨立</li></ul><h2>Java-compiler</h2><p><img src="java-compiler.png" alt=""></p><h2>JVM - Java Virtual Machine</h2><p><img src="jvm.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;4 系統程式 (System Program)&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;補充 - Linking 的種類&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Static Linking (like MACRO)&lt;/li&gt;
&lt;li&gt;Dynamic Linking (like Subrouti
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="系統程式" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F/"/>
    
    
      <category term="System Program" scheme="https://pingjing0628.github.io/tags/System-Program/"/>
    
      <category term="Static Linking" scheme="https://pingjing0628.github.io/tags/Static-Linking/"/>
    
      <category term="Dynamic Linking" scheme="https://pingjing0628.github.io/tags/Dynamic-Linking/"/>
    
      <category term="P-code Compiler" scheme="https://pingjing0628.github.io/tags/P-code-Compiler/"/>
    
      <category term="Java Compiler" scheme="https://pingjing0628.github.io/tags/Java-Compiler/"/>
    
      <category term="JVM" scheme="https://pingjing0628.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Chapter4-系統程式-part1</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part1/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part1/</id>
    <published>2021-07-02T15:21:49.000Z</published>
    <updated>2022-09-20T14:41:49.890Z</updated>
    
    <content type="html"><![CDATA[<h1>4 系統程式 (System Program)</h1><hr><h2>Software License</h2><table><thead><tr><th>Software Licence</th><th>Def</th><th>licence</th><th>Open source code</th><th>Ex</th></tr></thead><tbody><tr><td><strong>Trial software</strong></td><td>試用一段時間, 若欲長期使用需付費</td><td>Yes</td><td>No</td><td>ACDSee</td></tr><tr><td><strong>Shareware</strong></td><td>同上, 但限制較寬鬆</td><td>Yes</td><td>No</td><td>WinRAR</td></tr><tr><td><strong>Freeware</strong></td><td>free</td><td>Yes</td><td>No</td><td>IE, MSN</td></tr><tr><td><strong>Public domain</strong></td><td>free</td><td>No</td><td>No</td><td>X</td></tr><tr><td><strong>Open software</strong></td><td>free</td><td>No</td><td>Yes</td><td>Redhat, Open Office</td></tr></tbody></table><h2>Open Source Software</h2><p>Def:</p><ul><li>指沒有 licence 限制, 可 free 使用, 且可拿到程式碼</li><li><strong>從 Open source 取得的程式, 修改後亦無 licence 所屬也為 Open source</strong></li></ul><h2>System Program</h2><h3><strong>Assembler (組譯器)</strong></h3><ul><li>Def: 將組合語言轉成 object code (<strong>目的碼, 為機器可識別之程式</strong>), 以便系統執行之</li><li>圖：<img src="assembler.png" alt=""></li></ul><h3><strong>Linker/Loader (鏈結器/載入器)</strong> =&gt; linking loader</h3><ul><li>欲將 object code 載入 memory 中, 過程需<ol><li><strong>linking (連結)</strong>: 將 object code 中的外部參考之宣告, 正式跟外部函式庫鏈結</li><li><strong>relocation (重定址)</strong>: 將程式中參考位址依實際 memory 所在重新計算其實際的位址</li><li><strong>loading (載入)</strong>: 正式將上述完成之 object code 載入 memory 中</li></ol></li></ul><h3><strong>Compiler (編譯器)</strong></h3><ul><li>Def: 將高階語言 (c, c++) 轉成低階的 object code</li><li>圖：<img src="compiler.png" alt=""></li><li>Compiler 過程：<ol><li>Lexical Analysis</li><li>Syntax Analysis</li><li>Semantic Analysis</li><li>Intermediate Code Optimization</li><li>Machine Dependent Code Generation and Optimization</li><li>Generate the Object Code<br>1.~ 4. =&gt; <strong>Machine Independent</strong><br>5.~ 6. =&gt; <strong>Machine Dependent</strong></li></ol></li><li>Lexical Analysis 語彙分析<ul><li>Scan the program and find out the token (語彙單元)<ol><li><strong>Terminal Symbol (終端符號)</strong> =&gt; keyword, 保留字</li><li><strong>Identifier (識別字)</strong> =&gt; 變數</li><li><strong>Liferal (常數)</strong> =&gt; 文, 數字</li></ol><ul><li>Ex: int(1) x(2) = (1) 20(3);(1)</li></ul></li><li>圖：<img src="lexical.png" alt=""></li></ul></li><li>Syntax Analysis 語法分析<ul><li>Def: 判別程式敘述是否合乎文法 (Grammer)<ul><li>合乎：建立出 <strong>parsing tree 或 syntax tree</strong></li><li>不合乎：output syntax tree</li></ul></li><li>圖：<img src="syntax.png" alt=""></li><li>文法 (Grammer)<ul><li>Note: 剖析工具: parser (剖析器)</li><li>Def: <code>G = &lt;N, T, P, S&gt;</code><ul><li>N: Non-terminal symbol set (非終端)</li><li>T: Terminal symbol set (終端)</li><li>P: Production rules (推衍規則)</li><li>S: Start symbol (S ∈ N) (起始)</li></ul></li><li>Ex:<br><code>G = &lt;N, T, P, S&gt;</code>, <code>N = {s, A, B}</code>, <code>T = {a, b}</code>,<br><code>P = {S -&gt; A|B; A -&gt; aA|a; B -&gt; bB|b;}</code> (-&gt; 為推衍符號),<br><code>S = s ∈ N</code> (S 為起始符號, s 為起始符號的名稱), 問 abaa, aaa 是否合乎文法？<br><strong>Sol:</strong><ol><li>S -&gt; A -&gt; aA -&gt; 此無法推出 b, 故不合乎文法</li><li>S -&gt; A -&gt; aA -&gt; aaA -&gt; aaa, 可推論出, 故合乎文法</li></ol></li></ul></li><li>Parsing tree 剖析樹<ul><li>Def: 剖析文法敘述所建立之樹</li><li>作法:<ul><li>N 必為 Tree 中的非終端節點 (degree ≥ 1)</li><li>T 必為 Tree 中的終端節點 (degree = 0)</li></ul></li><li>Ex:<br><code>G = &lt;N, T, P, S&gt;</code>, <code>N = {E, T, F}</code>, <code>T = {+, -, *, /, id (,)}</code>,<br><code>P = {E -&gt; E+T|E-T|T; T -&gt; T*F|T/F|F; F -&gt; id|(E);}</code>, <code>S = E ∈ N</code>,<br>問<ol><li>id + id * id 合法建立剖析樹</li><li>id * (id - id / id)?</li></ol><ul><li>Note: 括號 &quot;()&quot;, 不可以被分割於 2 不同區塊之中<strong>Sol:</strong><br><img src="parsingTree.png" alt=""></li></ul></li></ul></li><li>Syntax tree 語法樹<ul><li>目的：<ul><li>簡化剖析樹</li><li>只保留 Terminal symbol</li><li>利用中序追蹤可還原運算式</li></ul></li><li>Note: <strong>括號不需考慮</strong> (因為已有 priority 之考量)</li></ul></li><li>文法種類<table><thead><tr><th>Note</th><th>Type</th><th>別名</th><th>自動機</th></tr></thead><tbody><tr><td><strong>自由度最大</strong></td><td>0</td><td>Unrestricted (不受限) grammer (AI)</td><td>Turing Machine (杜林機)</td></tr><tr><td><strong>如變數的宣告</strong></td><td>1</td><td>Context-sensitive (上下文相關) grammer</td><td></td></tr><tr><td><strong>高階語法</strong></td><td>2</td><td>Context-free (上下文無關) grammer</td><td></td></tr><tr><td></td><td>3</td><td>Regular grammer</td><td></td></tr></tbody></table></li></ul></li><li>Semantic Analysis 語意分析<ul><li>目的：依剖析結果, 呼叫對應的 semantic routine 或 action routine 以產生 <strong>intermediate code (中間碼)</strong> (<strong>類似目的碼一樣由 0, 1 組成, 但和機器獨立謂之</strong>)</li><li>圖：<img src="semantic.png" alt=""></li></ul></li><li>Intermediate Code Optimization 中間碼最佳化<ul><li>目的：<ol><li>精簡中間碼</li><li>所佔用 space 下降</li><li>效益提高</li></ol></li><li>常用技巧：<ol><li>刪除共通運算式<br><code>A = B + C * D + 2</code><br><code>F = 5 + (B + C + D) / 3</code><br>令 B, C, D 皆不變<br>α = B + C * D</li><li>先求出常數運算<br>Ex: <code>A = 3.14 * 2.56 / 3.2 + 8 - E</code><br>求 α = 3.14 * 2.56 / 3.2 + 8</li><li>布林運算式最佳化<ul><li>Ex1: if (A and B), A B 皆為 Condition (條件式)<br>若 A = false, B 不做 =&gt; 結果必為 false</li><li>Ex2: if (A or B), 若 A = true, B 不做 =&gt; 結果必為 True</li><li>Note: 此概念為：<ul><li>短路：short-circuit</li><li>又稱 <strong>&quot;捷徑運算&quot;</strong></li></ul></li></ul></li></ol></li></ul></li><li>程式中常見的 error<br><img src="error.png" alt=""></li></ul><h3><strong>Interpreter (直譯器)</strong></h3><ul><li>Def:<ul><li>不事先將 source code 轉成 object code</li><li>直接拿 source code 執行, 依原始程式 logical 順序進行</li><li>執行期間 interpreter 須留在 memory 之中</li></ul></li><li>圖：<img src="interpreter.png" alt=""></li></ul><h3>Compare Compiler vs Interpreter</h3><table><thead><tr><th>Compiler</th><th>Interpreter</th></tr></thead><tbody><tr><td>執行不需於 memory 中</td><td>需要</td></tr><tr><td>會事先產生 object code (<strong>有最佳化, 故效益佳</strong>)</td><td>不會, 直接依 logical 執行, 產生結果</td></tr><tr><td>全部 scan, 故比較沒有漏洞</td><td>較易有漏洞</td></tr><tr><td>修改 =&gt; recompile (彈性差)</td><td>不需 recompile (彈性佳)</td></tr><tr><td>開發時期較不適用</td><td>適用</td></tr><tr><td>找 bug 較不易</td><td>較易找到 bug 所在</td></tr><tr><td>初學者較不易</td><td>初學者較易上手</td></tr></tbody></table><hr><h3>Macro 巨集</h3><ul><li>Def: 開放式副程式 (Open subroutine)<br>將一連串的指令定義為巨集指令, 當 source code 轉換時, 遇到巨集呼叫, 就將對應的連串指令插入於呼叫處</li><li>圖：<img src="macro.png" alt=""></li><li>特性：<ol><li>巨集呼叫於<strong>程式轉換</strong>期間, 而非 <strong>runtime</strong></li><li>呼叫 Ｎ 次, 需插入巨集本文 N 次 =&gt; <strong>浪費空間</strong></li><li>執行階段, 不需做控制移轉 =&gt; <strong>快</strong></li><li>多此使用一單獨定義的常式 (定義一次, 可使用多次)</li></ol></li></ul><h3>Subroutine 副程式 =&gt; 又稱 close subroutine</h3><ul><li>Def: 於<strong>執行中</strong>, 當 subroutine 被呼叫才<strong>動態</strong>的去呼叫之, 並將資料及控制權移轉給他, 待完成, 再移轉回來</li><li>優點：只佔用一份 memory =&gt; 省 space</li><li>缺點：需做控制權移轉 =&gt; speed 下降</li></ul><h3>Compare Macro vs Subroutine</h3><table><thead><tr><th>MACRO</th><th>Subroutine</th></tr></thead><tbody><tr><td>Speed 快</td><td>Speed 慢</td></tr><tr><td>以空間換時間</td><td>以時間換空間</td></tr><tr><td>space 浪費</td><td>space 省</td></tr></tbody></table><h2>Summary</h2><p><img src="summary.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;4 系統程式 (System Program)&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Software License&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Software Licence&lt;/th&gt;
&lt;th&gt;Def&lt;/th&gt;
&lt;th&gt;licence&lt;/th&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="系統程式" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F/"/>
    
    
      <category term="System Program" scheme="https://pingjing0628.github.io/tags/System-Program/"/>
    
      <category term="Software" scheme="https://pingjing0628.github.io/tags/Software/"/>
    
      <category term="Assembler" scheme="https://pingjing0628.github.io/tags/Assembler/"/>
    
      <category term="Linker/Loader" scheme="https://pingjing0628.github.io/tags/Linker-Loader/"/>
    
      <category term="Compiler" scheme="https://pingjing0628.github.io/tags/Compiler/"/>
    
      <category term="Interpreter" scheme="https://pingjing0628.github.io/tags/Interpreter/"/>
    
      <category term="Marco" scheme="https://pingjing0628.github.io/tags/Marco/"/>
    
      <category term="Subroutine" scheme="https://pingjing0628.github.io/tags/Subroutine/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-磁碟管理-part3</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part3/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part3/</id>
    <published>2021-07-01T16:10:14.000Z</published>
    <updated>2022-09-20T14:41:37.885Z</updated>
    
    <content type="html"><![CDATA[<h1>3.9 磁碟管理 (Disk Management)</h1><h2>目錄</h2><ul><li>Free space management<ul><li>Link list</li><li>Combination</li><li>Counting</li></ul></li><li>Allocation Method (配置方法)<ul><li>連續性配置 (contiguous allocation)</li><li>鏈結式配置 (linked allocation)<ul><li>FAT (file allocation table)</li></ul></li><li>索引配置 (index allocation)<ul><li>i-node</li></ul></li></ul></li><li>Disk structure**</li><li>Disk access time**</li><li>Disk scheduling**<ul><li>FCFS</li><li>SSTF</li><li>SCAN</li><li>C-SCAN</li><li>LOOK</li><li>C-LOOK</li></ul></li><li>補充</li><li><strong>RAID</strong></li><li><strong>RAID 的種類</strong><ul><li><strong>RAID1</strong></li><li><strong>RAID0+1</strong></li><li><strong>RAID2</strong></li><li><strong>RAID3 vs RAID4</strong></li><li><strong>RAID5</strong></li><li><strong>RAID6</strong></li></ul></li><li><strong>Summary</strong></li></ul><hr><h2>RAID Redundant Array of Independent Disks 磁碟陣列</h2><ul><li>Why RAID?<ol><li><strong>CPU 和 disk I/O 速度不對等</strong></li><li>資料安全性, 可靠性議題</li></ol></li><li>Solution:<ul><li>採用 &quot;<strong>data striping</strong>&quot; 資料切割：指將 data 分成幾個等分, 同時存到不同 disk 之中, <strong>以達平行 I/O 之效</strong></li></ul></li><li>RAID:<ul><li>Def: 指將多顆 physical disk, 組成一顆 logical disk 之後, 以達提高 I/O 效能跟增加資料的可靠性</li><li>圖：<img src="RAID.png" alt=""></li></ul></li></ul><h2>RAID 的種類</h2><ol><li><strong>RAID 0 (striping RAID)</strong></li></ol><ul><li>以效能導向</li><li><strong>速度最快的 RAID</strong></li><li><strong>沒有 fault tolerant</strong></li><li>Cost 低</li><li>至少需 2 顆 disk</li><li>圖：<img src="RAID0.png" alt=""></li></ul><ol start="2"><li><strong>RAID 1 (mirror RAID)</strong></li></ol><ul><li>至少有 ≥ 2 顆 disk 存相同的 data</li><li>具 <strong>fault tolerant</strong> 特色</li><li>Cost 高 (浪費一半 space)</li><li>Read 效益不佳, write 較差</li><li>至少需 2 顆 disk (資料保護)</li><li>圖：<img src="RAID1.png" alt=""></li></ul><ol start="3"><li><strong>RAID 0+1 (01) speed 快 &gt; RAID 10</strong></li></ol><ul><li>兼具 speed up + fault tolerant</li><li>Cost 極高</li><li>至少需 4 顆 disk</li><li>補充：RAID 1+0 (10)<ul><li>先做 mirror, 在做 striping</li><li>相較下, 此種方法可靠性更佳, 故現在較常用此</li></ul></li><li>圖：<img src="RAID01.png" alt=""></li></ul><ol start="4"><li><strong>RAID 2</strong> (被 RAID 3 ~ 5 取代)</li></ol><ul><li>採用 &quot;ECC&quot; (Error Correcting Code) 技術, 達容錯效果</li></ul><ol start="5"><li><strong>RAID 3 vs RAID 4</strong>|RAID 3|RAID 4||--|--||以 &quot;bit&quot; 為切割單位 (太頻繁)|以 &quot;block&quot; 為單位||效能較差|效能較好|</li></ol><ul><li>共同特色：<ul><li>採 <strong>parity check</strong> 做 data 的可靠性機制</li><li>會有一顆專門放 parity 的 disk =&gt; <strong>會成為效能上的瓶頸</strong></li><li>同時允許一顆 disk 損壞依舊可以復原</li></ul></li><li>圖：<img src="RAID3&amp;4.png" alt=""></li></ul><ol start="6"><li><strong>RAID 5</strong> =&gt; 同 RAID 4, 但將 parity data 平均在各 disk 之上</li></ol><ul><li>圖：<img src="parityData.png" alt=""></li><li>小比較：<table><thead><tr><th>RAID</th><th>Speed</th><th>單位</th><th>parity data</th></tr></thead><tbody><tr><td>3</td><td>慢</td><td>bit</td><td>集中</td></tr><tr><td>4</td><td>中</td><td>block</td><td>集中</td></tr><tr><td>5</td><td>快</td><td>block</td><td>分散</td></tr></tbody></table></li></ul><ol start="7"><li><strong>RAID 6</strong></li></ol><ul><li>採 &quot;parity check&quot; + &quot;read soloman code&quot; =&gt; 可允許同時 2 顆 disk 損壞, 仍可恢復</li><li><strong>可靠性優於 RAID 3 ~ 5</strong></li></ul><h2>Summary</h2><table><thead><tr><th>RAID</th><th>至少 disk 數</th><th>Speed</th><th>Cost</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>快</td><td>低 -&gt; striping</td></tr><tr><td>1</td><td>2</td><td>慢</td><td>高 -&gt; mirror</td></tr><tr><td>0+1</td><td>4</td><td>快</td><td>最高</td></tr><tr><td>3</td><td>3</td><td>居中</td><td>居中 -&gt; parity check</td></tr><tr><td>4</td><td>3</td><td>居中</td><td>居中 -&gt; parity check</td></tr><tr><td>5</td><td>3</td><td>居中</td><td>居中 -&gt; parity check</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.9 磁碟管理 (Disk Management)&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Free space management
&lt;ul&gt;
&lt;li&gt;Link list&lt;/li&gt;
&lt;li&gt;Combination&lt;/li&gt;
&lt;li&gt;Counting&lt;/li
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="Disk Management" scheme="https://pingjing0628.github.io/tags/Disk-Management/"/>
    
      <category term="RAID" scheme="https://pingjing0628.github.io/tags/RAID/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-磁碟管理-part2</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part2/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part2/</id>
    <published>2021-07-01T16:10:10.000Z</published>
    <updated>2022-09-19T12:55:32.403Z</updated>
    
    <content type="html"><![CDATA[<h1>3.9 磁碟管理 (Disk Management)</h1><h2>目錄</h2><ul><li>Free space management<ul><li>Link list</li><li>Combination</li><li>Counting</li></ul></li><li>Allocation Method (配置方法)<ul><li>連續性配置 (contiguous allocation)</li><li>鏈結式配置 (linked allocation)<ul><li>FAT (file allocation table)</li></ul></li><li>索引配置 (index allocation)<ul><li>i-node</li></ul></li></ul></li><li><strong>Disk structure</strong></li><li><strong>Disk access time</strong></li><li><strong>Disk scheduling</strong><ul><li><strong>FCFS</strong></li><li><strong>SSTF</strong></li><li><strong>SCAN</strong></li><li><strong>C-SCAN</strong></li><li><strong>LOOK</strong></li><li><strong>C-LOOK</strong></li></ul></li><li><strong>補充</strong></li><li>RAID</li><li>RAID 的種類<ul><li>RAID1</li><li>RAID0+1</li><li>RAID2</li><li>RAID3 vs RAID4</li><li>RAID5</li><li>RAID6</li></ul></li><li>Summary</li></ul><hr><h2>Disk structure</h2><ul><li>圖：<img src="diskStructure.png" alt=""></li><li>track 的水平集合 =&gt; surface (磁面)</li><li>track 的垂直集合 =&gt; cylinder (磁柱) 圓柱體</li><li>順序 小 -&gt; 大 =&gt; sector &lt; cluster &lt; track &lt; {surface, cylinder}</li><li>Ex: cylinder = 10, tracks = 20<ul><li>each track has 320 sector</li><li>each sector 的 size = 512 bytes<br>What's the disk total size?<br>Sol:<br><code>10 * 20 * 320 * 512 bytes</code><br><code>= 32000 KB</code><br>約等於 32 MB</li></ul></li></ul><h2>Disk access time</h2><ul><li><p>由下列組成：</p><ol><li>Seek time 搜尋時間：將 Header (讀寫頭) 移到指定的 Track 上方 (最耗時)</li><li>Rotation time 旋轉時間 (Latency 延遲)：將 data 轉到 Header 的下方 (耗時 中等)</li><li>Transfer time 傳輸時間：正式由 Header 讀取 data 做 disk  &lt;-&gt; Memory 傳輸 (耗時 小)</li></ol></li><li><p>Ex: seek time 平均需 8ms, 而 disk 為 7200RPM(轉), 問平均 disk access time = ?<br>RPM = Rotate Per Minute: 7200/60 = 120/secSol:<br>seek time + rotate (平均) = 8ms + 1/120 sec * 1/2 = 8ms + 1/240 sec<br><img src="Ex.png" alt=""></p></li></ul><h2>Disk Scheduling</h2><ul><li>Def: 指當有多個 access request, 在不同的 disk 之上, 則 Header 之移動服務順序為何</li><li><strong>策略採 &quot;Disk Scheduling algorithm&quot;</strong><ol><li><strong>FCFS (FIFO) (First Come First Service)</strong><ul><li>Ex: track 0~99, header = 15, access request - 81, 47, 90, 18, 5<br>Sol: <img src="FCFS.png" alt=""></li></ul></li><li><strong>SSTF (Shortest Seek Time First)(不見得為最佳解)</strong><ul><li>Ex: <img src="SSTF.png" alt=""></li></ul></li><li><strong>SCAN (掃描法)</strong>: 來回於兩端移動, 遇到 access request 即停下來服務之</li><li><strong>C-SCAN</strong> =&gt; 同 SCAN, 但 &quot;單向服務&quot;<ul><li>圖：<img src="C-SCAN.png" alt=""></li></ul></li><li><strong>LOOK</strong>: 跟 SCAN 相似, 但<strong>不見得碰底, 沒服務則往回走</strong><ul><li>較有效率, 但也就較複雜, 需額外空間處理</li><li>圖：<img src="LOOK.png" alt=""></li></ul></li><li><strong>C-LOOK</strong>: 同 LOOK, 但 &quot;單向服務&quot;<ul><li>圖：<img src="C-LOOK.png" alt=""></li></ul></li></ol></li></ul><h2>補充</h2><table><thead><tr><th>說明</th><th>傳統 (IDE, SCSI, SATA)</th><th>固態硬體 SSD(Solid State Drive)</th></tr></thead><tbody><tr><td>比較 1</td><td>Header 採機械式移動 =&gt; 慢 (seek 是 sequential)</td><td>採用 &quot;電子式&quot; =&gt; 快 (random access)</td></tr><tr><td>比較 2</td><td>抗震性差</td><td>抗震性佳 =&gt; 適用於行動裝置上</td></tr><tr><td>比較 3</td><td>成本低</td><td>成本高</td></tr><tr><td>比較 4</td><td>容量高</td><td>容量小</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.9 磁碟管理 (Disk Management)&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Free space management
&lt;ul&gt;
&lt;li&gt;Link list&lt;/li&gt;
&lt;li&gt;Combination&lt;/li&gt;
&lt;li&gt;Counting&lt;/li
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="Disk Management" scheme="https://pingjing0628.github.io/tags/Disk-Management/"/>
    
      <category term="Disk structure" scheme="https://pingjing0628.github.io/tags/Disk-structure/"/>
    
      <category term="Disk scheduling" scheme="https://pingjing0628.github.io/tags/Disk-scheduling/"/>
    
  </entry>
  
</feed>
