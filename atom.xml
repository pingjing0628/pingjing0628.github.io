<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PinJing&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pingjing0628.github.io/"/>
  <updated>2022-09-19T12:56:37.656Z</updated>
  <id>https://pingjing0628.github.io/</id>
  
  <author>
    <name>PinJing Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chapter6-資料結構-Array</title>
    <link href="https://pingjing0628.github.io/2022/09/18/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Array/"/>
    <id>https://pingjing0628.github.io/2022/09/18/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Array/</id>
    <published>2022-09-18T14:33:38.000Z</published>
    <updated>2022-09-19T12:56:37.656Z</updated>
    
    <content type="html"><![CDATA[<h1>6.1 Array</h1><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;6.1 Array&lt;/h1&gt;
&lt;hr&gt;

      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="資料結構" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"/>
    
    
      <category term="array" scheme="https://pingjing0628.github.io/tags/array/"/>
    
      <category term="對稱矩陣" scheme="https://pingjing0628.github.io/tags/%E5%B0%8D%E7%A8%B1%E7%9F%A9%E9%99%A3/"/>
    
  </entry>
  
  <entry>
    <title>Chapter6-資料結構-Algorithm&#39;s Time Complexity and Recursive Program</title>
    <link href="https://pingjing0628.github.io/2022/06/20/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Algorithm-s-Time-Complexity-and-Recursive-Program/"/>
    <id>https://pingjing0628.github.io/2022/06/20/Chapter6-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-Algorithm-s-Time-Complexity-and-Recursive-Program/</id>
    <published>2022-06-19T16:24:09.000Z</published>
    <updated>2022-09-19T12:56:33.371Z</updated>
    
    <content type="html"><![CDATA[<h1>6.1 Algorithm 的時間複雜度及遞迴程式</h1><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;6.1 Algorithm 的時間複雜度及遞迴程式&lt;/h1&gt;
&lt;hr&gt;

      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="資料結構" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"/>
    
    
      <category term="algorithm" scheme="https://pingjing0628.github.io/tags/algorithm/"/>
    
      <category term="漸進式表示法" scheme="https://pingjing0628.github.io/tags/%E6%BC%B8%E9%80%B2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    
      <category term="時間複雜度" scheme="https://pingjing0628.github.io/tags/%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6/"/>
    
      <category term="遞迴" scheme="https://pingjing0628.github.io/tags/%E9%81%9E%E8%BF%B4/"/>
    
      <category term="費氏數列" scheme="https://pingjing0628.github.io/tags/%E8%B2%BB%E6%B0%8F%E6%95%B8%E5%88%97/"/>
    
      <category term="Ackermans" scheme="https://pingjing0628.github.io/tags/Ackermans/"/>
    
      <category term="河內塔" scheme="https://pingjing0628.github.io/tags/%E6%B2%B3%E5%85%A7%E5%A1%94/"/>
    
      <category term="排列組合" scheme="https://pingjing0628.github.io/tags/%E6%8E%92%E5%88%97%E7%B5%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-JAVA</title>
    <link href="https://pingjing0628.github.io/2022/06/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-JAVA/"/>
    <id>https://pingjing0628.github.io/2022/06/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-JAVA/</id>
    <published>2022-06-19T16:16:31.000Z</published>
    <updated>2022-09-19T15:19:03.338Z</updated>
    
    <content type="html"><![CDATA[<h1>5.5 JAVA</h1><hr><h2>Java VS C++</h2><table><thead><tr><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>Pure O.O language, 因為主程式都在 class 中</td><td>較不 pure</td></tr><tr><td>No pointer</td><td>有 pointer</td></tr><tr><td>Single Inheritance</td><td>Multiple Inheritance</td></tr><tr><td><strong>利用 garbage collection</strong>, 不需有destructor</td><td><strong>沒有 garbage collection</strong>, 需有destructor</td></tr><tr><td>interpret language, speed 較慢</td><td>compile language, speed 較快</td></tr><tr><td>Cross platform</td><td>沒有跨平台</td></tr><tr><td>安全性佳, 因為JVM (有類別驗證器)</td><td>安全性較差</td></tr><tr><td>support open source 較多</td><td>較少</td></tr></tbody></table><blockquote><p>Garbage Collection(垃圾回收): 指不要的 Mem. 會由系統來進行自動回收的機制 =&gt; 回收 programmer 不需介入, 所以不須 destructorNote: java 中的 thread 的環境有較妥善的機制和方便 api 供 user 使用</p></blockquote><h2>Class 格式</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class class_name</span><br><span class="line">&#123;</span><br><span class="line">  constructor -&gt; object initial</span><br><span class="line">  att -&gt; 變數宣告</span><br><span class="line">  method -&gt; function define</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>Ex:</li></ul><h2>Constructor (建構子)</h2><ul><li>和 C++ 概念相似</li><li>O.O 中所有物件皆需 <strong>&quot;初始化&quot;</strong> =&gt; 一定要呼叫 constructor</li><li>當 class 無 constructor, 系統會補上 <strong>預設建構子</strong><ul><li>Default constructor:<ol><li>權限同 class</li><li>Parameter list 為空</li><li>Constructor code 為空</li></ol></li></ul></li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class A </span><br><span class="line">&#123;</span><br><span class="line">  public A () &#123;&#125; &#x2F;&#x2F; 自動補上 default constructor</span><br><span class="line">  &#x2F;&#x2F; public 1</span><br><span class="line">  &#x2F;&#x2F; () 2</span><br><span class="line">  &#x2F;&#x2F; &#123;&#125; 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>主程式</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">  public static void main(string [] args)</span><br><span class="line">  &#123;</span><br><span class="line">    ...  &#x2F;&#x2F;進入點</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">  public static void main() &#x2F;&#x2F; ()非主程式</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1. compile error</span><br><span class="line">2. runtime error</span><br><span class="line">3. No error</span><br><span class="line">Ans: 2</span><br><span class="line">出現 &quot;main method not found&quot;</span><br></pre></td></tr></table></figure></p><h2>配置物件 Mem.space =&gt; &quot;new&quot;</h2><ul><li>格式： <code>class object = new class 建構子 (...欲傳入的參數);</code></li><li>Ex:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person p &#x3D; new Person();</span><br><span class="line">&#x2F;&#x2F; new 正式做 Memory allocation</span><br><span class="line">&#x2F;&#x2F; Person() 呼叫 class Person 不帶參數的 constructor</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.height &#x3D; 180;</span><br><span class="line">&#x2F;&#x2F; in C ,Yes</span><br><span class="line">&#x2F;&#x2F; in Java , 尚未配置 Mem space</span><br></pre></td></tr></table></figure></li><li>Note: 物件操作方式同 C++, <code>object.att</code> or <code>object.op</code></li></ul><h2>Inheritance 繼承</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>downcasting 向下轉型</th><th>upcasting 向上轉型</th></tr></thead><tbody><tr><td>將父類別物件視為子類別型態</td><td>相反</td></tr><tr><td>有 risk, compiler 擋掉</td><td>沒有 risk</td></tr></tbody></table><ul><li>圖：</li><li>EX:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p &#x3D; new Superman(); &#x2F;&#x2F; superman upcasting</span><br><span class="line">Superman s &#x3D; new Person(); &#x2F;&#x2F; person downcasting</span><br><span class="line">Superman s &#x3D; new Xman(); &#x2F;&#x2F; X</span><br></pre></td></tr></table></figure></li></ul><h2>Overriding</h2><ul><li><p>子類別把父類別的函式重新定義<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public void iam()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;I am a Person&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Superman extends Person</span><br><span class="line">&#123;</span><br><span class="line">  public void iam()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;I am a Superman&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>注意：</p><ol><li><strong>method signature 方法簽章</strong> 要一樣</li></ol><ul><li>return type + method name + (parameter list)</li><li>Ex:<ul><li>superclass: double getValue()... <code>// compile error 多型會錯</code></li><li>subclass: string getValue()...</li></ul></li><li>Ex2:<ul><li>superclass: void print(int i)... <code>沒有 overriding 為 overloading, compile OK</code></li><li>subclass void print()...</li></ul></li></ul><ol start="2"><li>Subclass 的存取權限要 <strong>&gt;=</strong> superclass 的存取權限, 為避免多型有誤</li></ol><ul><li>Note: <code>public &gt; protected &gt; private</code></li></ul></li></ul><h2>this, super</h2><ul><li>概念同 C++, 但 <strong>Java 中 this, super 非 pointer</strong>, 其用法同一般物件, <code>this/super.att/method</code></li><li>圖：</li><li>Ex:</li></ul><h2>Constructor 的進一步介紹 (constructor 的延伸)</h2><ul><li><p>constructor 不會被繼承</p></li><li><p>在 inheritance之下, subclass 的 constructor 第一行需呼叫 &quot;super(...)&quot; (若無, 系統會自動加上&quot;super()&quot; 呼叫 parent, 不帶任何參數的 constructor) =&gt; 呼叫父類別的建構子產生 parent object</p></li><li><p>處理的順序(初始化時)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">  public A() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line">  public B() &#123;</span><br><span class="line">    super();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>常見陷阱題：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">  public A(int a)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A</span><br><span class="line">&#123;</span><br><span class="line">  public B() &#x2F;&#x2F; default constructor</span><br><span class="line">  &#123;</span><br><span class="line">    super(); &#x2F;&#x2F; 系統補上的, 找不到不帶參數的建構子</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Result: compile error</span><br></pre></td></tr></table></figure></p></li><li><p>Summary:</p><ol><li>No constructor =&gt; 補上 default constructor</li><li>若為 subclass 之 constructor 第一行無 &quot;super(...)&quot;, 自動補上 &quot;super(...)&quot; (不帶任何參數的)</li></ol></li><li><p>Ex:</p></li></ul><h2>Java 的例外處理 (Exception Handler)</h2><ul><li>於 Java 中採用 try...catch...finally 來做例外處理</li><li>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  &#x2F;&#x2F; 嘗試執行的動作</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">  &#x2F;&#x2F; 做例外捕捉後的 exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  &#x2F;&#x2F; 最後需執行的動作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>說明：<ol><li>try 一定存在, catch 跟 finally 至少需有1個</li><li>try 若遇到 Exception, 則之後的 statement 不做, 拋出 Exception object</li><li>catch 會捕捉 Exception, 並加以處理</li><li>try or catch 結束後, 會執行 finally block</li><li>若只有 try, finally , 當發生 exception 時, 會：</li><li>先執行 finally block</li><li>再將 Exception 往外拋</li></ol></li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">  exception occurs; &#x2F;&#x2F; 1</span><br><span class="line">  System.out.println(&quot;1&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123; &#x2F;&#x2F; 2 </span><br><span class="line">  System.out.println(&quot;2&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  System.out.println(&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Q1: output &#x3D; ? 2, 3</span><br><span class="line">&#x2F;&#x2F; Q2: 拿掉 1, output &#x3D; ? 1, 3</span><br><span class="line">&#x2F;&#x2F; Q3: 拿掉 2, output &#x3D; ? 3, runtime exception</span><br></pre></td></tr></table></figure></p><h2>array 初始化</h2><ul><li>in O.O 所有物件皆需 <strong>初始化</strong> (呼叫建構子)</li><li>in Java array 即為物件, 所以需初始化</li><li>不同型別的初始值<ul><li>基本型別: boolean, char, byte, int, long, short, float, double</li><li>物件型別: &quot;null&quot;</li></ul></li></ul><h2>Java 中的 array 宣告</h2><ul><li>type 陣列 name[] = new type [size];</li><li>ex: int a[] = new int[3];</li><li>ex1: double d() = new double[3];</li><li>主程式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s[] &#x3D; new String[3];</span><br><span class="line">s[s.length - 1] &#x3D; &quot;hello&quot;;</span><br><span class="line">System.out.println(&quot;s[1]&quot;);</span><br></pre></td></tr></table></figure></li><li>Note: 若為 &quot;基本型別&quot;, 且為 &quot;區域變數&quot;, 則：系統不會幫忙初始化, 需自行設預設值, <strong>若無則處理時會有compile error</strong></li><li>Ex:</li></ul><h2>static keyword</h2><blockquote><p>類別 -&gt; 靜態, 物件 -&gt; 動態</p></blockquote><ul><li><p>說明: static 修飾詞可用於 attribute, method 宣告中, 代表此 attribute, method 為 class 所有, 非 object 的</p></li><li><p>Note: data member 可分為:</p><ul><li>attribute:<ul><li>class variable (static)</li><li>instance variable (non-static)</li></ul></li><li>method<ul><li>class method (static)</li><li>instance method (non-static)</li></ul></li></ul></li><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">  public static int x;</span><br><span class="line">  public int y;</span><br><span class="line">&#125;</span><br><span class="line">A a1 &#x3D; new A();</span><br><span class="line">A a2 &#x3D; new A();</span><br></pre></td></tr></table></figure></p></li><li><p>成大: 一公司有員工的類別, 有下列屬性, 何者適合宣告為 static:</p><ol><li>姓名</li><li>手機</li><li>住址</li><li>配偶</li><li>CEO V</li></ol></li></ul><h2>static 注意事項</h2><ol><li>static method 只能存取 static 的 attribute 及 method, 無法用 Non-static 之 attribute 及 method</li></ol><ul><li><p>Ex1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先有類別, 才有物件</span><br><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">  public static int x;</span><br><span class="line">  public int y; &#x2F;&#x2F; non-static</span><br><span class="line">  public static void count()</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(x+y); &#x2F;&#x2F; y compile error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">  public void get X()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void get()</span><br><span class="line">  &#123;</span><br><span class="line">    get x(); &#x2F;&#x2F; compile error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><ol start="2"><li>static method 不可被 override (因為 static method 為靜態的, 故無法達多型(Dynamic Binding))之效)</li></ol><h2>final keyword</h2><p>可用來修飾:</p><ol><li>class: 代表此 class 不可再被<strong>繼承</strong></li></ol><ul><li>ex:<ul><li>父: <code>final class A {}</code></li><li>子: <code>calss B extends A{}</code> compile error</li></ul></li></ul><ol start="2"><li>method: 此 method 不可<strong>被 override</strong></li></ol><ul><li>ex:<ul><li>superclass: <code>public final void print() {}</code></li><li>subclass: <code>public void print(){}</code> compile error, 因為 final 不能被 override</li></ul></li></ul><ol start="3"><li>attribute: 代表此attribute 的值為 <strong>常數</strong></li></ol><ul><li>ex:<ul><li><code>public final int x = 10;.....x = 50;</code> compile error, 因為常數不能被更改</li></ul></li></ul><h2>polymorphism in Java</h2><ul><li>Java 的多型不需有 &quot;virtual&quot; 的 keyword, 因為在 java 中所有的 method 皆具 virtual function 功能, 不需額外宣告, 亦即 method 皆可達 Dynamic Binding 之效</li></ul><h2>Abstract method</h2><h2>Abstract class</h2><h2>interface</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.5 JAVA&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Java VS C++&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Java&lt;/th&gt;
&lt;th&gt;C++&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Pure O.O languag
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="建構子" scheme="https://pingjing0628.github.io/tags/%E5%BB%BA%E6%A7%8B%E5%AD%90/"/>
    
      <category term="Overriding" scheme="https://pingjing0628.github.io/tags/Overriding/"/>
    
      <category term="繼承" scheme="https://pingjing0628.github.io/tags/%E7%B9%BC%E6%89%BF/"/>
    
      <category term="多型" scheme="https://pingjing0628.github.io/tags/%E5%A4%9A%E5%9E%8B/"/>
    
      <category term="Interface" scheme="https://pingjing0628.github.io/tags/Interface/"/>
    
      <category term="Java" scheme="https://pingjing0628.github.io/tags/Java/"/>
    
      <category term="Exception" scheme="https://pingjing0628.github.io/tags/Exception/"/>
    
      <category term="Static" scheme="https://pingjing0628.github.io/tags/Static/"/>
    
      <category term="Final" scheme="https://pingjing0628.github.io/tags/Final/"/>
    
      <category term="Abstract" scheme="https://pingjing0628.github.io/tags/Abstract/"/>
    
      <category term="this" scheme="https://pingjing0628.github.io/tags/this/"/>
    
      <category term="super" scheme="https://pingjing0628.github.io/tags/super/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-C++程式語言介紹</title>
    <link href="https://pingjing0628.github.io/2022/06/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C-%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E4%BB%8B%E7%B4%B9/"/>
    <id>https://pingjing0628.github.io/2022/06/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C-%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E4%BB%8B%E7%B4%B9/</id>
    <published>2022-06-19T16:15:34.000Z</published>
    <updated>2022-09-19T12:56:16.348Z</updated>
    
    <content type="html"><![CDATA[<h1>5.4 C++ 程式語言介紹</h1><hr><h2>C++ Language</h2><p>Class:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式: class class_name</span><br><span class="line">&#123;</span><br><span class="line">    Constructor &#x2F;&#x2F; 建構子</span><br><span class="line">    Destructor &#x2F;&#x2F; 解構子</span><br><span class="line">    Attribute &#x2F;&#x2F; 變數宣告</span><br><span class="line">    Operation &#x2F;&#x2F; 函式定義</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2>Object 宣告, 操作</h2><p><code>class _ object;</code><br>操作：<br>object.att.<br>object.op.</p><ul><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    Person P;</span><br><span class="line">    p.height &#x3D; 180;</span><br><span class="line">    p.weight &#x3D; 80;</span><br><span class="line">    p.walk(); &#x2F;&#x2F; 印出 &quot;Person walk&quot;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2>建構子 (Construtor)</h2><ul><li>Def:<ul><li>對 object 做 <strong>初始化</strong> 的動作</li><li>於 object 產生時呼叫</li><li>Constructor name 和 <strong>class name 相同, 且 No return type</strong></li><li>Constructor 可有很多個</li></ul></li><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public:</span><br><span class="line">    &#x2F;&#x2F;建構子</span><br><span class="line">    A() &#123;</span><br><span class="line">        cout &lt;&lt;&quot;con.A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;解構子</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        cout &lt;&lt;&quot;del.A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2>解構子 (Destructor)</h2><ul><li>Def:<ul><li>於 constructor 之前加上 <strong>&quot;~&quot;</strong></li><li>Destructor <strong>不接收參數</strong> parameter list 為空</li><li>class 中 destructor <strong>只會有一個</strong></li><li>於 object 被回收時呼叫<br><img src="%E8%A7%A3%E6%A7%8B%E5%AD%90.png" alt=""></li></ul></li><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    public: </span><br><span class="line">    A() &#123;</span><br><span class="line">        cout &lt;&lt;&quot;con.A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        cout &lt;&lt;&quot;del.A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    A a1; a1 屬於 A</span><br><span class="line">    A a2;</span><br><span class="line">    return 0;</span><br><span class="line">&#125; &#x2F;&#x2F; 結束前呼叫解構子 output?</span><br></pre></td></tr></table></figure></li></ul><h2>變數種類</h2><p>格式：<code>static _ type _ variable;</code><br><code>static int x;</code></p><ul><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    fun();</span><br><span class="line">    fun();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void fun() &#123;</span><br><span class="line">    static int i &#x3D; 20;</span><br><span class="line">    i++;</span><br><span class="line">    cout &lt;&lt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Note:</p><ul><li>靜態變數存於靜態區塊中, <strong>&quot;不會隨著所屬 block 結束而回收&quot;</strong>, 於程式結束回收</li><li>靜態變數之宣告只於第一次執行, 之後忽略之</li></ul></li><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public:</span><br><span class="line">    int oid; &#x2F;&#x2F; att</span><br><span class="line">    &#x2F;&#x2F; 建構子</span><br><span class="line">    A(int i) &#123;</span><br><span class="line">        oid &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;解構子</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        cout &lt;&lt;oid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int main() &#123;</span><br><span class="line">        A a1(1); &#x2F;&#x2F; 給建構子的參數</span><br><span class="line">        fun();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    void fun() &#123;</span><br><span class="line">        A a2(2);</span><br><span class="line">        static A a3(3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li></ul><p>問 output is?<br><img src="%E8%AE%8A%E6%95%B8%E7%A8%AE%E9%A1%9EEX1.png" alt=""></p><h2>C++ 參考變數 Reference Variable</h2><p>格式：<br><code>type **&amp;**var = **被參考變數** (不可省略)</code><br><code>int &amp;count = x;</code> -&gt; 替 x 取別名叫 count</p><blockquote><p>注意事項：</p><ol><li>int count; (X) 替某人取綽號叫 count, 但某人不存在</li><li>int &amp;count = 3; (X) 常數(No mem space)</li></ol></blockquote><h3>宣告時</h3><p><code>int x;</code> <strong>=&gt; call by value</strong> (一般)<br><code>int *x;</code> <strong>=&gt; call by address</strong> (指標)<br><code>int &amp;x;</code> <strong>=&gt; call by reference</strong> (參數)</p><h3>操作時</h3><p><code>x</code><strong>=&gt; 取內容</strong><br><code>*x</code><strong>=&gt; 取指標指向的值</strong><br><code>&amp;x</code><strong>=&gt; 取所在 address</strong></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    cout &lt;&lt;a&lt;&lt;b;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int x, int y) &#123;</span><br><span class="line">    int &amp;x &#x3D; a;</span><br><span class="line">    int temp;</span><br><span class="line">    temp &#x3D; x;</span><br><span class="line">    x &#x3D; y;</span><br><span class="line">    y &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Q:<br>1. a, b 呼叫 swap 後為何 No change? (call - by value)<br>2. How to modifiy?</p><h2>C++ 的 Inheritance</h2><p><img src="%E7%B9%BC%E6%89%BF.png" alt=""></p><ul><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public: &#x2F;&#x2F; 若改為 private, 此時 B會有 compile error</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line">class B: Public A &#123; &#x2F;&#x2F;: 繼承</span><br><span class="line">    public:</span><br><span class="line">    B (inta, int b) &#123;</span><br><span class="line">        x &#x3D; a;</span><br><span class="line">        y &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    void print() &#123;</span><br><span class="line">        cout &lt;&lt;x&lt;&lt;y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    B objB(2, 5);</span><br><span class="line">    objB.print();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>補充：繼承的存取權限<img src="%E8%A3%9C%E5%85%85%E7%B9%BC%E6%89%BF.png" alt=""></p></blockquote><h2>Overriding 覆載</h2><ul><li>子類別將父類別的<strong>函式重新定義</strong>以符合自身所需<br><img src="%E8%A6%86%E8%BC%89.png" alt=""></li></ul><h2>Overloading 多載</h2><p>分為：</p><ol><li>function overloading<ol><li>藉由接收多數串列的<strong>數量</strong>或<strong>型別不同</strong>以達到共用相同的函式名稱<ul><li><p>Ex1:</p><ul><li>對 user 而言較方便, 不需記過多的 function name</li><li>對 programmer 而言命名 function 亦可簡化其原則<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(2); -&gt; void print(int i)</span><br><span class="line">print(3.5); -&gt; void print(double d)</span><br><span class="line">print(&quot;abc&quot;); -&gt; void print(char *s)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    public:</span><br><span class="line">    Person() &#123;...&#125;            &#x2F;&#x2F; 建構子</span><br><span class="line">    Person(int h) &#123;...&#125;       &#x2F;&#x2F; 建構子</span><br><span class="line">    Person(inth, int w) &#123;...&#125; &#x2F;&#x2F; 建構子  Overloading</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul></li></ol></li></ol><ol start="2"><li>operator overloading<ul><li>Def: 藉由接收的運算元型別不同, 以達<strong>共用相同的運算子(operator)符號</strong></li><li>概念：<ul><li>3 + 5 =&gt; int + int</li><li>2.3 + 5.5 =&gt; double + double</li><li>matrix + matrix</li></ul></li></ul></li></ol><h2>this vs super</h2><ul><li>為 C++ 內建提供的物件指標</li><li>其中：<ul><li>this 會指向物件本身</li><li>super 會指向物件的 parent class</li></ul></li><li>說明：<br><img src="this&amp;super.png" alt=""></li></ul><h2>物件指標</h2><ol><li>物件指標指向 attribute or operator<br>ex: this -&gt; i;</li><li>(*物件指標).attribute or operator<br>ex: (*this).i;</li></ol><ul><li>Ex: this.i ... 錯誤 (成大)<br>因為 <strong>&quot;.&quot;</strong> priority &gt; <em><em>&quot;</em>&quot;</em>*<br>所以 括號不能拿掉<br><code>(*(&amp;(*this))).i; = (*this).i</code><ul><li>為從 address 拿回值<br>&amp; 為拿出 address</li></ul></li></ul><p><img src="%E7%89%A9%E4%BB%B6%E6%8C%87%E6%A8%99.png" alt=""></p><ul><li>EX:<br><img src="%E7%89%A9%E4%BB%B6%E6%8C%87%E6%A8%99Ex1.png" alt=""></li><li>EX2 (政大):<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void A(int V1, int V2)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; V2, V2 &#x3D; V1 - 3, V1 &#x3D; t + 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pA(int *V1, int *V2)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; *V2;</span><br><span class="line">    *V2 &#x3D; *V1 + 2;</span><br><span class="line">    *V1 &#x3D; t - 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rA(int &amp;V1, int &amp;V2)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; V2;</span><br><span class="line">    V2 &#x3D; V1 + 4;</span><br><span class="line">    V1 &#x3D; t - 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i &#x3D; 1, j &#x3D; 2;</span><br><span class="line">    cout &lt;&lt;i&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    A(i, j);      &#x2F;&#x2F; call-by value</span><br><span class="line">    cout &lt;&lt;i&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    pA(&amp;i, &amp;i);   &#x2F;&#x2F; call-by address</span><br><span class="line">    cout &lt;&lt;i&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    rA(i, j);     &#x2F;&#x2F; call-by reference (取綽號, c++ 獨有)</span><br><span class="line">    cout &lt;&lt;i&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Ans: </span><br><span class="line">&#x2F;&#x2F; 1 2 </span><br><span class="line">&#x2F;&#x2F; 1 2</span><br><span class="line">&#x2F;&#x2F; -2 3</span><br><span class="line">&#x2F;&#x2F; -2 2</span><br></pre></td></tr></table></figure><img src="%E6%8C%87%E6%A8%99Ex.png" alt=""></li></ul><h2>Polymorphism 多型</h2><ul><li>Def :<ul><li>多型主要是於<strong>執行時期</strong>利用<strong>動態繫結</strong>的方式來呼叫需執行的 function =&gt; <strong>執行時才動態決定</strong></li><li>C++ 中一般的函式呼叫於 compile time (state binding)已決定, 其呼叫位址 =&gt; <strong>故無法達到多型</strong></li><li>在 C++ 中多加入一keyword <strong>virtual</strong> 來註明函式為 virtual function =&gt; <strong>已達多型之效</strong></li></ul></li><li>圖：<br><img src="%E5%A4%9A%E5%9E%8B.png" alt=""></li></ul><ol><li>利用父類別型態 <strong>(須為指標或參數, 不能為一般變數)</strong></li><li>接收不同子類別的物件</li><li>做相同的動作</li><li>引發不同的行為(同名異式)</li></ol><ul><li><p>Ex1:</p></li><li><p>NOTE: Polymorphism =&gt; Inheritance(:) + Overriding + Virtual function<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Virtual 一抽掉, 就永遠印出 An.walk</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void walk()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;An.walk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Person:public Animal</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void walk()  &#x2F;&#x2F; 子類別的 virtual 可省略</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Person walk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog: public Animal</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void walk()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Dog walk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    &#x2F;&#x2F; 一定要指標或參考</span><br><span class="line">    Animzl *aPtr &#x3D; 0; &#x2F;&#x2F; 一開始是 0</span><br><span class="line">    Person p;</span><br><span class="line">    aPtr &#x3D; &amp;p;  &#x2F;&#x2F; 指標接收住址</span><br><span class="line">    aPtr-&gt; walk(); &#x2F;&#x2F; &quot;Person&quot; walk</span><br><span class="line">    Dog d;</span><br><span class="line">    aPtr &#x3D; &amp;d;</span><br><span class="line">    aPtr -&gt; walk(); &#x2F;&#x2F; &quot;dog&quot; walk</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2: 政大<br><img src="%E5%A4%9A%E5%9E%8BEx1.png" alt=""><img src="%E5%A4%9A%E5%9E%8BEx2.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">    public: </span><br><span class="line">    virtual void iam()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Base \n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>問：</p></li></ul><ol><li>Derive two class from Base(繼承), and for each define iam() to write out the name of the class (override).<br>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class D1: public Base</span><br><span class="line">&#123;</span><br><span class="line">    public: </span><br><span class="line">    virtual void iam()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;D1 \n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D2: public Base</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void iam()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;D2 \n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>Create objects of these classes(物件宣告), and call iam() for them(物件操作).<br>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    D1 d1;</span><br><span class="line">    D2 d2;</span><br><span class="line">    b.iam();</span><br><span class="line">    d1.iam();</span><br><span class="line">    d2.iam();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Assign pointers to objects of the derived class to Base *pointers and call iam() through those pointers.<br>Sol:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *b1, *b2;</span><br><span class="line">    D1 d1;</span><br><span class="line">    b1 &#x3D; &amp;d1;</span><br><span class="line">    b1 -&gt; iam(); &#x2F;&#x2F; 印出 &quot;D1&quot;</span><br><span class="line">    D2 d2;</span><br><span class="line">    b2 &#x3D; &amp;d2;</span><br><span class="line">    b2 -&gt; iam(); &#x2F;&#x2F; 印出 &quot;D2&quot;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.4 C++ 程式語言介紹&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;C++ Language&lt;/h2&gt;
&lt;p&gt;Class:
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="C++" scheme="https://pingjing0628.github.io/tags/C/"/>
    
      <category term="建構子" scheme="https://pingjing0628.github.io/tags/%E5%BB%BA%E6%A7%8B%E5%AD%90/"/>
    
      <category term="解構子" scheme="https://pingjing0628.github.io/tags/%E8%A7%A3%E6%A7%8B%E5%AD%90/"/>
    
      <category term="Overriding" scheme="https://pingjing0628.github.io/tags/Overriding/"/>
    
      <category term="Overloading" scheme="https://pingjing0628.github.io/tags/Overloading/"/>
    
      <category term="物件指標" scheme="https://pingjing0628.github.io/tags/%E7%89%A9%E4%BB%B6%E6%8C%87%E6%A8%99/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-物件導向概論</title>
    <link href="https://pingjing0628.github.io/2022/04/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E6%A6%82%E8%AB%96/"/>
    <id>https://pingjing0628.github.io/2022/04/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E6%A6%82%E8%AB%96/</id>
    <published>2022-04-20T15:00:18.000Z</published>
    <updated>2022-09-19T12:56:04.088Z</updated>
    
    <content type="html"><![CDATA[<h1>5.3 物件導向概論</h1><hr><h2>Object Oriented:</h2><p>int x; (type 變數)<br>person P; (類別 物件)</p><ul><li>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person p;</span><br><span class="line">p.h &#x3D; 180</span><br><span class="line">p.w &#x3D; 80;</span><br><span class="line">p.walk();</span><br></pre></td></tr></table></figure></li></ul><h3>why O.O</h3><ul><li>可用以反應出真實世界的情況, 使程式的可讀性更佳, 日後的可維護性亦更好</li><li><strong>彈性好, 但 performance 差</strong></li></ul><h2>物件(object)</h2><ul><li>Def:<ul><li>an object is an instance of a class =&gt; 指物件為類別的實體</li><li>each object 是獨立的, 滿足唯一性(unique)</li></ul></li><li>就程式而言物件是<ol><li>參與程式執行的單位</li><li>為一變數會佔用 Mem.space</li><li><strong>dynamic</strong>: 指會隨執行而更動其狀態</li></ol></li></ul><h2>類別(class)</h2><ul><li>Def:<ul><li>將具相同屬性及行為的 object 加以抽象化定義</li></ul></li><li>其中：<ul><li>attribute: 靜態描述(特徵值), height, weight, 單眼皮, 雙眼皮</li><li>behavior(operation in c++, method in java): 動態描述 =&gt; 作用在屬性上</li></ul></li><li>就程式而言類別是：<ul><li>ADT (Abstract Data Type)</li><li>為靜態單位, 只佔用一份 Mem. space</li><li>為物件的實施藍圖</li></ul></li><li>概念：<ul><li>圖：<img src="%E5%80%9F%E6%9B%B8.png" alt=""></li><li>Note: Object 之間溝通採用 <strong>&quot;Message Passing&quot;</strong> (因為物件間是獨立的, 無共享Mem.)</li></ul></li></ul><h2>Object Oriented 四大特色</h2><ol><li>Data Abstraction 資料抽象化<ul><li>將物件細節排除, 擷取共通的 attribute 及 operation, 加以抽象化定義</li><li>在定義(抽象化)過程, 會忽略和問題無關的部分</li></ul></li><li>Encapsulation 封裝<ul><li>Def:<ul><li>可將 class 中部分的 attribute 及 operation 隱藏, 避免外界直接取用</li><li>一般會用一公開的管道使外界可做間接存取, 以便管控正確性</li></ul></li><li>優點：<ol><li>確保私有 data 不受外界影響 =&gt; 可避免不當操作發生, 如 ....heart</li><li>適時將製作的細節封裝, 如此可在改變時, 減少對外操作的影響 =&gt; ripple effect 低, 可維護性高(如程式碼2)</li></ol></li></ul></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person                   外界</span><br><span class="line">setHeight(int h)         height &#x3D; -30; (Can&#39;t use)</span><br><span class="line">&#123;                        setHeight(-30);</span><br><span class="line">    if (h &lt; 0) error;</span><br><span class="line">    height &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;今日有一客戶需一排序程式</span><br><span class="line">BubbleSort(data) &#123;</span><br><span class="line">    ...             &#x2F;&#x2F;但由於資料愈來愈多嫌太慢</span><br><span class="line">&#125;</span><br><span class="line">QuickSort(data) &#123;</span><br><span class="line">    ...             &#x2F;&#x2F;卻發現舊系統中都是 bubble sort, 無法執行 quick sort</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所以當初應</span><br><span class="line">Sort(data) &#123;</span><br><span class="line">    BubbleSort(data) &#x2F;&#x2F; 改成</span><br><span class="line">    QuickSort(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>Inheritance 繼承<ul><li>Def:<ul><li>子類別(Child class) 可以繼承 父類別 (parent class) 的屬性及運作, 亦可加入 child class 自訂的屬性及運作</li></ul></li><li>圖：<br><img src="%E7%B9%BC%E6%89%BF1.png" alt=""></li><li>優點：<ol><li>支援 software reuse (軟體再利用) =&gt; <strong>省下重複開發成本</strong></li><li>支援 component base software developments (以元件為基礎的軟體開發方式) =&gt; VB , 品質好, 速度快</li></ol></li><li>缺點：<ol><li>當繼承深且複雜的時候, 會使 compiler 的 performance 下降, 耗費時間去找尋各 data 的來源<br><img src="%E7%B9%BC%E6%89%BF.png" alt=""></li><li>readable 及 maintainable 的程度下降, 因為太多層, 所以視窗太多, 要找時也困難</li><li>有 Naming Conflicting 的議題(命名衝突), 又稱 &quot;ambiguous calling&quot; (模糊呼叫)<br><img src="%E5%91%BD%E5%90%8D%E8%A1%9D%E7%AA%81.png" alt=""></li><li>重複繼承的問題<br><img src="%E9%87%8D%E8%A4%87%E7%B9%BC%E6%89%BF.png" alt=""></li></ol></li></ul></li></ol><blockquote><p>補充 Encapsulation 存取權限：<br><img src="%E5%B0%81%E8%A3%9D%E5%AD%98%E5%8F%96%E6%AC%8A%E9%99%90.png" alt=""><br>Note:</p><ol><li>在 c++中額外提供 &quot;friendly&quot; 權限, 當 class A, B 2者設為 friend, 即可取用之</li><li>在 java 中若沒宣稱權限, 則為 default 權限, <strong>此時只有 class 本身及同 package(類似目錄的概念) 下方可使用</strong></li></ol></blockquote><ol start="4"><li>Polymorphism 多型<ul><li>Def: O.O 程式於 &quot;執行期間&quot; (Runtime 才決定呼叫的 function 之所在 -&gt; Dynamic Binding), 不同型別之物件, 接收到同一訊息 <strong>(同名)</strong>, 會有不同的行為 <strong>(異式)</strong>, 反應謂之「多型」</li><li>Note: binding<br><img src="%E5%A4%9A%E5%9E%8B2.png" alt=""></li><li>Ex:<br><img src="%E5%A4%9A%E5%9E%8B1.png" alt=""></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.3 物件導向概論&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Object Oriented:&lt;/h2&gt;
&lt;p&gt;int x; (type 變數)&lt;br&gt;
person P; (類別 物件)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ex:&lt;br&gt;
&lt;figure class=&quot;highlight p
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="物件導向" scheme="https://pingjing0628.github.io/tags/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91/"/>
    
      <category term="繼承" scheme="https://pingjing0628.github.io/tags/%E7%B9%BC%E6%89%BF/"/>
    
      <category term="多型" scheme="https://pingjing0628.github.io/tags/%E5%A4%9A%E5%9E%8B/"/>
    
      <category term="封裝" scheme="https://pingjing0628.github.io/tags/%E5%B0%81%E8%A3%9D/"/>
    
      <category term="抽象" scheme="https://pingjing0628.github.io/tags/%E6%8A%BD%E8%B1%A1/"/>
    
      <category term="類別" scheme="https://pingjing0628.github.io/tags/%E9%A1%9E%E5%88%A5/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-C語言重點</title>
    <link href="https://pingjing0628.github.io/2021/07/08/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C%E8%AA%9E%E8%A8%80%E9%87%8D%E9%BB%9E/"/>
    <id>https://pingjing0628.github.io/2021/07/08/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C%E8%AA%9E%E8%A8%80%E9%87%8D%E9%BB%9E/</id>
    <published>2021-07-08T09:10:18.000Z</published>
    <updated>2022-09-19T12:56:14.068Z</updated>
    
    <content type="html"><![CDATA[<h1>5.2 C 語言重點</h1><hr><h2>C Language</h2><ul><li>結構<ul><li>xxx.c</li><li>header: 表頭</li><li>body: object code</li></ul></li><li>Ex:<code># include &lt;stdio.h&gt;</code> =&gt; stdio.h 為 linker, 外部函式庫之 header file</li></ul><h2>變數 vs 常數</h2><table><thead><tr><th>Variable</th><th>Constant</th></tr></thead><tbody><tr><td>會隨著執行而更動的數值</td><td>不變</td></tr><tr><td>佔用 memory space 來存取</td><td>不需</td></tr><tr><td>int x;</td><td>ex: 'a' or 100</td></tr></tbody></table><ul><li>Note: 常數變數 (constant variable)<br>Define: <code>const int x = 10;</code></li></ul><h2>變數宣告</h2><p>格式： <code>type (space) variable;</code><br>ex: int x;</p><h2>Compare Static typed and Dynamic typed</h2><table><thead><tr><th>Static typed</th><th>Dynamic typed</th></tr></thead><tbody><tr><td>宣告時, 即需決定 data 之型態</td><td>不需, runtime 才決定</td></tr><tr><td>int x;</td><td>var x; x = 100;</td></tr><tr><td>java, C, C++</td><td>javascript, ruby</td></tr></tbody></table><h2>常見的 data type 介紹</h2><ol><li>boolean (布林):</li></ol><ul><li>只有兩種狀態:<ul><li>true</li><li>false</li></ul></li><li>Ex: <code>bool flag;</code></li></ul><ol start="2"><li>character (字元):</li></ol><ul><li>利用 &quot;ASCII&quot; 來存放</li><li>佔用 1 byte memory space</li><li>常見字元編碼<ul><li>'0' =&gt; (48)10</li><li>'A' =&gt; (65)10</li><li>'a' =&gt; (97)10</li></ul></li><li>Ex: <code>char c1;</code></li><li>Note:</li></ul><table><thead><tr><th>character</th><th>string</th></tr></thead><tbody><tr><td>由一字母或數字組成</td><td>由 1~多個組成</td></tr><tr><td>用單引號括住</td><td>用雙引號括住</td></tr><tr><td>'a', 'B'(對), &quot;B&quot;(錯)</td><td>&quot;hello&quot;(對), 'hello'(錯)</td></tr></tbody></table><ol start="3"><li>integer (整數):</li></ol><ul><li>利用 4 bytes 表示</li><li>Ex: <code>int x;</code></li><li>除法:<ul><li>&quot;/&quot; =&gt; 取商, <code>x = 6/4</code></li><li>&quot;%&quot; =&gt; 取餘, <code>y = 6%4</code></li></ul></li><li>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">char a1 &#x3D; &#39;a&#39;;</span><br><span class="line">x &#x3D; a1;</span><br><span class="line">a1 &#x3D; a1 + 3;</span><br><span class="line">printf(&quot;%d&quot;, x); &#x2F;&#x2F; x &#x3D; 97</span><br><span class="line">printf(&quot;%c&quot;, a1); &#x2F;&#x2F; a1 &#x3D; 100</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>浮點數:</li></ol><table><thead><tr><th>float</th><th>double</th></tr></thead><tbody><tr><td>single precision</td><td>double precision</td></tr><tr><td>32 bits, 佔用 4 bytes</td><td>使用 8 bytes</td></tr><tr><td>float f;</td><td>double d;</td></tr></tbody></table><ul><li>ex:<ol><li><code>float f1 = 3.2/4;</code> =&gt; 0.8</li><li><code>float f2 = 5/4;</code> =&gt; 1.0</li><li><code>float f3 = 5.0/4;</code> =&gt; 1.25</li><li><code>float f4 = (float)5/4;</code> =&gt; 1.25 =&gt; 強制將 5 視為浮點數, <strong>強制轉型 casting</strong></li></ol></li><li>Note:<ol><li>在 c, c++中, 運算是會以最大型別來求得結果<ul><li>ex: int(隱含轉型 -&gt; double) * double + float = ? =&gt; output <strong>double</strong></li></ul></li><li>浮點數, 預設為 <strong>double</strong> 之型態 (因為失真少, 結尾誤差少)<ul><li>ex: 3.14 * 2.56 + 3.2 =&gt; double</li></ul></li></ol></li></ul><blockquote><p>NOTE: type range =&gt; byte &lt; short &lt; int &lt; long &lt; float &lt; double</p></blockquote><h2>變數種類</h2><table><thead><tr><th>local variable</th><th>global variable</th></tr></thead><tbody><tr><td>於 block 或 函式之中宣告</td><td>於 block 或 函式之外宣告</td></tr><tr><td>僅能在所屬的 block 之內使用</td><td>全部block都可用</td></tr><tr><td>於 block 一結束, 即清除</td><td>整個程式結束才清除</td></tr></tbody></table><ul><li>static variable</li></ul><h2>變數的存取順序</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">全域變數</span><br><span class="line">3.&#123;</span><br><span class="line">    2.&#123;</span><br><span class="line">        1.&#123;</span><br><span class="line">            print(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>先找自身區塊</li><li>若 1 無, 往外層找</li><li>若 2 無, 往 global 找</li></ol><ul><li><p>Note: dynamic scoping =&gt; 依程式執行時的呼叫順序 (runtime) 來決定找尋順序, <code>main() -&gt; A() -&gt; B()</code> =&gt; 找B找不到, 找A, 在找不到找 main</p></li><li><p>Ex1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 10; &#x2F;&#x2F;global</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    int y &#x3D; 5;</span><br><span class="line">    &#123;</span><br><span class="line">        int x &#x3D; 20;</span><br><span class="line">        int z &#x3D; 8;</span><br><span class="line">        printf(&quot;%d&quot;, x); &#x2F;&#x2F; x&#x3D;20, 用完即清除</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, x); &#x2F;&#x2F; x&#x3D;10</span><br><span class="line">    printf(&quot;%d&quot;, z); &#x2F;&#x2F; compile error</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 20;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int y &#x3D; 10;</span><br><span class="line">    fun(y);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">void fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int y &#x3D; 30;</span><br><span class="line">    printf(&quot;%d, %d&quot;, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Ans: (20, 30)</p></li><li><p>Note: 在 C 語言裡, 只要不是指標, 就是 call by-value</p></li><li><p>local variable =&gt; 與 function 一樣, 用 stack 放 =&gt; 後進先出</p></li></ul><h2>Standard I/O library 標準輸出/輸入函式庫</h2><h3>程式欲使用須引入： <code>#include &lt;stdio.h&gt;</code></h3><h3>常用函式：</h3><ol><li><p><code>printf</code> =&gt; 標準輸出<br>格式： <code>printf(&quot;格式字串&quot;, var1, var2...);</code><br>Note:</p><ol><li>var 可省略</li><li>若有 var, 需在格式字串中, 有對應的 <strong>格式碼</strong></li></ol><blockquote><p>格式碼：<br>%d 整數<br>%f 浮點數<br>%c 字元<br>%s 字串</p></blockquote><p>EX:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;hello&quot;);</span><br><span class="line">int x;</span><br><span class="line">printf(&quot;x is %d&quot;, x);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; x is 100</span><br></pre></td></tr></table></figure></p></li><li><p><code>scanf</code> =&gt; 標準輸入<br>從外界 key in 值, 接收到程式<br>格式： <code>scanf(&quot;格式字串&quot;, &amp;var1, &amp;var2...); // &amp;位址</code><br>Note: 格式碼與 <code>printf</code> 相同<br>EX:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">scanf(&quot;input: %d&quot;, &amp;x);</span><br></pre></td></tr></table></figure></p><p>EX:<br><code>Sum = 1+2+3+4...+N</code>, N 為輸入值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    int N, sum &#x3D; 0, i;</span><br><span class="line">    scanf(&quot;input: %d&quot;, &amp;N);</span><br><span class="line">    for(i &#x3D; 1; i &lt;&#x3D; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum &#x3D; sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;total:%d&quot;, sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2>運算子</h2><table><thead><tr><th>Operator</th><th>Priority</th><th>Associative</th></tr></thead><tbody><tr><td>(), []</td><td><strong>高</strong></td><td>右結合</td></tr><tr><td>!, ~, -(負), ++, --</td><td></td><td>左結合</td></tr><tr><td>*, /, +, - (<strong>算數1</strong>)</td><td></td><td>左結合</td></tr><tr><td>&lt;&lt;, &gt;&gt;</td><td></td><td>左結合</td></tr><tr><td>&lt;, &gt;,&lt;=, &gt;= (<strong>關係2</strong>)</td><td></td><td>左結合</td></tr><tr><td>位元 (<strong>3</strong>)</td><td></td><td>左結合</td></tr><tr><td>logical (<strong>4</strong>)</td><td></td><td>左結合</td></tr><tr><td>= (assign)</td><td><strong>低</strong></td><td>右結合</td></tr></tbody></table><ul><li>Note:<ol><li><p>1&gt;2&gt;3&gt;4</p></li><li><p>多個 operator 之運算, 先看 priority, 若相同在看 associate</p></li><li><p>Associative 分為：</p><ul><li>左結合 ((3+5)+8)</li><li>右結合 (3+(5+8))</li></ul></li><li><p>operator 分為：</p><ol><li>unary operator (單元)<br>ex: -5, !flag</li><li>binary operator (二元)<br>ex: 3+5, 6-4, 7*8</li><li>trinary operator (三元)<br><code>條件式 ? x : y</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (條件式)</span><br><span class="line">&#123;</span><br><span class="line">    x</span><br><span class="line">&#125; else </span><br><span class="line">&#123;</span><br><span class="line">    y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>=</strong>: assign , <strong>==</strong>: equals</p></li></ol></li></ul><h2>++, --</h2><table><thead><tr><th>前置式</th><th>後置式</th></tr></thead><tbody><tr><td>先做++, --, 再取值</td><td>先取值, 再做++, --</td></tr><tr><td>++x, --x</td><td>x++, x--</td></tr></tbody></table><ul><li><p>Ex1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 5, y&#x3D;5;</span><br><span class="line">int A, B;</span><br><span class="line">A &#x3D; x++;</span><br><span class="line">B &#x3D; ++y;</span><br><span class="line">print(A, B, x, y);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5, 6, 6, 6</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2:<br><code>a = 3, b = 6</code>, 則 <code>39/-++a+-20%b--</code><br>Sol:<br><code>39/(-4)+(-29)%6</code> = <code>-9 + (-5)</code> = <code>-14</code></p></li></ul><h2>位元運算</h2><ul><li>概念：先將資料化成 2 進制, 再開始進行運算</li></ul><ol><li>AND (&amp;)</li><li>OR (|)</li><li>XOR (^)</li><li>&lt;&lt;</li><li>&quot;&gt;&gt;&quot;</li></ol><ul><li>EX1:  <code>int x = 8 &amp; 6;</code>, <code>(0 0 0 0)2 = 0</code>, 同時為 1 才成立, <strong>像 (．)</strong></li><li>EX2: <code>int x = 8 | 6;</code>, <code>(1 1 1 0)2 = 14</code>, <strong>像 (+)</strong></li><li>EX3: <code>int x = 8 ^ 6;</code>, <code>(1 1 1 0 )2 = 14</code>, <strong>相同為 0, 相異為 1</strong></li><li>EX4: &lt;&lt; 左移, <code>x &lt;&lt; n</code> =&gt; 將 x 左移 n 個 bits,<br>作法：在右邊加上 n 個 0 (具備 <strong>乘法</strong> 效果)<br>例如：<code>int x = 8 &lt;&lt; 2;</code>, (1000<strong>00</strong>)2 = 32</li><li>EX5: &gt;&gt; 右移, <code>x &gt;&gt; n</code> =&gt; 將 x 右移 n 個 bits,<br>作法：<ul><li>step1 =&gt; 將右邊<strong>砍掉</strong> n 個 bits <strong>維持 sign bit</strong></li><li>step2 =&gt; 在左邊補上<ol><li>正 =&gt; 0 (n 個)</li><li>負 =&gt; 1 (n 個)<br>（具備 <strong>除法</strong> 效果)例如：<code>int x = 8 &gt;&gt; 2;</code>, (<strong>00</strong>1000)2 = 2</li></ol></li></ul></li></ul><h2>Logical</h2><h3>NOT (!)</h3><ul><li>false -&gt; true</li><li>true -&gt; false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool flag &#x3D; true;</span><br><span class="line">&#x3D;&gt; !flag &#x3D;&gt; false</span><br></pre></td></tr></table></figure></li></ul><h3>AND (&amp;&amp;) and OR (||)</h3><ul><li><strong>布林運算式最佳化</strong>  =&gt; <strong>短路現象</strong> =&gt; <strong>shortcut 捷徑運算</strong></li><li>A, B 均為 conditional (條件式)<br><code>if(A &amp;&amp; B)</code>, A = false, B 不做, 結果必為 false<br><code>if(A || B)</code>, A = true, B 不做, 結果必為 true</li></ul><h2>if - else</h2><ul><li><p>格式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (cond 1) &#123;</span><br><span class="line">    true (2)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    false (3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>1 ? 2 : 3</p></li><li><p>格式二：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (cond) &#123;</span><br><span class="line">    true 1</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    if (cond) &#123;</span><br><span class="line">        true 2</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        false 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">if (cond) &#123;</span><br><span class="line">    1</span><br><span class="line">&#125;else if (cond) &#123;</span><br><span class="line">    2</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Note: 當 if ... else 沒有 block 時, 則只會影響到下一個 statement (敘述)</p></li><li><p>ex1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 1;</span><br><span class="line">if (x &lt; 5) &#123;</span><br><span class="line">    x--;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line">x++;</span><br><span class="line">printf(&quot;%d&quot;, x);</span><br></pre></td></tr></table></figure></p></li><li><p>ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 10;</span><br><span class="line">&#x2F;*</span><br><span class="line">    說明, 此程式在判別 x 是否大於 5 後, 再行動行</span><br><span class="line">*&#x2F;</span><br><span class="line">if (x &gt; 5) </span><br><span class="line">    x &#x3D; x + 5;</span><br><span class="line">else </span><br><span class="line">    x &#x3D; x - 5;</span><br><span class="line">printf(&quot;%d&quot;, x);</span><br></pre></td></tr></table></figure></p></li></ul><blockquote><p>Note: 註解可分, // =&gt; 單行, /<em>...</em>/ =&gt; 多行註解</p></blockquote><ul><li>ex3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 3, j &#x3D; 5;</span><br><span class="line">if (cond) &#123;</span><br><span class="line">    printf(&quot;%d&quot;, i);</span><br><span class="line">    printf(&quot;%d&quot;, j);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    printf(&quot;false&quot;);</span><br><span class="line">    printf(&quot;%d, %d&quot;, i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Q: cond 為：<ol><li>(i = 0) &amp;&amp; (j = 4), false, 0, 5 =&gt; Ans</li><li>i == 2 &amp;&amp; j == 4, false, 3, 5</li><li>(i = 0) &amp; (j = 4), false, 0, 4</li><li>(i = 2) || (j = 4), 2, 5</li></ol></li></ul><h2>switch...case</h2><ul><li><p>思考：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(c1)</span><br><span class="line">else if (c2)</span><br><span class="line">else if (c3)</span><br><span class="line">else</span><br><span class="line">&#x2F;&#x2F; 當 else if 太多時，採用 switch...case 較清楚</span><br></pre></td></tr></table></figure></p></li><li><p>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(變數 or 運算式)</span><br><span class="line">&#123;</span><br><span class="line">    case 符合文 or 數字：</span><br><span class="line">        statement;</span><br><span class="line">    case ...:</span><br><span class="line">        statement;</span><br><span class="line">    case ...:</span><br><span class="line">        ...;</span><br><span class="line">    default: &#x2F;&#x2F;當所有 case 皆不成立, 則於此</span><br><span class="line">        statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>執行方式：</p><ul><li>step1: 從 switch 的變數去比對哪個 case 符合條件</li><li>step2: 從符合的 case 之 statement 往下做, 直到 break 或 block 結束才停止</li></ul></li><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch(x) &#123;</span><br><span class="line">    default:</span><br><span class="line">        printf(&quot;No match&quot;);</span><br><span class="line">    case 1:</span><br><span class="line">        printf(&quot;1&quot;);</span><br><span class="line">    case 2:</span><br><span class="line">        printf(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1. x &#x3D; 2 &#x3D;&gt; 印出 2</span><br><span class="line">&#x2F;&#x2F; 2. x &#x3D; 5 &#x3D;&gt; 印出 No match 1 2</span><br></pre></td></tr></table></figure></p></li></ul><h2>重複 =&gt; loop in C 常用 loop 語法</h2><h3>for</h3><ul><li><p>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for ( exp1(1); exp2(2); exp3(4)) </span><br><span class="line">&#123;</span><br><span class="line">    statement(3);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1. initial: 只做一次，於進入時做</span><br><span class="line">&#x2F;&#x2F; 2. conditional: 成立，做 3, 接著 4, 再回到 2。不成立，跳出 for loop</span><br><span class="line">----------------------------------</span><br><span class="line">&#x2F;&#x2F; special case:</span><br><span class="line">for ( ; (true); ;)</span><br><span class="line">[</span><br><span class="line">    &#x2F;&#x2F; 無窮迴圈</span><br><span class="line">]</span><br><span class="line">&#x3D;&gt;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex: 1+2+3....+10, 用 for 寫<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0, i;</span><br><span class="line">for(i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;</span><br><span class="line">    sum &#x3D; sum + i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;sum&#x3D;%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 55, i &#x3D; 11 最終跑到 11 不成立</span><br></pre></td></tr></table></figure></p></li></ul><h3>while</h3><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 承上題</span><br><span class="line">int sum &#x3D; 0, i;</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">while (i &lt;&#x3D; 10)</span><br><span class="line">&#123;</span><br><span class="line">    sum &#x3D; sum + i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;sum&#x3D;%d&quot;, sum);</span><br></pre></td></tr></table></figure></li></ul><h3>do...while</h3><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do(1)</span><br><span class="line">&#123;</span><br><span class="line">(3)</span><br><span class="line">(4)</span><br><span class="line">&#125;while(2);</span><br></pre></td></tr></table></figure></li></ul><h3>Compare 前測式 VS 後測式</h3><table><thead><tr><th>前測式</th><th>後測式</th></tr></thead><tbody><tr><td>先做測試，成立才做 statement =&gt; 最少做 0 次</td><td>先做，再做測試 =&gt; 最少做 1 次</td></tr><tr><td>while, for loop</td><td>do-while</td></tr></tbody></table><ul><li>Note: C語言和 C++ 中, 所有關鍵字都是小寫</li></ul><h3>Compare counted loop VS conditional loop</h3><table><thead><tr><th>counted loop (計數式)</th><th>conditional loop(條件式)</th></tr></thead><tbody><tr><td>執行次數明確</td><td>執行次數不明確，在一特定的條件，成立或不成立才終止</td></tr><tr><td>ex: 1+2+....+100</td><td>linked list 長度</td></tr><tr><td>for loop</td><td>while loop</td></tr></tbody></table><h3>continue &amp; break</h3><table><thead><tr><th>continue</th><th>break</th></tr></thead><tbody><tr><td>遇到時，則之後的敘述不做，直接進入 loop 的下一回合</td><td>遇到時，直接跳出所屬的 loop</td></tr></tbody></table><ul><li><p>ex:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; 10; i+&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &#x3D;&#x3D; 6) continue;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; i  2 4 6 8  10 12</span><br><span class="line">&#x2F;&#x2F;sum 2 6 X 14 24 stop</span><br><span class="line">&#x2F;&#x2F;sum &#x3D; 24</span><br></pre></td></tr></table></figure></p></li><li><p>ex2: 承上題 若 continue 改為 break<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; 10; i+&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &#x3D;&#x3D; 6) break;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; i  2 4 6 </span><br><span class="line">&#x2F;&#x2F;sum 2 6 X </span><br><span class="line">&#x2F;&#x2F;sum &#x3D; 6</span><br></pre></td></tr></table></figure></p></li><li><p>ex3: 呈例 2, 將 <strong>==</strong> 改為 <strong>=</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; 10; i+&#x3D;2)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &#x3D; 6) break;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sum &#x3D; 0</span><br></pre></td></tr></table></figure></p></li></ul><h2>Pointer (指標)</h2><ul><li>說明：</li></ul><table><thead><tr><th>一般變數</th><th>指標變數</th></tr></thead><tbody><tr><td>int x;</td><td>int *p;</td></tr></tbody></table><ul><li><p>Ex:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 5;</span><br><span class="line">&#x2F;&#x2F; 下面兩行為 int *p &#x3D; &amp;x</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; &amp;x;</span><br><span class="line">*p &#x3D; *p + 1; &#x2F;&#x2F; 利用指標間接操作指向的內容</span><br><span class="line">printf(&quot;%d&quot;, x)</span><br></pre></td></tr></table></figure></p></li><li><p>Ex: 一學生採 C language coding 如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    printf(&quot;%d, %d&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp &#x3D; x;</span><br><span class="line">    x &#x3D; y;</span><br><span class="line">    y &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Q:</p><ol><li>為何呼叫 swap 後, a, b 沒變動？<br>由於此時 swap 的參數傳遞是採用 call by value, 而非 call by address, 故沒有 side effect, 因此 x, y 的變動, a, b 不受影響</li><li>How to modify the program?<br>in C =&gt; 用 pointer 以改成 call by address<br>in C++ =&gt; 用 pointer or 用 call by reference<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">    swap(&amp;a, &amp;b);</span><br><span class="line">    printf(&quot;%d, %d&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int *x, int *y)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp &#x3D; *x;</span><br><span class="line">    *x &#x3D; *y;</span><br><span class="line">    *y &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2>陣列(Array)</h2><ul><li><p>宣告方式：<br>type 變數 [size];<br>int  A  [5];</p></li><li><p>Note: 在 C, C++ 中, 陣列名稱本身為 <strong>一固定(其內容不可更動)指標</strong>, 永遠指向第 [0]格</p></li><li><p>Ex:</p><ol><li>A[0] = 10</li><li>A = 1000</li><li>*A = 10</li><li>&amp;A[0] = 1000</li><li>A[2] = 30</li><li>&amp;A[2] = 1008</li><li>*(A+1) = 20 -&gt; A(陣列指標)+1 =&gt; 往下一格</li><li>*(A++) = compile error (因為試圖去更動A, 但A的內容不可更動) -&gt; A++ =&gt; A=A+1</li></ol></li><li><p>Ex1:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int A[5];</span><br><span class="line">int *p;</span><br><span class="line">for ( i &#x3D; 0; i&lt;&#x3D; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">    A[i] &#x3D; 5 - i;</span><br><span class="line">&#125;</span><br><span class="line">p &#x3D; A; &#x2F;&#x2F; A為何不用&amp;, 因為A已經是 address 所以不須加</span><br></pre></td></tr></table></figure><img src="pointer.png" alt=""></p></li></ul><p>Q:<br>1. printf(*p);  5<br>2. printf(<em>p++);  5 // 先取值再往下一格<br>3. printf(</em>++p);  3<br>4. printf(++*p);  4<br>5. printf((<em>p++));  4<br>6. printf(</em>--p);  4</p><ul><li>Note:<br>p++ or ++p =&gt; p=p+1 往下一格<br>p-- or --p =&gt; p=p-1 往上一格</li></ul><p>(*p)++ or ++*p =&gt; *p=*p+1 將p指向的內容+1<br>(*p)-- or --*p =&gt; *p=*p-1 將p指向的內容-1</p><h2>雙重指標</h2><ul><li><p>宣告：<br>type  **變數名稱<br>指標的指標<br>=&gt; 需 &quot;2次&quot; 的 Mem. access 才可取得data</p></li><li><p>Ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 5;</span><br><span class="line">int *p &#x3D; &amp;x;</span><br><span class="line">int **q &#x3D; &amp;p;</span><br></pre></td></tr></table></figure><img src="double_pointer.png" alt=""></p></li><li><p>Q:</p><ol><li>q = ?  2000</li><li>&amp;q = ?  3000</li><li>*q = ?  1000</li><li>**q = ?  5</li></ol></li></ul><h2>字串的處理方式</h2><ul><li>C 語言中無 string 之 data type =&gt; 拿 &quot;字元陣列&quot; 來存字串</li><li>ex: cahr a[10];<br>a = &quot;hello&quot;;</li><li>ex1:<br>char *S = &quot;hello&quot;;<ul><li>Q:<ol><li>S[0] = ?</li><li>*(S+4) = ?</li><li>printf(&quot;%s&quot;, S+2);?</li></ol></li><li>Sol:<ol><li>h</li><li>o</li><li>llo</li></ol></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.2 C 語言重點&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;C Language&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;結構
&lt;ul&gt;
&lt;li&gt;xxx.c&lt;/li&gt;
&lt;li&gt;header: 表頭&lt;/li&gt;
&lt;li&gt;body: object code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="C" scheme="https://pingjing0628.github.io/tags/C/"/>
    
      <category term="運算子" scheme="https://pingjing0628.github.io/tags/%E9%81%8B%E7%AE%97%E5%AD%90/"/>
    
      <category term="位元運算" scheme="https://pingjing0628.github.io/tags/%E4%BD%8D%E5%85%83%E9%81%8B%E7%AE%97/"/>
    
      <category term="Pointer" scheme="https://pingjing0628.github.io/tags/Pointer/"/>
    
      <category term="雙重指標" scheme="https://pingjing0628.github.io/tags/%E9%9B%99%E9%87%8D%E6%8C%87%E6%A8%99/"/>
    
      <category term="Structure Programming Language" scheme="https://pingjing0628.github.io/tags/Structure-Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-基本介紹</title>
    <link href="https://pingjing0628.github.io/2021/07/05/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/"/>
    <id>https://pingjing0628.github.io/2021/07/05/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/</id>
    <published>2021-07-05T09:30:35.000Z</published>
    <updated>2022-09-19T12:56:17.453Z</updated>
    
    <content type="html"><![CDATA[<h1>5.1 基本介紹</h1><hr><h2>Programming Language 程式語言</h2><table><thead><tr><th>年代</th><th>特徵1</th><th>特徵2</th><th>特徵3</th><th>特徵4</th><th>特徵5</th></tr></thead><tbody><tr><td>1GL (Machine Language)<strong>低階語言</strong></td><td>由 0, 1 組成</td><td>為機器能直接執行的語言</td><td>user 不易理解</td><td></td><td></td></tr><tr><td>2GL (Assembly Language)<strong>低階語言</strong></td><td>提供簡易的符號供 user 使用</td><td>用 &quot;assembler&quot; 將之轉成 object code</td><td>Ex: ADD R1 3 <strong>=&gt; 將 3 加到 Register R1 中</strong></td><td></td><td></td></tr><tr><td>3GL (High-Level Language)<strong>高階語言</strong></td><td>提供更多貼近 user 的指令</td><td>多為程序導向的程式語言 (procedural language -&gt; tell &quot;how&quot; to do)</td><td>Ex: <code>int i = 3 + 5;</code></td><td>代表：C (具 self-compile), PASCAL, FURTRAN, COBOL, BASIC, C++, JAVA, .NET</td><td>C 語言：  1. compile 完的 object code, 不能跨平台  2. 此邊是語法, 故可跨平台</td></tr><tr><td>4GL (Non-procedural Language) 非程序導向<strong>高階語言</strong></td><td>又稱為<strong>宣告式語言 (Declaractive Language)</strong> -&gt; tell &quot;what&quot; to do</td><td>代表：SQL, report generator</td><td>Ex: <code>Select height From student where height &gt;= 180</code></td><td></td><td></td></tr><tr><td>5GL (Natural Language) 自然語言<strong>高階語言</strong></td><td>使用到人工智慧的技術</td><td>為機器能直接執行的語言</td><td>代表：LISP, PROLOG</td><td></td><td></td></tr></tbody></table><h3>種類</h3><table><thead><tr><th>種類</th><th>代表性程式語言</th><th>備註</th></tr></thead><tbody><tr><td>Interpreter language 直譯</td><td>Basic, Java, Javascript, ASP, PHP, JSP, ruby, groovy, python</td><td></td></tr><tr><td>Compile language 編譯</td><td>C, C++, FURTRAN, PASCAL, COBAL -&gt; 先編譯成 object code</td><td>java, javascript 沒有關係</td></tr><tr><td>先 compile, 後 interpreter -&gt; p-code, java</td><td>跨平台 (cross-platform)</td><td></td></tr><tr><td>Object Oriented Programming (OOP)</td><td>java, C++, C#, .NET, javascript, ruby, python, groovy, VB, smalltalk, Ada</td><td></td></tr><tr><td>Functional Programming Language (函式編程語言) FPL</td><td>LISP, ML, F#</td><td>適用於平行運算, 以 function 為 first class, 各 function 間 No side effect</td></tr></tbody></table><h2>funtion (函式) =&gt; C, C++, Java</h2><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return type   function name  parameter list</span><br><span class="line">&#123;</span><br><span class="line">    function code (body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>return type</code> : 回傳型態 <strong>output</strong></li><li><code>function name</code>: in c, c++ 中 main 代表主程式</li><li><code>parameter List</code>: 參數串列, 接收外界呼叫時須引入的參數 <strong>input</strong></li><li><code>function code</code> <strong>process</strong></li></ol><h2>funtion calling (呼叫)</h2><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">funA()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    ...</span><br><span class="line">    funcB(a, b) &#x2F;&#x2F; (a, b 為 actual parameter 實際參數 AP)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funB(x, y) &#x2F;&#x2F; (x, y 為 foraml parameter 型式參數 FP)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>參數傳遞 (funcB in funcA)</li><li>funcB execute</li><li>funcB return</li></ol><h2>參數傳遞種類</h2><table><thead><tr><th>Call by value</th><th>Call by address</th><th>Call by name</th><th>Call by value-result</th></tr></thead><tbody><tr><td>AP 跟 FP 佔用不同的 memory space</td><td>操作相同 Memory space</td><td>AP 會直接取代 FP 之所在</td><td>在 function 最後結束時, 將 FP 寫回對應 AP 之內容</td></tr><tr><td>No side effect</td><td>有</td><td>有</td><td>有</td></tr><tr><td>binding 速度慢 (最慢)</td><td>最快</td><td>居中</td><td></td></tr><tr><td>不適合用於結構型資料的參數傳遞</td><td>適合</td><td></td><td></td></tr></tbody></table><ul><li>Ex1:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">    fun(a, b);</span><br><span class="line">    print(a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    x &#x3D; 3;</span><br><span class="line">    y &#x3D; 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>問分別採 1. call by value 2. call by address 3. call by value result, output = ? a = ? b = ?<br><strong>Sol:</strong></p><ol><li>a=10, b=20</li><li>x, y 為記錄 a, b 的位址, 並指回原變數。Ans: a=3, b=6</li><li><strong>最後結束時會將 FP 寫回對應 AP 之內容</strong>, 具 side effect(砍掉前，將最後的值抓回)。Ans: a=3, b=6</li></ol><ul><li>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 4, b &#x3D; 6;</span><br><span class="line">    fun(a, b, a+b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">    x &#x3D; 7;</span><br><span class="line">    y &#x3D; 10;</span><br><span class="line">    int t &#x3D; z * z;</span><br><span class="line">    printf(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>問採 1. call by name? 2. call by address?<br><strong>Sol:</strong></p><ol><li>87, 需注意 <code>a+b*a+b</code>先乘除後加減</li><li>100</li></ol><ul><li>Note:<br>採 <code>call by-address</code> 時, 若有運算式, 則此採 <strong>call by-value</strong> 來接收<br><code>call by-reference</code> 一般而言相同, 但在 c++ 中, 2 者完全不同<br><code>call by-name</code> 多做一件事, 所以居中</li></ul><h2>結構化程式三要求 Structure Programming Language SPL</h2><p>三要素：</p><ol><li>循序 sequential<br>指令會依序一一往下執行</li><li>選擇 selective/conditional<br>利用 &quot;判別式&quot; 來決定接下來的執行步驟為何<br><code>if...else...</code><br><code>switch...case...</code></li><li>重複 repeat/iteractive<br>利用 &quot;loop&quot; 來反覆執行部分的 step<br><code>for loop</code><br><code>while</code><br><code>do...while</code></li></ol><ul><li>SPL 中避免使用 &quot;跳躍&quot; 指令或動作<br><code>jump</code>, <code>goto</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.1 基本介紹&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Programming Language 程式語言&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;年代&lt;/th&gt;
&lt;th&gt;特徵1&lt;/th&gt;
&lt;th&gt;特徵2&lt;/th&gt;
&lt;th&gt;特徵3&lt;/th&gt;
&lt;th&gt;特徵4&lt;/t
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="程式介紹" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9/"/>
    
    
      <category term="Structure Programming Language" scheme="https://pingjing0628.github.io/tags/Structure-Programming-Language/"/>
    
      <category term="OOP" scheme="https://pingjing0628.github.io/tags/OOP/"/>
    
      <category term="Call by value" scheme="https://pingjing0628.github.io/tags/Call-by-value/"/>
    
      <category term="Call by address" scheme="https://pingjing0628.github.io/tags/Call-by-address/"/>
    
      <category term="Call by name" scheme="https://pingjing0628.github.io/tags/Call-by-name/"/>
    
      <category term="Call by value result" scheme="https://pingjing0628.github.io/tags/Call-by-value-result/"/>
    
  </entry>
  
  <entry>
    <title>Chapter4-系統程式-part2</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part2/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part2/</id>
    <published>2021-07-02T15:21:54.000Z</published>
    <updated>2022-09-19T12:55:55.920Z</updated>
    
    <content type="html"><![CDATA[<h1>4 系統程式 (System Program)</h1><hr><h2>補充 - Linking 的種類</h2><ul><li>Static Linking (like MACRO)</li><li>Dynamic Linking (like Subroutine)</li></ul><h3>Static Linking</h3><ul><li>指在 linking 時會將外部參考的函式皆搬到程式中, 成為程式的一部份, 故<strong>程式將較佔 space, 但後續執行不需去呼叫外部函式</strong></li><li>巨集 =&gt; 程式碼被撐大</li><li>Static Linking =&gt; 執行檔會被撐大</li><li>圖：<img src="staticLinking.png" alt=""></li></ul><h3>Dynamic Linking</h3><ul><li>Linking 時, 只將外部參考和外部函式所在做繫結, 不將外部函式載入, 故執行時在動態呼叫之</li><li>Ex: .dll =&gt; Dynamic Linking Library</li></ul><h3>Compare</h3><table><thead><tr><th>Static Linking</th><th>Dynamic Linking</th></tr></thead><tbody><tr><td>可執行檔較大</td><td>較小</td></tr><tr><td>不需外部呼叫 =&gt; 快</td><td>需要 =&gt; 慢</td></tr><tr><td>若外部程式改 =&gt; 需 relinking</td><td>不需</td></tr><tr><td>不受外在影響 =&gt; 較安全</td><td>受影響 (駭客可以改, 由於動態呼叫, 因此會被影響) =&gt; 較不安全</td></tr></tbody></table><h2>P-code compiler</h2><ul><li>Def: 為 pesudo-machine 之 object code<ul><li>類似中間碼</li><li>與機器獨立</li><li>高可攜性 =&gt; <strong>具跨平台 cross platform</strong></li></ul></li><li>圖：<img src="p-code.png" alt=""></li><li>優點：只要機器上有 P-code interpreter 即可執行 =&gt; 具可攜性</li><li>缺點：P-code 使用 interpreter 執行, 所以執行速度較慢</li><li>中間碼：類似目的碼, 由 0, 1 組成, 但和機器獨立</li></ul><h2>Java-compiler</h2><p><img src="java-compiler.png" alt=""></p><h2>JVM - Java Virtual Machine</h2><p><img src="jvm.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;4 系統程式 (System Program)&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;補充 - Linking 的種類&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Static Linking (like MACRO)&lt;/li&gt;
&lt;li&gt;Dynamic Linking (like Subrouti
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="系統程式" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F/"/>
    
    
      <category term="System Program" scheme="https://pingjing0628.github.io/tags/System-Program/"/>
    
      <category term="Static Linking" scheme="https://pingjing0628.github.io/tags/Static-Linking/"/>
    
      <category term="Dynamic Linking" scheme="https://pingjing0628.github.io/tags/Dynamic-Linking/"/>
    
      <category term="P-code Compiler" scheme="https://pingjing0628.github.io/tags/P-code-Compiler/"/>
    
      <category term="Java Compiler" scheme="https://pingjing0628.github.io/tags/Java-Compiler/"/>
    
      <category term="JVM" scheme="https://pingjing0628.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Chapter4-系統程式-part1</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part1/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part1/</id>
    <published>2021-07-02T15:21:49.000Z</published>
    <updated>2022-09-19T12:55:52.614Z</updated>
    
    <content type="html"><![CDATA[<h1>4 系統程式 (System Program)</h1><hr><h2>Software License</h2><table><thead><tr><th>Software Licence</th><th>Def</th><th>licence</th><th>Open source code</th><th>Ex</th></tr></thead><tbody><tr><td><strong>Trial software</strong></td><td>試用一段時間, 若欲長期使用需付費</td><td>Yes</td><td>No</td><td>ACDSee</td></tr><tr><td><strong>Shareware</strong></td><td>同上, 但限制較寬鬆</td><td>Yes</td><td>No</td><td>WinRAR</td></tr><tr><td><strong>Freeware</strong></td><td>free</td><td>Yes</td><td>No</td><td>IE, MSN</td></tr><tr><td><strong>Public domain</strong></td><td>free</td><td>No</td><td>No</td><td>X</td></tr><tr><td><strong>Open software</strong></td><td>free</td><td>No</td><td>Yes</td><td>Redhat, Open Office</td></tr></tbody></table><h2>Open Source Software</h2><p>Def:</p><ul><li>指沒有 licence 限制, 可 free 使用, 且可拿到程式碼</li><li><strong>從 Open source 取得的程式, 修改後亦無 licence 所屬也為 Open source</strong></li></ul><h2>System Program</h2><h3><strong>Assembler (組譯器)</strong></h3><ul><li>Def: 將組合語言轉成 object code (<strong>目的碼, 為機器可識別之程式</strong>), 以便系統執行之</li><li>圖：<img src="assembler.png" alt=""></li></ul><h3><strong>Linker/Loader (鏈結器/載入器)</strong> =&gt; linking loader</h3><ul><li>欲將 object code 載入 memory 中, 過程需<ol><li><strong>linking (連結)</strong>: 將 object code 中的外部參考之宣告, 正式跟外部函式庫鏈結</li><li><strong>relocation (重定址)</strong>: 將程式中參考位址依實際 memory 所在重新計算其實際的位址</li><li><strong>loading (載入)</strong>: 正式將上述完成之 object code 載入 memory 中</li></ol></li></ul><h3><strong>Compiler (編譯器)</strong></h3><ul><li>Def: 將高階語言 (c, c++) 轉成低階的 object code</li><li>圖：<img src="compiler.png" alt=""></li><li>Compiler 過程：<ol><li>Lexical Analysis</li><li>Syntax Analysis</li><li>Semantic Analysis</li><li>Intermediate Code Optimization</li><li>Machine Dependent Code Generation and Optimization</li><li>Generate the Object Code<br>1.~ 4. =&gt; <strong>Machine Independent</strong><br>5.~ 6. =&gt; <strong>Machine Dependent</strong></li></ol></li><li>Lexical Analysis 語彙分析<ul><li>Scan the program and find out the token (語彙單元)<ol><li><strong>Terminal Symbol (終端符號)</strong> =&gt; keyword, 保留字</li><li><strong>Identifier (識別字)</strong> =&gt; 變數</li><li><strong>Liferal (常數)</strong> =&gt; 文, 數字</li></ol><ul><li>Ex: int(1) x(2) = (1) 20(3);(1)</li></ul></li><li>圖：<img src="lexical.png" alt=""></li></ul></li><li>Syntax Analysis 語法分析<ul><li>Def: 判別程式敘述是否合乎文法 (Grammer)<ul><li>合乎：建立出 <strong>parsing tree 或 syntax tree</strong></li><li>不合乎：output syntax tree</li></ul></li><li>圖：<img src="syntax.png" alt=""></li><li>文法 (Grammer)<ul><li>Note: 剖析工具: parser (剖析器)</li><li>Def: <code>G = &lt;N, T, P, S&gt;</code><ul><li>N: Non-terminal symbol set (非終端)</li><li>T: Terminal symbol set (終端)</li><li>P: Production rules (推衍規則)</li><li>S: Start symbol (S ∈ N) (起始)</li></ul></li><li>Ex:<br><code>G = &lt;N, T, P, S&gt;</code>, <code>N = {s, A, B}</code>, <code>T = {a, b}</code>,<br><code>P = {S -&gt; A|B; A -&gt; aA|a; B -&gt; bB|b;}</code> (-&gt; 為推衍符號),<br><code>S = s ∈ N</code> (S 為起始符號, s 為起始符號的名稱), 問 abaa, aaa 是否合乎文法？<br><strong>Sol:</strong><ol><li>S -&gt; A -&gt; aA -&gt; 此無法推出 b, 故不合乎文法</li><li>S -&gt; A -&gt; aA -&gt; aaA -&gt; aaa, 可推論出, 故合乎文法</li></ol></li></ul></li><li>Parsing tree 剖析樹<ul><li>Def: 剖析文法敘述所建立之樹</li><li>作法:<ul><li>N 必為 Tree 中的非終端節點 (degree &gt;= 1)</li><li>T 必為 Tree 中的終端節點 (degree = 0)</li></ul></li><li>Ex:<br><code>G = &lt;N, T, P, S&gt;</code>, <code>N = {E, T, F}</code>, <code>T = {+, -, *, /, id (,)}</code>,<br><code>P = {E -&gt; E+T|E-T|T; T -&gt; T*F|T/F|F; F -&gt; id|(E);}</code>, <code>S = E ∈ N</code>,<br>問<ol><li>id + id * id 合法建立剖析樹</li><li>id * (id - id / id)?</li></ol><ul><li>Note: 括號 &quot;()&quot;, 不可以被分割於 2 不同區塊之中<strong>Sol:</strong><br><img src="parsingTree.png" alt=""></li></ul></li></ul></li><li>Syntax tree 語法樹<ul><li>目的：<ul><li>簡化剖析樹</li><li>只保留 Terminal symbol</li><li>利用中序追蹤可還原運算式</li></ul></li><li>Note: <strong>括號不需考慮</strong> (因為已有 priority 之考量)</li></ul></li><li>文法種類<table><thead><tr><th>Note</th><th>Type</th><th>別名</th><th>自動機</th></tr></thead><tbody><tr><td><strong>自由度最大</strong></td><td>0</td><td>Unrestricted (不受限) grammer (AI)</td><td>Turing Machine (杜林機)</td></tr><tr><td><strong>如變數的宣告</strong></td><td>1</td><td>Context-sensitive (上下文相關) grammer</td><td></td></tr><tr><td><strong>高階語法</strong></td><td>2</td><td>Context-free (上下文無關) grammer</td><td></td></tr><tr><td></td><td>3</td><td>Regular grammer</td><td></td></tr></tbody></table></li></ul></li><li>Semantic Analysis 語意分析<ul><li>目的：依剖析結果, 呼叫對應的 semantic routine 或 action routine 以產生 <strong>intermediate code (中間碼)</strong> (<strong>類似目的碼一樣由 0, 1 組成, 但和機器獨立謂之</strong>)</li><li>圖：<img src="semantic.png" alt=""></li></ul></li><li>Intermediate Code Optimization 中間碼最佳化<ul><li>目的：<ol><li>精簡中間碼</li><li>所佔用 space 下降</li><li>效益提高</li></ol></li><li>常用技巧：<ol><li>刪除共通運算式<br><code>A = B + C * D + 2</code><br><code>F = 5 + (B + C + D) / 3</code><br>令 B, C, D 皆不變<br>α = B + C * D</li><li>先求出常數運算<br>Ex: <code>A = 3.14 * 2.56 / 3.2 + 8 - E</code><br>求 α = 3.14 * 2.56 / 3.2 + 8</li><li>布林運算式最佳化<ul><li>Ex1: if (A and B), A B 皆為 Condition (條件式)<br>若 A = false, B 不做 =&gt; 結果必為 false</li><li>Ex2: if (A or B), 若 A = true, B 不做 =&gt; 結果必為 True</li><li>Note: 此概念為：<ul><li>短路：short-circuit</li><li>又稱 <strong>&quot;捷徑運算&quot;</strong></li></ul></li></ul></li></ol></li></ul></li><li>程式中常見的 error<br><img src="error.png" alt=""></li></ul><h3><strong>Interpreter (直譯器)</strong></h3><ul><li>Def:<ul><li>不事先將 source code 轉成 object code</li><li>直接拿 source code 執行, 依原始程式 logical 順序進行</li><li>執行期間 interpreter 須留在 memory 之中</li></ul></li><li>圖：<img src="interpreter.png" alt=""></li></ul><h3>Compare Compiler vs Interpreter</h3><table><thead><tr><th>Compiler</th><th>Interpreter</th></tr></thead><tbody><tr><td>執行不需於 memory 中</td><td>需要</td></tr><tr><td>會事先產生 object code (<strong>有最佳化, 故效益佳</strong>)</td><td>不會, 直接依 logical 執行, 產生結果</td></tr><tr><td>全部 scan, 故比較沒有漏洞</td><td>較易有漏洞</td></tr><tr><td>修改 =&gt; recompile (彈性差)</td><td>不需 recompile (彈性佳)</td></tr><tr><td>開發時期較不適用</td><td>適用</td></tr><tr><td>找 bug 較不易</td><td>較易找到 bug 所在</td></tr><tr><td>初學者較不易</td><td>初學者較易上手</td></tr></tbody></table><hr><h3>Macro 巨集</h3><ul><li>Def: 開放式副程式 (Open subroutine)<br>將一連串的指令定義為巨集指令, 當 source code 轉換時, 遇到巨集呼叫, 就將對應的連串指令插入於呼叫處</li><li>圖：<img src="macro.png" alt=""></li><li>特性：<ol><li>巨集呼叫於<strong>程式轉換</strong>期間, 而非 <strong>runtime</strong></li><li>呼叫 Ｎ 次, 需插入巨集本文 N 次 =&gt; <strong>浪費空間</strong></li><li>執行階段, 不需做控制移轉 =&gt; <strong>快</strong></li><li>多此使用一單獨定義的常式 (定義一次, 可使用多次)</li></ol></li></ul><h3>Subroutine 副程式 =&gt; 又稱 close subroutine</h3><ul><li>Def: 於<strong>執行中</strong>, 當 subroutine 被呼叫才<strong>動態</strong>的去呼叫之, 並將資料及控制權移轉給他, 待完成, 再移轉回來</li><li>優點：只佔用一份 memory =&gt; 省 space</li><li>缺點：需做控制權移轉 =&gt; speed 下降</li></ul><h3>Compare Macro vs Subroutine</h3><table><thead><tr><th>MACRO</th><th>Subroutine</th></tr></thead><tbody><tr><td>Speed 快</td><td>Speed 慢</td></tr><tr><td>以空間換時間</td><td>以時間換空間</td></tr><tr><td>space 浪費</td><td>space 省</td></tr></tbody></table><h2>Summary</h2><p><img src="summary.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;4 系統程式 (System Program)&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Software License&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Software Licence&lt;/th&gt;
&lt;th&gt;Def&lt;/th&gt;
&lt;th&gt;licence&lt;/th&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="系統程式" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F/"/>
    
    
      <category term="System Program" scheme="https://pingjing0628.github.io/tags/System-Program/"/>
    
      <category term="Software" scheme="https://pingjing0628.github.io/tags/Software/"/>
    
      <category term="Assembler" scheme="https://pingjing0628.github.io/tags/Assembler/"/>
    
      <category term="Linker/Loader" scheme="https://pingjing0628.github.io/tags/Linker-Loader/"/>
    
      <category term="Compiler" scheme="https://pingjing0628.github.io/tags/Compiler/"/>
    
      <category term="Interpreter" scheme="https://pingjing0628.github.io/tags/Interpreter/"/>
    
      <category term="Marco" scheme="https://pingjing0628.github.io/tags/Marco/"/>
    
      <category term="Subroutine" scheme="https://pingjing0628.github.io/tags/Subroutine/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-磁碟管理-part3</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part3/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part3/</id>
    <published>2021-07-01T16:10:14.000Z</published>
    <updated>2022-09-19T12:55:34.649Z</updated>
    
    <content type="html"><![CDATA[<h1>3.9 磁碟管理 (Disk Management)</h1><h2>目錄</h2><ul><li>Free space management<ul><li>Link list</li><li>Combination</li><li>Counting</li></ul></li><li>Allocation Method (配置方法)<ul><li>連續性配置 (contiguous allocation)</li><li>鏈結式配置 (linked allocation)<ul><li>FAT (file allocation table)</li></ul></li><li>索引配置 (index allocation)<ul><li>i-node</li></ul></li></ul></li><li>Disk structure**</li><li>Disk access time**</li><li>Disk scheduling**<ul><li>FCFS</li><li>SSTF</li><li>SCAN</li><li>C-SCAN</li><li>LOOK</li><li>C-LOOK</li></ul></li><li>補充</li><li><strong>RAID</strong></li><li><strong>RAID 的種類</strong><ul><li><strong>RAID1</strong></li><li><strong>RAID0+1</strong></li><li><strong>RAID2</strong></li><li><strong>RAID3 vs RAID4</strong></li><li><strong>RAID5</strong></li><li><strong>RAID6</strong></li></ul></li><li><strong>Summary</strong></li></ul><hr><h2>RAID Redundant Array of Independent Disks 磁碟陣列</h2><ul><li>Why RAID?<ol><li><strong>CPU 和 disk I/O 速度不對等</strong></li><li>資料安全性, 可靠性議題</li></ol></li><li>Solution:<ul><li>採用 &quot;<strong>data striping</strong>&quot; 資料切割：指將 data 分成幾個等分, 同時存到不同 disk 之中, <strong>以達平行 I/O 之效</strong></li></ul></li><li>RAID:<ul><li>Def: 指將多顆 physical disk, 組成一顆 logical disk 之後, 以達提高 I/O 效能跟增加資料的可靠性</li><li>圖：<img src="RAID.png" alt=""></li></ul></li></ul><h2>RAID 的種類</h2><ol><li><strong>RAID 0 (striping RAID)</strong></li></ol><ul><li>以效能導向</li><li><strong>速度最快的 RAID</strong></li><li><strong>沒有 fault tolerant</strong></li><li>Cost 低</li><li>至少需 2 顆 disk</li><li>圖：<img src="RAID0.png" alt=""></li></ul><ol start="2"><li><strong>RAID 1 (mirror RAID)</strong></li></ol><ul><li>至少有 &gt;= 2 顆 disk 存相同的 data</li><li>具 <strong>fault tolerant</strong> 特色</li><li>Cost 高 (浪費一半 space)</li><li>Read 效益不佳, write 較差</li><li>至少需 2 顆 disk (資料保護)</li><li>圖：<img src="RAID1.png" alt=""></li></ul><ol start="3"><li><strong>RAID 0+1 (01) speed 快 &gt; RAID 10</strong></li></ol><ul><li>兼具 speed up + fault tolerant</li><li>Cost 極高</li><li>至少需 4 顆 disk</li><li>補充：RAID 1+0 (10)<ul><li>先做 mirror, 在做 striping</li><li>相較下, 此種方法可靠性更佳, 故現在較常用此</li></ul></li><li>圖：<img src="RAID01.png" alt=""></li></ul><ol start="4"><li><strong>RAID 2</strong> (被 RAID 3 ~ 5 取代)</li></ol><ul><li>採用 &quot;ECC&quot; (Error Correcting Code) 技術, 達容錯效果</li></ul><ol start="5"><li><strong>RAID 3 vs RAID 4</strong>|RAID 3|RAID 4||--|--||以 &quot;bit&quot; 為切割單位 (太頻繁)|以 &quot;block&quot; 為單位||效能較差|效能較好|</li></ol><ul><li>共同特色：<ul><li>採 <strong>parity check</strong> 做 data 的可靠性機制</li><li>會有一顆專門放 parity 的 disk =&gt; <strong>會成為效能上的瓶頸</strong></li><li>同時允許一顆 disk 損壞依舊可以復原</li></ul></li><li>圖：<img src="RAID3&amp;4.png" alt=""></li></ul><ol start="6"><li><strong>RAID 5</strong> =&gt; 同 RAID 4, 但將 parity data 平均在各 disk 之上</li></ol><ul><li>圖：<img src="parityData.png" alt=""></li><li>小比較：<table><thead><tr><th>RAID</th><th>Speed</th><th>單位</th><th>parity data</th></tr></thead><tbody><tr><td>3</td><td>慢</td><td>bit</td><td>集中</td></tr><tr><td>4</td><td>中</td><td>block</td><td>集中</td></tr><tr><td>5</td><td>快</td><td>block</td><td>分散</td></tr></tbody></table></li></ul><ol start="7"><li><strong>RAID 6</strong></li></ol><ul><li>採 &quot;parity check&quot; + &quot;read soloman code&quot; =&gt; 可允許同時 2 顆 disk 損壞, 仍可恢復</li><li><strong>可靠性優於 RAID 3 ~ 5</strong></li></ul><h2>Summary</h2><table><thead><tr><th>RAID</th><th>至少 disk 數</th><th>Speed</th><th>Cost</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>快</td><td>低 -&gt; striping</td></tr><tr><td>1</td><td>2</td><td>慢</td><td>高 -&gt; mirror</td></tr><tr><td>0+1</td><td>4</td><td>快</td><td>最高</td></tr><tr><td>3</td><td>3</td><td>居中</td><td>居中 -&gt; parity check</td></tr><tr><td>4</td><td>3</td><td>居中</td><td>居中 -&gt; parity check</td></tr><tr><td>5</td><td>3</td><td>居中</td><td>居中 -&gt; parity check</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.9 磁碟管理 (Disk Management)&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Free space management
&lt;ul&gt;
&lt;li&gt;Link list&lt;/li&gt;
&lt;li&gt;Combination&lt;/li&gt;
&lt;li&gt;Counting&lt;/li
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="Disk Management" scheme="https://pingjing0628.github.io/tags/Disk-Management/"/>
    
      <category term="RAID" scheme="https://pingjing0628.github.io/tags/RAID/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-磁碟管理-part2</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part2/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part2/</id>
    <published>2021-07-01T16:10:10.000Z</published>
    <updated>2022-09-19T12:55:32.403Z</updated>
    
    <content type="html"><![CDATA[<h1>3.9 磁碟管理 (Disk Management)</h1><h2>目錄</h2><ul><li>Free space management<ul><li>Link list</li><li>Combination</li><li>Counting</li></ul></li><li>Allocation Method (配置方法)<ul><li>連續性配置 (contiguous allocation)</li><li>鏈結式配置 (linked allocation)<ul><li>FAT (file allocation table)</li></ul></li><li>索引配置 (index allocation)<ul><li>i-node</li></ul></li></ul></li><li><strong>Disk structure</strong></li><li><strong>Disk access time</strong></li><li><strong>Disk scheduling</strong><ul><li><strong>FCFS</strong></li><li><strong>SSTF</strong></li><li><strong>SCAN</strong></li><li><strong>C-SCAN</strong></li><li><strong>LOOK</strong></li><li><strong>C-LOOK</strong></li></ul></li><li><strong>補充</strong></li><li>RAID</li><li>RAID 的種類<ul><li>RAID1</li><li>RAID0+1</li><li>RAID2</li><li>RAID3 vs RAID4</li><li>RAID5</li><li>RAID6</li></ul></li><li>Summary</li></ul><hr><h2>Disk structure</h2><ul><li>圖：<img src="diskStructure.png" alt=""></li><li>track 的水平集合 =&gt; surface (磁面)</li><li>track 的垂直集合 =&gt; cylinder (磁柱) 圓柱體</li><li>順序 小 -&gt; 大 =&gt; sector &lt; cluster &lt; track &lt; {surface, cylinder}</li><li>Ex: cylinder = 10, tracks = 20<ul><li>each track has 320 sector</li><li>each sector 的 size = 512 bytes<br>What's the disk total size?<br>Sol:<br><code>10 * 20 * 320 * 512 bytes</code><br><code>= 32000 KB</code><br>約等於 32 MB</li></ul></li></ul><h2>Disk access time</h2><ul><li><p>由下列組成：</p><ol><li>Seek time 搜尋時間：將 Header (讀寫頭) 移到指定的 Track 上方 (最耗時)</li><li>Rotation time 旋轉時間 (Latency 延遲)：將 data 轉到 Header 的下方 (耗時 中等)</li><li>Transfer time 傳輸時間：正式由 Header 讀取 data 做 disk  &lt;-&gt; Memory 傳輸 (耗時 小)</li></ol></li><li><p>Ex: seek time 平均需 8ms, 而 disk 為 7200RPM(轉), 問平均 disk access time = ?<br>RPM = Rotate Per Minute: 7200/60 = 120/secSol:<br>seek time + rotate (平均) = 8ms + 1/120 sec * 1/2 = 8ms + 1/240 sec<br><img src="Ex.png" alt=""></p></li></ul><h2>Disk Scheduling</h2><ul><li>Def: 指當有多個 access request, 在不同的 disk 之上, 則 Header 之移動服務順序為何</li><li><strong>策略採 &quot;Disk Scheduling algorithm&quot;</strong><ol><li><strong>FCFS (FIFO) (First Come First Service)</strong><ul><li>Ex: track 0~99, header = 15, access request - 81, 47, 90, 18, 5<br>Sol: <img src="FCFS.png" alt=""></li></ul></li><li><strong>SSTF (Shortest Seek Time First)(不見得為最佳解)</strong><ul><li>Ex: <img src="SSTF.png" alt=""></li></ul></li><li><strong>SCAN (掃描法)</strong>: 來回於兩端移動, 遇到 access request 即停下來服務之</li><li><strong>C-SCAN</strong> =&gt; 同 SCAN, 但 &quot;單向服務&quot;<ul><li>圖：<img src="C-SCAN.png" alt=""></li></ul></li><li><strong>LOOK</strong>: 跟 SCAN 相似, 但<strong>不見得碰底, 沒服務則往回走</strong><ul><li>較有效率, 但也就較複雜, 需額外空間處理</li><li>圖：<img src="LOOK.png" alt=""></li></ul></li><li><strong>C-LOOK</strong>: 同 LOOK, 但 &quot;單向服務&quot;<ul><li>圖：<img src="C-LOOK.png" alt=""></li></ul></li></ol></li></ul><h2>補充</h2><table><thead><tr><th>說明</th><th>傳統 (IDE, SCSI, SATA)</th><th>固態硬體 SSD(Solid State Drive)</th></tr></thead><tbody><tr><td>比較 1</td><td>Header 採機械式移動 =&gt; 慢 (seek 是 sequential)</td><td>採用 &quot;電子式&quot; =&gt; 快 (random access)</td></tr><tr><td>比較 2</td><td>抗震性差</td><td>抗震性佳 =&gt; 適用於行動裝置上</td></tr><tr><td>比較 3</td><td>成本低</td><td>成本高</td></tr><tr><td>比較 4</td><td>容量高</td><td>容量小</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.9 磁碟管理 (Disk Management)&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Free space management
&lt;ul&gt;
&lt;li&gt;Link list&lt;/li&gt;
&lt;li&gt;Combination&lt;/li&gt;
&lt;li&gt;Counting&lt;/li
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="Disk Management" scheme="https://pingjing0628.github.io/tags/Disk-Management/"/>
    
      <category term="Disk structure" scheme="https://pingjing0628.github.io/tags/Disk-structure/"/>
    
      <category term="Disk scheduling" scheme="https://pingjing0628.github.io/tags/Disk-scheduling/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-磁碟管理-part1</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part1/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part1/</id>
    <published>2021-07-01T16:08:39.000Z</published>
    <updated>2022-09-19T12:55:29.572Z</updated>
    
    <content type="html"><![CDATA[<h1>3.9 磁碟管理 (Disk Management)</h1><h2>目錄</h2><ul><li><strong>Free space management</strong><ul><li><strong>Link list</strong></li><li><strong>Combination</strong></li><li><strong>Counting</strong></li></ul></li><li><strong>Allocation Method (配置方法)</strong><ul><li><strong>連續性配置 (contiguous allocation)</strong></li><li><strong>鏈結式配置 (linked allocation)</strong><ul><li><strong>FAT (file allocation table)</strong></li></ul></li><li><strong>索引配置 (index allocation)</strong><ul><li><strong>i-node</strong></li></ul></li></ul></li><li>Disk structure</li><li>Disk access time</li><li>Disk scheduling<ul><li>FCFS</li><li>SSTF</li><li>SCAN</li><li>C-SCAN</li><li>LOOK</li><li>C-LOOK</li></ul></li><li>補充</li><li>RAID</li><li>RAID 的種類<ul><li>RAID1</li><li>RAID0+1</li><li>RAID2</li><li>RAID3 vs RAID4</li><li>RAID5</li><li>RAID6</li></ul></li><li>Summary</li></ul><hr><h2>Free Space Management</h2><ol><li><strong>Bit Vector (位元向量)</strong></li></ol><ul><li>圖：<img src="bitVector.png" alt=""></li><li>Def: 給各 block 一個 bit, 當 bit<ul><li>bit = 0, 則 free block</li><li>bit = 1, 則 use</li></ul></li><li>Ex: <code>011001110001</code></li><li>優點：<ol><li>easy to implement</li><li>找連續可用的 block 容易</li></ol></li><li>缺點：當 block 太多, 則 bit vector 不適用</li></ul><ol start="2"><li><strong>Link list (鏈結串列)</strong></li></ol><ul><li>Def: 將 free block 以 link 方式串接</li><li>Ex: <img src="linkList.png" alt=""></li><li>優點：insert / delete free block 容易</li><li>缺點：<ol><li>檔案配置不便</li><li>link broken, data lose</li></ol></li></ul><ol start="3"><li><strong>Combination (組合)</strong></li></ol><ul><li>Def: 將一 Node 給予多個格子合併而成</li><li><img src="combination.png" alt=""></li><li>Ex: <img src="combinationEx.png" alt=""></li></ul><ol start="4"><li><strong>Counting (計數法)</strong></li></ol><ul><li>Def: 在 linked list 中 Node 加入一空間, 放連續 free block 之數量 (<strong>連續的 free block 越多, 串列越短</strong>)</li><li>Ex: <img src="countingEx.png" alt=""></li></ul><hr><h2>Allocation Method (配置方法)</h2><ol><li><strong>連續性配置 (contiguous allocation)</strong></li></ol><ul><li>Def: 檔案大小 = n blocks 時, O.S. 需找到連續 free block &gt;= n, 方可配置</li><li>優點：<ol><li>search time 短 =&gt; 因為 data 鄰近度</li><li>support sequential 及 random access =&gt; 處理快</li></ol></li><li>缺點：<ol><li>有 external 碎裂</li><li>檔案大小無法任意擴充</li><li>file size 需事先宣告<br>(2, 3 會導致沒有彈性)</li></ol></li><li><strong>Solution:</strong><ol><li><strong>Repack (壓縮), 但極度耗時</strong></li><li><strong>disk defragmentation 磁碟重組: 將 file 的分配重組, 以求能達:</strong><ul><li>access time 下降 =&gt; 速度快</li><li>連續空間變多 =&gt; 外部碎裂下降</li></ul></li></ol></li><li>圖：<img src="contiguous.png" alt=""></li></ul><ol start="2"><li><strong>鏈結式配置 (linked allocation)</strong></li></ol><ul><li>Def: 檔案大小 = n blocks 時, O.S. 需找到 free block &gt;= n, 即可配置</li><li>優點：<ol><li>No external 碎裂</li><li>檔案可以擴充</li><li>file size 不需事先宣告<br>(2, 3 有彈性)</li></ol></li><li>缺點：<ol><li>search time 長 (因為 data 不見得於鄰近處)</li><li>support sequential 較慢, 不支援 random access</li></ol></li><li>圖：<img src="linked.png" alt=""></li><li><strong>FAT (file allocation table)</strong><ul><li>Def:<ul><li>用於 Dos, OS/2 之中</li><li>FAT Stored in the disk, 紀錄各 file block 的 link 關係</li></ul></li><li>Ex: <img src="FATEx.png" alt=""></li><li>Note: windows PC 版用 &quot;NTFS&quot; 格式</li><li>圖：<img src="FAT.png" alt=""></li></ul></li></ul><ol start="3"><li><strong>索引配置 (index allocation)</strong></li></ol><ul><li>Def: 各 file 皆有自己的 index block, 用以指向其 block 對應到 disk block 的編號為何</li><li>Ex: <img src="indexEx.png" alt=""></li><li>優點：結合 Contiguous Allocation &amp; Linked Allocation 的優點 =&gt; speed up 又有彈性</li><li>缺點：<ol><li>index block 需佔用額外空間</li><li>index block 大小不易決定</li></ol></li><li><strong>i-node (unix-like 常用)</strong><ul><li>概念：<img src="i-node.png" alt=""></li><li>說明：<br>1 ~ 12: direct index block (最重要的)<br>13: single indirect index block<br>14: double indirect index block<br>15: triple indirect index block</li><li>Ex:<br>1~10: direct block<br>11: single indirect block<br>12: double indirect block<br>13: triple indirect block<hr>each data block = 4 bytes<br>each index block = 4 k<br>each index size = 4<br>total data size = ?<br><strong>Sol:</strong><br><code>10 * 4 bytes</code> + <code>4k/4 * 4 bytes</code> +<br><code>k * k * 4 bytes</code> + <code>k * k * k * 4 bytes</code><br>= <code>40 bytes + 4kB + 4k^2B + 4k^3B</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.9 磁碟管理 (Disk Management)&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Free space management&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Link list&lt;/strong&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="Disk Management" scheme="https://pingjing0628.github.io/tags/Disk-Management/"/>
    
      <category term="Free space management" scheme="https://pingjing0628.github.io/tags/Free-space-management/"/>
    
      <category term="Bit vector" scheme="https://pingjing0628.github.io/tags/Bit-vector/"/>
    
      <category term="Linked list" scheme="https://pingjing0628.github.io/tags/Linked-list/"/>
    
      <category term="Combination" scheme="https://pingjing0628.github.io/tags/Combination/"/>
    
      <category term="Counting" scheme="https://pingjing0628.github.io/tags/Counting/"/>
    
      <category term="Allocation Method" scheme="https://pingjing0628.github.io/tags/Allocation-Method/"/>
    
      <category term="FAT" scheme="https://pingjing0628.github.io/tags/FAT/"/>
    
      <category term="i-node" scheme="https://pingjing0628.github.io/tags/i-node/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-虛擬記憶體-part2</title>
    <link href="https://pingjing0628.github.io/2021/06/24/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94-part2/"/>
    <id>https://pingjing0628.github.io/2021/06/24/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94-part2/</id>
    <published>2021-06-24T14:43:52.000Z</published>
    <updated>2022-09-19T12:55:22.345Z</updated>
    
    <content type="html"><![CDATA[<h1>3.8 虛擬記憶體 (Virtual Memory)</h1><ul><li>目的：允許 program size &gt; physical memory size, 而程式仍能執行</li><li>作法：(部分載入) =&gt; <strong>有需要才載入</strong><br>方法：<br>1. Dynamic Loading =&gt; 為 <strong>programmer</strong> 的負擔<br>2. Virtual Memory =&gt; 為 <strong>O.S.</strong> 的負擔</li></ul><h2>目錄</h2><ul><li>Dynamic Loading 動態載入</li><li>Virtual Memory</li><li>Virtual Memory Definition</li><li><strong>Virtual Memory實施方式</strong><ul><li><strong>Demand Paging</strong></li><li><strong>Demand Segment</strong></li><li><strong>Page Fault 處理</strong></li><li><strong>Virtual Memory Performance 評估</strong><ul><li><strong>P 的影響因素</strong><ol><li><strong>frame 數量</strong></li><li><strong>page size 大小</strong></li><li><strong>Program Structure</strong></li><li><strong>Page Replacement algorithm</strong><ol><li><strong>FIFO</strong></li><li><strong>OPT</strong></li><li><strong>LRU</strong></li><li><strong>LRU 近似法則</strong></li><li><strong>Frequency of reference</strong></li></ol></li></ol></li></ul></li><li><strong>Demand Paging 的問題：「Thrashing」猛移/輾轉</strong><ul><li><strong>防止 Thrashing 作法</strong></li></ul></li></ul></li></ul><hr><h2>Virtual Memory 實施方式</h2><ol><li>Demand Paging<ul><li>Def:<ul><li>執行初期只載入部分的 page (有需要, 才載入)</li><li>當遇到 &quot;所需 page 不在 memory 之中&quot;, 則通知 O.S. 做 **page fault (頁面缺失)**處理, <strong>將 lose page 載入 memory 之中</strong></li></ul></li><li>作法：<ul><li>在 P.T. 上加入 V/I Bit , 使 memory 可達部分載入之效</li><li><strong>V: Valid (存在 Memory)</strong></li><li><strong>I: Invalid (不存在)</strong></li></ul></li><li>圖：  <img src="demandPaging.png" alt=""></li></ul></li><li>Demand Segment</li></ol><h3>Page Fault 處理</h3><ol><li>產生 page fault interrupt 訊號給系統</li><li>find: 找一 free frame</li><li>swap in: 將 lose page 載入 memory 中</li><li>updates: 改 page table 內容</li><li>將控制權交還 user</li></ol><hr><h2>Virtual Memory Performance 評估</h2><p>=&gt; 由 Memory 存取時間來決定 (effect memory access time)<br>=&gt; <strong><code>(1 - P) x ma + P x PFPT</code></strong></p><ul><li><code>(1 - P) x ma</code> 命中所需<ul><li>1 - P 小較好</li><li>ma 短</li></ul></li><li><code>P x PFPT</code> 沒命中<ul><li>PFPT 長</li><li><strong>結論 P 越低越好</strong></li></ul></li><li>P: page fault ratio</li><li>ma: memory access time (硬體不能改)</li><li>PFPT: page fault processing time (不能改)</li></ul><h3>P 的影響因素為</h3><ol><li>frame 數量<br><img src="P1.png" alt=""></li><li>page size 大小<ul><li>當 page size 越小, 則：</li><li>缺點：<ol><li>Page Table 大小上升</li><li>I/O 次數 上升</li><li>Page fault ratio 上升</li></ol></li><li>優點：<ol><li>內部碎裂下降</li><li>單一 I/O 量 下降</li></ol></li></ul></li><li>Program Structure:<br>=&gt; 說明：program 的設計跟撰寫的 logical 結構亦會影響 P 的大小</li><li><strong>Page Replacement (頁面置換)</strong> algorithm<ul><li>Def: 當 page fault 時, 又系統的 free frame 已無, 則需：<ol><li><strong>挑出一 victim page (V.P)</strong></li><li><strong>將 Victim Page swap out</strong></li><li><strong>將 Lose Page swap in</strong></li></ol></li><li>挑選策略分為：<ol><li><strong>FIFO</strong></li><li><strong>OPT</strong></li><li><strong>LRU</strong></li><li><strong>LRU 近似法則</strong></li><li><strong>Frequency of reference</strong></li></ol></li></ul></li></ol><h4>1. FIFO - First In First Out</h4><ul><li>先到達, 先被置換</li><li>特色：<ul><li>easy to implement</li><li>效益不佳 (page fault ratio 太高, I/O 就多, 效益一定不好)</li><li>有 <strong>Belady's 異常</strong><ul><li>一般：frame 數給越多 =&gt; page fault ratio 下降</li><li>在 Belady's 之下：frame 數給越多 =&gt; page fault ratio 上升</li></ul></li></ul></li><li>Ex: 採 FIFO, 且用 pure demand paging, page fault 幾次？<br><img src="exFIFO.png" alt=""></li></ul><h4>2. OPT (Optimal) 最佳法則</h4><ul><li>Def: 替換掉 <strong>未來長期不用</strong>的</li><li>特質：<ol><li>效益最佳 (因為 page fault ratio 最小)</li><li>No Belady's 異常</li><li>要預測未來不易 (實作困難)</li><li>拿來當作理論的依據</li></ol></li><li>Note: demand paging 載入方式<ul><li>pure =&gt; 不先載入, 一開始會有 page fault</li><li>prepaging =&gt; 做預先載入</li></ul></li><li>Ex: 呈上例才 OPT<br><img src="OPT.png" alt=""></li></ul><h4>3. LRU (Least Recently Used) =&gt; 看過去的歷史 (Stack)</h4><ul><li>Def: 替換<strong>過去</strong>長期不用的 page</li><li>特色：<ol><li>效果不錯</li><li>No Belady's 異常</li><li>需 Hardware Support (大量硬體)</li></ol></li><li>作法：<ol><li>Counting (計數法)<br>紀錄 page 的參考時間, 替換掉最久的 page</li><li><strong>Stack (堆疊法)</strong><br>採 stack 方式, 最近用的於 top 端, 最底層為下次 swap 之 page</li></ol></li><li>Ex: LRU<br><img src="LRU.png" alt=""></li></ul><h4>4. LRU 近似法則</h4><ul><li>Def: 由於 LRU 近 <strong>花費大量的 Hardware</strong>, 故採用 LRU 近似法來模擬 LRU 之效</li><li>作法：<ol><li>Second Chance<ul><li>Def: FIFO + 1 個 Reference Bit (0 =&gt; 沒被參考, 1 =&gt; 有被參考)</li><li>挑選策略：<ul><li><strong>先用 FIFO 找出 page: P</strong></li><li><strong>check page: P</strong><ul><li><strong>若 R.B = 1 =&gt; 改為 0, 往下找</strong></li><li><strong>若 R.B = 0 =&gt; 此為 victim page</strong></li></ul></li></ul></li><li>Ex: <img src="secondChance.png" alt=""></li><li>Special Case:<ul><li>當 R.B 全為 0, 或 R.B 全為 1, 代表 =&gt; 退化成 FIFO (可能有 Belady's)</li></ul></li></ul></li><li>Enhanced Second Chance<ul><li>Def: 將 Second Chance + 1 個 Modification Bit (M.B)(想要讓效能變更快)</li><li>Note: M.B<ul><li>=0, 代表 page 沒有更動過</li><li>=1, 代表 page 有更動過</li></ul></li><li>當 Victim page 之 M.B = 0, 代表內容沒變, 故不需 swap out =&gt; <strong>performance 上升</strong></li><li>圖：<img src="enhanceChance1.png" alt=""></li><li>挑選策略：<img src="enhanceChance2.png" alt=""></li><li>Ex: 問 victim page, 採 second chance 挑, enhanced second chance 挑？<br><img src="LRU%E8%BF%91%E4%BC%BCex.png" alt=""><br>採 second chance 挑 2<br>enhanced second chance 挑 4</li></ul></li></ol></li></ul><h4>5. Frequency of reference</h4><ul><li>紀錄各 page 被參考的次數</li><li>方式：<ol><li>LFU =&gt; 挑參考值最小的當 victim page</li><li>MFU =&gt; 挑參考值最大的當 victim page</li></ol></li></ul><hr><h2>Demand Paging 的問題：「Thrashing」猛移/輾轉</h2><ul><li>Def: 於 demand paging 下, 當 <strong>process frame 不足</strong>產生 page fault 又 <strong>memory 的 frame</strong>亦不足, 此時需搶奪其他 process 的 frame, 導致：<ul><li><strong>CPU utilization 下降</strong></li><li><strong>O.S. 引入更多 process</strong></li><li><strong>Page fault 更嚴重</strong></li><li>圖：<img src="thrashing1.png" alt=""></li></ul></li><li>問：<ol><li>CPU 使用率 10%, How to do ?</li><li>呈上得知 page fault ratio 90%, How to do ?<br>Sol:<ol><li><strong>Multiprogramming Degree 上升 (引入更多 process)</strong></li><li><strong>Multiprogramming Degree 下降 (收回一些 process)</strong></li></ol></li></ol></li></ul><h3>防止 Thrashing 作法</h3><ol><li>控制 page fault ratio <strong>合理 range</strong><ul><li>圖：<img src="thrashing2.png" alt=""></li></ul></li><li>採 <strong>Working Set Model</strong>(工作集模式)<ul><li>Def: 利用程式執行時有 **&quot;局部性&quot;**之特性, 將各 process 於此 working set 所需之 frame 加以配置, 避免 Thrashing<ul><li><strong>Locality: 指程式於一特定時間會集中執行部分的區塊, 而不是 uniform 的執行</strong></li></ul></li><li>分：<ul><li>Temporal (時間)<ul><li>ex: loop, subroutine, stack, counter</li><li>用到的不久後還會被用到</li></ul></li><li>Spatial (空間)<ul><li>ex: array, 范紐曼, sequential code</li><li>我被用了, 鄰近的空間很容易也被用到</li></ul></li></ul></li><li>Note:<ul><li>O(某符號): Working Set Window<br>Working set (W.S.) =&gt; 指 O 中不同的 page 之集合<br>Working set size (W.S.S) =&gt; 為 W.S 之大小</li></ul></li><li><strong>判別：令</strong> <img src="thrashing3.png" alt=""><ul><li>n: process 數</li><li>M: physical free frame 的數量</li></ul><ol><li>若 <code>D &lt;= M</code> =&gt; 依各 process 的 W.S.S 配置 frames 數量</li><li><code>D &gt; M</code> =&gt; stop 部分 process, go to 1.</li></ol></li><li>Ex:<br>P1: 1 2 2 1 | 3 4 2 2 | 3 4 1 5<br>P2: 2 2 1 3 | 3 3 3 3 | 4 2 4 2<br>P3: 1 2 3 4 | 4 3 3 3 | 3 2 2 1<br>O(某符號) = 4<br>Sol:<br>P1:<br>W.S. = {1, 2}<br>W.S.S = 2<br>P2:<br>W.S. = {1, 2, 3}<br>W.S.S = 3<br>P3:<br>W.S. = {1, 2, 3, 4}<br>W.S.S = 4<br>Total: 9</li><li>優點：<ol><li>防止 Thrashing</li><li>對 Prepaging 很有幫助</li></ol></li><li>缺點：<ol><li>Working set 的追蹤不易</li><li>Working set 之間的 Transfer time 拉長</li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.8 虛擬記憶體 (Virtual Memory)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;目的：允許 program size &amp;gt; physical memory size, 而程式仍能執行&lt;/li&gt;
&lt;li&gt;作法：(部分載入) =&amp;gt; &lt;strong&gt;有需要才載入&lt;/
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="Virtual Memory" scheme="https://pingjing0628.github.io/tags/Virtual-Memory/"/>
    
      <category term="Demand Paging" scheme="https://pingjing0628.github.io/tags/Demand-Paging/"/>
    
      <category term="Page Fault" scheme="https://pingjing0628.github.io/tags/Page-Fault/"/>
    
      <category term="Virtual Memory Performance" scheme="https://pingjing0628.github.io/tags/Virtual-Memory-Performance/"/>
    
      <category term="FIFO" scheme="https://pingjing0628.github.io/tags/FIFO/"/>
    
      <category term="LRU" scheme="https://pingjing0628.github.io/tags/LRU/"/>
    
      <category term="OPT" scheme="https://pingjing0628.github.io/tags/OPT/"/>
    
      <category term="Thrashing" scheme="https://pingjing0628.github.io/tags/Thrashing/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-虛擬記憶體-part1</title>
    <link href="https://pingjing0628.github.io/2021/06/24/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94-part1/"/>
    <id>https://pingjing0628.github.io/2021/06/24/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94-part1/</id>
    <published>2021-06-24T14:42:29.000Z</published>
    <updated>2022-09-19T12:55:19.017Z</updated>
    
    <content type="html"><![CDATA[<h1>3.8 虛擬記憶體 (Virtual Memory)</h1><ul><li>目的：允許 program size &gt; physical memory size, 而程式仍能執行</li><li>作法：(部分載入) =&gt; <strong>有需要才載入</strong><br>方法：<br>1. Dynamic Loading =&gt; 為 <strong>programmer</strong> 的負擔<br>2. Virtual Memory =&gt; 為 <strong>O.S.</strong> 的負擔</li></ul><h2>目錄</h2><ul><li><strong>Dynamic Loading 動態載入</strong></li><li><strong>Virtual Memory</strong></li><li><strong>Virtual Memory Definition</strong></li><li>Virtual Memory實施方式<ul><li>Demand Paging</li><li>Demand Segment</li><li>Page Fault 處理</li><li>Virtual Memory Performance 評估<ul><li>P 的影響因素<ol><li>frame 數量</li><li>page size 大小</li><li>Program Structure</li><li>Page Replacement algorithm<ol><li>FIFO</li><li>OPT</li><li>LRU</li><li>LRU 近似法則</li><li>Frequency of reference</li></ol></li></ol></li></ul></li><li>Demand Paging 的問題：「Thrashing」猛移/輾轉<ul><li>防止 Thrashing 作法</li></ul></li></ul></li></ul><hr><h2>Dynamic Loading 動態載入</h2><ul><li>執行之初只載入所需的部分頁面</li><li>當 subroutine 被呼叫時, 再將之載入到其他不需用的 subroutine 的所在位址, 以 <strong>覆寫</strong> 利用原 Memory space <strong>=&gt; 為 Overlay 之技巧</strong></li><li>圖：<img src="dynamicLoading.png" alt=""></li></ul><h2>Virtual Memory</h2><ul><li>圖：<img src="virtualMem.png" alt=""></li></ul><h2>Virtual Memory Definition</h2><ul><li><strong>正在執行中</strong>的區塊才載入 Memory</li><li>將 Logical 和 Physical address 分開<strong>且 Logical 可大於 Physical 之 address</strong></li><li>在系統會於 <strong>次儲存媒體</strong>(主要 storage 為 main memory, 次要為 <strong>disk</strong> or CD-ROM)挪用一塊空間模擬(<strong>swap space</strong>)成 Memory</li><li>執行時允許<strong>動態</strong>的 swap in/out</li><li>優點：<ol><li>Program 不受限於 physical memory</li><li>Programmer 可專心寫程式即可</li><li>各 process 佔用 memory space 下降 <strong>=&gt;可列入更多 process, 即 Multiprogramming Degree 上升</strong></li><li>單次 I/O 量下降, 但 I/O 次數上升(缺),存取效能下降(因為需I/O)(缺)</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.8 虛擬記憶體 (Virtual Memory)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;目的：允許 program size &amp;gt; physical memory size, 而程式仍能執行&lt;/li&gt;
&lt;li&gt;作法：(部分載入) =&amp;gt; &lt;strong&gt;有需要才載入&lt;/
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="Virtual Memory" scheme="https://pingjing0628.github.io/tags/Virtual-Memory/"/>
    
      <category term="Dynamic Loading" scheme="https://pingjing0628.github.io/tags/Dynamic-Loading/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-記憶體管理</title>
    <link href="https://pingjing0628.github.io/2021/06/22/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86/"/>
    <id>https://pingjing0628.github.io/2021/06/22/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86/</id>
    <published>2021-06-22T12:44:03.000Z</published>
    <updated>2022-09-19T12:55:10.260Z</updated>
    
    <content type="html"><![CDATA[<h1>3.7 記憶體管理 (Memory Management)</h1><p>圖：<img src="%E8%A8%98%E6%86%B6%E9%AB%94.png" alt=""></p><hr><h2>Memory Allocation Strategy 記憶體配置策略</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">定義</th><th style="text-align:center">Time</th><th style="text-align:center">Space 使用率</th></tr></thead><tbody><tr><td style="text-align:left">First Fit</td><td style="text-align:left">從頭找, 當 free block size &gt;= n, 即可配置</td><td style="text-align:center">佳</td><td style="text-align:center">佳</td></tr><tr><td style="text-align:left">Best Fit</td><td style="text-align:left">從頭到尾, 找出所有符合 free block size &gt;= n, 且差異小者</td><td style="text-align:center">差</td><td style="text-align:center">佳</td></tr><tr><td style="text-align:left">Worst Fit</td><td style="text-align:left">從頭到尾, 找出所有符合 free block size &gt;= n, 且差異大者</td><td style="text-align:center">差</td><td style="text-align:center">差</td></tr></tbody></table><ul><li>Ex:<img src="allocation.png" alt=""></li></ul><h3>First Fit 的小問題</h3><p>經長期配置後, 前面的片段都會只剩下一小部分, 後續的 search 每次皆須經過<br>=&gt; Solution: 採用 &quot;<strong>Next Fit</strong>&quot;<br>Def: 利用 First Fit 概念, 但會從 <strong>上次配置的下一個節點開始 search</strong></p><h2>Memory 中常發生的問題</h2><ol><li>外部碎裂：External Fragmentation<br>Def: 指 process 所需的 Memory 大小小於 memory 總可用空間, 但卻不能配置 (因為空間不連續, <strong>空間夠但不能給</strong>)<br>Solution:<ol><li>Multiple Base/Limit 暫存器</li><li>Compaction 壓縮</li><li>Page Memory Management 分頁式</li></ol></li><li>內部碎裂：Internal Fragmentation<br>Def: 給予的 Memory 大小較 process 所需空間大 (給太多, 你不用別人也不能用), 造成空間上的浪費<br>Solution:<ol><li>Segment Memory Management 分段式</li></ol></li></ol><h3>Multiple Base/ Limit register set. 多重基底限制暫存器</h3><p><img src="baseLimit.png" alt=""></p><h3>Compaction 壓縮</h3><ul><li><p>圖：<img src="compaction.png" alt=""></p></li><li><p>困難：</p><ol><li>壓縮策略不易制定</li><li>Process 皆需支援 <strong>Dynamic Binding</strong> (只要一 process 不支援, 則無法採用)</li></ol></li></ul><h3>Paged Memory Management 分頁式</h3><ul><li><p>觀念：</p><ol><li>Physical memory 視為一組頁框 (frame) 之集合, <strong>各 frame 大小一致</strong></li><li>Logical memory 視為一組頁面 (page) 之集合, <strong>&quot;page size = 一 frame size&quot;</strong></li></ol></li><li><p>圖：<img src="paged.png" alt=""></p></li><li><p>配置策略：</p><ol><li>Page 間採 &quot;不連續&quot; 存放</li><li>Process 為 n 個 page 時, 當 free frames &gt;= n 個即可配置 (No 外部碎裂, 夠就一定可以給)</li><li>O.S. 替各 process 準備一 page table, 存放 <strong>page 跟 frame 之對應</strong></li></ol></li><li><p>例：一 program = 19k, frame size = 4k, 則</p><ol><li>需多少 page?</li><li>內部碎裂 = ?</li><li>Page Table 的 entry size = 4 bytes, 問 Page Table 大小 ?<br>Sol:<ol><li>5 個, 需整數</li><li>5 * 4k = 20k, 20k - 19k = 1k</li><li><code>19k -&gt; page size = 4k</code>, <code>5 * 4 bytes = 20 bytes</code></li></ol></li></ol></li></ul><h4>Logical address 對應 Physical address 的方式</h4><ul><li>圖：<img src="logical%E5%B0%8D%E6%87%89.png" alt=""></li><li>Ex: 8 frames, each frame size = 4, 一 process 的 Page Table 如下：問<ol><li>logical address 7 跟 13 的 physical address = ?</li><li>logical 跟 physical address 表示需幾 bits ?<br>Sol:</li><li><img src="ex%E8%A7%A3%E6%B3%951.png" alt=""></li><li><img src="ex%E8%A7%A3%E6%B3%952.png" alt=""></li></ol></li></ul><h4>Page table 的存放製作方式</h4><ol><li>存 register<ul><li>優點：速度快</li><li>缺點：容量大, 不適用 register 小</li></ul></li><li>存 memory<ul><li>優點：容量大, 適用</li><li>缺點：每次需做 2 次的 memory 存取 (第一次抓 P.T, 第二次抓 data)</li><li>作法： <img src="%E5%AD%98%E6%94%BE2.png" alt=""></li></ul></li><li><strong>TLB 方式 Translation look-aside Buffer</strong><ul><li>由高速的關聯是暫存器組成</li><li>其各個的內容為：<ul><li>key: 存 page number (p)</li><li>value: 存 frame number (f)</li></ul></li><li>只存常用的 p, f 之對應 <strong>(目前執行中的 process 方可存入 TLB 之中)</strong> (當如果只要有 process 更換或做了 context switching, TLB 內容需全部 refresh)</li><li><strong>採 TLB 之 effect memory access time 有效記憶體存取時間</strong><ul><li>公式：<code>h * (ta + ma) + (1 - h) * (ta + 2ma)</code><ul><li><code>h * (ta + ma)</code> 為<strong>命中所需時間</strong></li><li><code>(1 - h) * (ta + 2ma)</code> 為 <strong>沒命中</strong></li><li>h = hit ratio</li><li>ta = TLB access time</li><li>ma = Memory access time</li></ul></li><li>Note: <code>h * (ta + ma) + (1 - h) * (ta + 2ma)</code> =&gt; <strong>4-level page table</strong></li></ul></li></ul></li></ol><h3>Segment memory management 分段式記憶體管理</h3><ul><li>觀念：<ol><li>將 logical memory 視為一組 segment 之集合, <strong>各 segment 大小不一致</strong></li><li>和 user 對 memory 的看法一致, segment 可能是 main, subroutine...等</li></ol></li><li>圖：<img src="segmentManagement.png" alt=""></li><li>配置策略：<ol><li>Segment 之間採不連續性存放</li><li>單一 Segment 採 &quot;連續性&quot;配置 (<strong>有外部碎裂</strong>)</li><li>O.S. 會替各 process 準備一 Segment Table, 其中<ul><li>Base: 存段的起始位址</li><li>Limit: 段的大小</li></ul></li></ol></li></ul><hr><h2>Summary</h2><table><thead><tr><th style="text-align:left">分析</th><th style="text-align:center">Paged</th><th style="text-align:center">Segment</th></tr></thead><tbody><tr><td style="text-align:left">優點</td><td style="text-align:center">No 外部碎裂</td><td style="text-align:center">No 內部碎裂</td></tr><tr><td style="text-align:left">缺點</td><td style="text-align:center">有內部碎裂</td><td style="text-align:center">有外部碎裂</td></tr></tbody></table><ul><li><p><strong>相同點</strong>:</p><ol><li>支援 Memory 共享</li><li>支援 Memory 保護</li><li>支援 dynamic loading, linking, binding (動態繫結, 在執行期間可動態去翻轉記憶體位置)</li><li>需額外的 hardware support</li><li>執行較慢 (因為 logical -&gt; physical address)</li></ol></li><li><p>圖：<img src="summary.png" alt=""></p></li></ul><h2>Compare</h2><table><thead><tr><th style="text-align:center">Paged</th><th style="text-align:center">Segment</th></tr></thead><tbody><tr><td style="text-align:center">No 外部碎裂, 有內部碎裂</td><td style="text-align:center">No 內部碎裂, 有外部碎裂</td></tr><tr><td style="text-align:center">Page size 一致</td><td style="text-align:center">Segment 大小不一致</td></tr><tr><td style="text-align:center">和 user 看法不一致</td><td style="text-align:center">較一致</td></tr><tr><td style="text-align:center">需給單一量的 logical address</td><td style="text-align:center">需給 s, d (2 個量)</td></tr><tr><td style="text-align:center">不需做 d &lt; limit 之 check</td><td style="text-align:center">需 check d &lt; limit</td></tr><tr><td style="text-align:center">Memory 共享, 保護, 較不易</td><td style="text-align:center">較容易</td></tr></tbody></table><hr><h2>Page segment memory management 分頁是分段記憶體管理</h2><ul><li>觀念： 先分段, 在分頁 -&gt; 最終存 page</li><li>圖：<img src="%E5%88%86%E9%A0%81%E5%88%86%E6%AE%B5.png" alt=""></li><li>優點：<ol><li>No 外部碎裂</li><li>單一段可以 &quot;不連續性存放&quot;</li></ol></li><li>缺點：<ol><li>有內部碎裂</li><li>Table size 相當大 (因為 Segment Table 及 Page Table 皆需)</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.7 記憶體管理 (Memory Management)&lt;/h1&gt;
&lt;p&gt;圖：
&lt;img src=&quot;%E8%A8%98%E6%86%B6%E9%AB%94.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Memory Allocation Strategy 記憶體配
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="Memory Management" scheme="https://pingjing0628.github.io/tags/Memory-Management/"/>
    
      <category term="Page Memory Management" scheme="https://pingjing0628.github.io/tags/Page-Memory-Management/"/>
    
      <category term="Segment Memory Management" scheme="https://pingjing0628.github.io/tags/Segment-Memory-Management/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-程序間的溝通-part2</title>
    <link href="https://pingjing0628.github.io/2021/06/20/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A8%8B%E5%BA%8F%E9%96%93%E7%9A%84%E6%BA%9D%E9%80%9A-part2/"/>
    <id>https://pingjing0628.github.io/2021/06/20/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A8%8B%E5%BA%8F%E9%96%93%E7%9A%84%E6%BA%9D%E9%80%9A-part2/</id>
    <published>2021-06-20T03:41:23.000Z</published>
    <updated>2022-09-19T12:55:16.022Z</updated>
    
    <content type="html"><![CDATA[<h1>3.6 程序間的溝通 (Process Communication)</h1><p>又稱為 <strong>inter-process communication</strong> IPC<br>方法有兩種：</p><ol><li>Shared Memory</li><li>Message Passing<br>圖：<img src="3.6.png" alt=""></li></ol><h2>目錄</h2><ul><li>Shared Memory</li><li><strong>Message Passing</strong></li></ul><hr><h2>Message Passing (訊息傳遞)</h2><ul><li>Def: 當 process 之間不易採用 Shared Memory, 則可採 Message Passing</li><li>步驟:<ol><li>先建立雙方連結</li><li>將 Message send 到收方</li><li>待收方處理後將結果接收 (receive)<br><img src="messagePass.png" alt=""></li></ol></li><li>可分為:<ul><li>直接通訊:<ul><li>對稱: 收, 送雙方皆須指名<br>ex: <code>send (process, message), receive (process, message)</code></li><li>非對稱: 送方須指名, 收方不需<br>ex: <code>send (process, message), receive (id, message)</code>, id 為接收後帶入送方的身份</li></ul></li><li>間接通訊:<ul><li>圖: <img src="messagepass2.png" alt=""></li></ul></li></ul></li></ul><ul><li>Ex: 用 Message Passing 解決 Producer (生產者 P1) / Consumer (消費者 P2) 問題 (<strong>直接通訊, 對稱式</strong>)</li></ul><pre><code>// 拿筷子wait (right);wait (left);C.S. // eatingsignal (right);siganl (left);R.S. // 放下筷子</code></pre><p><strong>Hold and wait</strong><br><strong>Circular waiting</strong><br><strong>當同時執行時, 會有 deadlock 現象, 故違反 progress</strong></p><p><strong>流程：... produce item; ...-&gt; 1. send(consumer, item); ...-&gt; 2. receive(producer, item); ...-&gt; 3. consume item;</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.6 程序間的溝通 (Process Communication)&lt;/h1&gt;
&lt;p&gt;又稱為 &lt;strong&gt;inter-process communication&lt;/strong&gt; IPC&lt;br&gt;
方法有兩種：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shared Memory&lt;/l
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Message Passing" scheme="https://pingjing0628.github.io/tags/Message-Passing/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-程序間的溝通-part1</title>
    <link href="https://pingjing0628.github.io/2021/06/20/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A8%8B%E5%BA%8F%E9%96%93%E7%9A%84%E6%BA%9D%E9%80%9A-part1/"/>
    <id>https://pingjing0628.github.io/2021/06/20/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A8%8B%E5%BA%8F%E9%96%93%E7%9A%84%E6%BA%9D%E9%80%9A-part1/</id>
    <published>2021-06-20T03:41:20.000Z</published>
    <updated>2022-09-19T12:55:13.122Z</updated>
    
    <content type="html"><![CDATA[<h1>3.6 程序間的溝通 (Process Communication)</h1><p>又稱為 <strong>inter-process communication</strong> IPC<br>方法有兩種：</p><ol><li>Shared Memory</li><li>Message Passing<br>圖：<img src="3.6.png" alt=""></li></ol><h2>目錄</h2><ul><li><strong>Shared Memory</strong></li><li>Message Passing</li></ul><hr><h2>Shared Memory 分享記憶體</h2><p>Def: 指多個 process 藉由共用相同的 memory space 達到行程間溝通之效 (Multiprocessor)<br>問題：<strong>Race Condition 競爭情況</strong><br>Def: 相同的運作. 因執行順序不同, 造成處理的結果不同謂之<br>解決：<strong>Critical Section 臨界區間</strong><br>Def: 為一程式片段, 用來提供多 process 共用一 memory space 時的存取控管機制 =&gt; <strong>避免 race conditional</strong></p><h3>Critical Section Design</h3><p>格式：<br><img src="C.S.png" alt=""><br>良好的 C.S Design 需滿足：</p><ol><li>Mutual exclusion (互斥)：指同一時間只允許一個 process 進入 C.S.</li><li>Progress (可進行性)：不想進 C.S. 的 process, 不能影響其他欲進入 C.S. 之 process<ul><li>若有多個 process 欲進入 C.S., 則挑選的時間是有限的 =&gt; <strong>避免 deadlock</strong></li></ul></li><li>Bounded waiting (有限性等待)：指 n 個 process 存在於進入 C.S., 最多只需 wait n-1 次 =&gt; <strong>公平, No starvation</strong></li></ol><h3>C.S. Design 目錄</h3><ul><li>algo<ul><li>2 process =&gt; 3 algos (<strong>turn, flag</strong>)</li><li>2 process =&gt; 1 algos (<strong>turn + flag</strong>)</li></ul></li><li>Semaphore<ul><li>Binary</li><li>Counting</li></ul></li></ul><hr><h3>2 個 process 的 C.S. Design</h3><h4>algorithm1:</h4><ul><li>資料結構 (宣告變數)：<br><code>var turn: integer (0~1);</code></li><li>Pi 之程式片段：<br><img src="algo1.png" alt=""></li><li>分析：<ol><li>滿足 mutual exclusion (互斥)<br>說明：<br>當 Pi, Pj 皆欲進入 C.S., 又 turn 不會同時為 i, j (因為 i 不等於 j), 故只能一個 process 進入 C.S.</li><li>不滿足 progress (可進行性)<br>說明：<br>當 Pj 於 R.S. 中 (因為 j 就是不想上廁所), 但 <code>turn = j</code>, 此時若 Pi 想進入 C.S., 將被卡在 while loop 中無法進入 (因為違反 progress)</li></ol></li></ul><h4>algorithm2:</h4><ul><li><p>資料結構：<br><code>var flag [0...1] of Boolean;</code><br><img src="algo2Data.png" alt=""></p></li><li><p>Pi 之程式片段：<br><img src="algo2.png" alt=""></p></li><li><p>分析：</p><ol><li>滿足 mutual exclusion (互斥)<br>說明：<br>若欲使 Pi, Pj 同時進入 C.S., 則 <code>flag[i] = flag[j] = false</code>, 又當欲進入 C.S. 一開始 flag, 會改為 true, 故上述情況不可能存在</li><li>不滿足 progress (可進行性)<br>說明：<br>當 Pi, Pj 皆欲進入 C.S., 則 <code>flag[i] = flag[j] = true</code>, 此時 2 者皆會卡在 while loop 中 =&gt; deadlock, 故違反 progress</li></ol></li><li><p>中山<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag[i] &#x3D; true;</span><br><span class="line">while (flag[j]) do no-op;</span><br></pre></td></tr></table></figure>若交換上述兩行程式, 會發生什麼事？<br>Ans: 違反互斥性, 變成先問對方在舉手</p></li></ul><h4>algorithm3:</h4><ul><li><p>資料結構：<br><img src="algo3Data.png" alt=""></p></li><li><p>Pi 之程式片段：<br><img src="algo3.png" alt=""></p></li><li><p>分析：</p><ol><li>滿足 mutual exclusion (互斥)<br>說明：<br>當 2 process 皆欲進入 C.S., 則 <code>flag[i] = flag[j] = true</code>, 但 turn 不會同時為 i, j (因為 i 不等於 j), 故只有一 process 可進入 C.S.</li><li>滿足 progress (可進行性)<br>說明：<ul><li>當 Pj 不想進入 C.S., 又 <code>turn = j</code>, 且此時 <code>flag[j] = false</code>, 故當 Pi 想進入, 可以順利通過 while loop</li><li>當 2 process 皆欲進入 C.S., 此時視 turn 的值為 i 或 j, 指向者可進入 C.S., 所以 No deadlock</li></ul></li><li>滿足 Bounded Waiting (有限性等待)<br>說明：<br>當 Pi, Pj 皆欲進入 C.S., 而 <code>turn = j</code>時, 則 Pj 可進入, 若 Pj 離開後立即再度欲進入 C.S., 則：<br><code>flag[j] = true;</code><br><code>turn = i</code><br>因為 <code>turn = i</code>, 故下次必由 Pj 進入 C.S. 中</li></ol></li></ul><hr><h3>多 process 的 C.S. Design =&gt; Bakery's algorithm</h3><ul><li><p>資料結構：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var choosing: Array[0....n-1] of Boolean;</span><br><span class="line">    number: Array[0....n-1] of Integer; (initial 皆為 0)</span><br></pre></td></tr></table></figure></p></li><li><p>數字假設：</p><ol><li><code>(a, b) &lt; (c, d)</code>, if<ol><li><code>a &lt; c</code> or</li><li><code>a = c</code> 且 <code>b &lt; d</code></li></ol></li><li><code>Max(X0...Xn-1)</code> =&gt; 取 X0 ~ Xn-1 中最大值</li></ol></li><li><p>Pi 之程式片段：<img src="%E5%A4%9Aprocess.png" alt=""></p></li></ul><hr><h3>Semaphore (號誌) (可有互斥的效果)</h3><ul><li>Def: 為解決同步問題的一種機制, 本身為一整數型別 (通常初始為 1), <strong>會提供 2 個 atomically execution (不可分割, 指過程中不能被中斷) 的運作</strong><ul><li>signal</li><li>wait</li></ul></li><li>圖：<br><img src="semaphore.png" alt=""></li><li>Note:<br>Semaphore 初始值為 1 時, 則狀態永遠為 0 或 1, 故 Pj 謂之 <strong>Binary Semaphore (二元號誌)</strong></li></ul><h3>Counting Semaphore (計數號誌)</h3><p>Def: 有別於 Binary Semaphore, 於 counting semaphore 之中, 值可能為 1, 0, -1, -2....-n, <strong>若值為 -n, 代表有 n 個 process 卡在 wait 之中</strong><br>=&gt; 製作方式：</p><ol><li>用 Block, wakeup 製作</li><li>用 Binary Semaphore 製作</li></ol><h4>&lt;法一&gt;：用 Block, wakeup 及 Queue 製作</h4><ul><li>作法：將 Semaphore 定義成一 Record (紀錄) (like class)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type countingSemaphore: record</span><br><span class="line">    value: integer; &#x2F;&#x2F;initial &#x3D; 1</span><br><span class="line">    L: Queue;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li></ul><p><img src="way1.png" alt=""></p><h4>&lt;法二&gt;：用 Binary Semaphore 製作出 counting semaphore</h4><ul><li>資料結構：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var c: integer; initial &#x3D; 1 &#x2F;&#x2F; 計數器, like value, c 當 signal &amp; wait</span><br><span class="line">    S1: Binary Semaphore; initial &#x3D; 1 &#x2F;&#x2F; 對 C 做存取控制</span><br><span class="line">    S2: Binary Semaphore; initial &#x3D; 0 &#x2F;&#x2F; 用來模擬 block, wakeup 之效</span><br></pre></td></tr></table></figure></li></ul><p><img src="way2.png" alt=""></p><h4>Compare</h4><table><thead><tr><th style="text-align:left">Compare</th><th style="text-align:left">busy waiting (spinlock 盤旋鎖) 製作 counting semaphore (簡單的會使用)</th><th style="text-align:left">Block, wakeup 製作 (複雜的通常用)</th></tr></thead><tbody><tr><td style="text-align:left">優點</td><td style="text-align:left">wait 時不會有 context switching, 若為片刻等待, 適用</td><td style="text-align:left">wait 時不會用至 CPU</td></tr><tr><td style="text-align:left">缺點</td><td style="text-align:left">在 waiting 過程中, 會不斷的耗用 CPU 的資源, 所以浪費 CPU</td><td style="text-align:left">需 context switching</td></tr></tbody></table><hr><h3>思考</h3><p><img src="think.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.6 程序間的溝通 (Process Communication)&lt;/h1&gt;
&lt;p&gt;又稱為 &lt;strong&gt;inter-process communication&lt;/strong&gt; IPC&lt;br&gt;
方法有兩種：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shared Memory&lt;/l
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Shared Memory" scheme="https://pingjing0628.github.io/tags/Shared-Memory/"/>
    
      <category term="Critical Section" scheme="https://pingjing0628.github.io/tags/Critical-Section/"/>
    
      <category term="Semaphore" scheme="https://pingjing0628.github.io/tags/Semaphore/"/>
    
      <category term="Counting Semaphore" scheme="https://pingjing0628.github.io/tags/Counting-Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-死結deadlock-part2</title>
    <link href="https://pingjing0628.github.io/2021/06/19/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E6%AD%BB%E7%B5%90deadlock-part2/"/>
    <id>https://pingjing0628.github.io/2021/06/19/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E6%AD%BB%E7%B5%90deadlock-part2/</id>
    <published>2021-06-19T03:16:05.000Z</published>
    <updated>2022-09-19T12:54:50.152Z</updated>
    
    <content type="html"><![CDATA[<h1>3.5 死結 Deadlock</h1><h2>目錄</h2><ul><li>四要件</li><li><strong>Deadlock 處理方式</strong></li><li><strong>Deadlock Free</strong></li></ul><hr><h2>deadlock 處理</h2><ol><li>Preventation 預防：欲使 deadlock 不會發生<br>作法：大破四要件之一</li><li>Avoidance 避免：利用避免演算法確保資源分配不會產生 deadlock<br>作法：Banker's algo. check 安全否</li><li>Detection &amp; Recovery 偵測, 若有恢復</li></ol><h3>Deadlock Preventation =&gt; 打破四要件之一 (打破其中一個即可)</h3><ol><li><strong>打破 &quot;互斥&quot;</strong></li></ol><ul><li><strong>難達成, 因為此為資源先天的限制</strong>, ex: 印表機</li></ul><ol start="2"><li><strong>打破 &quot;Hold and Wait&quot;</strong> (要就全拿, 不要就都不拿)</li></ol><ul><li>作法 1: process 若無法取得, 所需的所有資源, 則需空手</li><li>作法 2: 提出申請時, 需將手中持有的資源 release</li><li>圖：<img src="%E6%89%93%E7%A0%B4Hold&amp;wait.png" alt=""></li></ul><ol start="3"><li><strong>打破 &quot;No preemptive&quot; =&gt; 將之改為 preemptive</strong></li></ol><ul><li>不建議, 因為資源先天限制, ex: 印表機, 印了 3 行被搶奪</li></ul><ol start="4"><li><strong>打破 Circular Waiting</strong></li></ol><ul><li>作法 1:<ul><li>給予各 resource 一獨立編號</li><li>資源申請須以編號遞增的方式提出</li><li>圖：<img src="%E6%89%93%E7%A0%B4circular1.png" alt=""><img src="%E6%89%93%E7%A0%B4circular2.png" alt=""></li></ul></li><li>反證：令仍然會有 Circular waiting, 假設滿足 2 條件下, 則存在如下的 waiting cycle:<img src="%E5%8F%8D%E8%AD%89.png" alt=""></li></ul><h3>Deadlock Avoidance</h3><ul><li>圖：<img src="deadlockAvoidance.png" alt=""></li><li>Note:<ul><li>Safe state (安全狀態):<br>指可以找到 &gt;= 1 組執行順序, 確保所有的 process 皆可執行完畢<br>Ex: 5 process (P0 ~ P4) =&gt; <code>P2-&gt;P4-&gt;P1-&gt;P0-&gt;P3</code></li><li>Unsafe state:<br>指找不到上述一組執行的順序謂之<br>Ex: <code>P2-&gt;P4-&gt;.....?</code></li></ul></li></ul><h4>Avoidance algo.</h4><ul><li><p>資源皆單一量 =&gt; 修改資源分配圖</p></li><li><p>資源非單一量 =&gt; Banker's algo. <code>m * n^2</code>, O(n^2) 效率較佳</p><ul><li>m = 資源種類數 (印表機, disk, 螢幕) , n = process 數量</li></ul></li><li><p>Note: Resource Allocation Graph 資源分配圖<br>Def: 一圖形 G = &lt;V, E&gt;, 其中 V 為頂點, E 為邊</p><ul><li>V 分為：<img src="V.png" alt=""></li><li>E 分為：<img src="E.png" alt=""></li><li>在 Resource Allocation Graph 中的性質<ol><li>當資源皆為單一量 -&gt; 有 cycle, 有 deadlock</li><li>當資源非單一量 -&gt; 有 cycle, &quot;不見得有 deadlock&quot;<ul><li>圖：<img src="resourceAllocate.png" alt=""></li></ul></li></ol></li></ul></li></ul><ol><li>資源皆為單一量的 avoidance algo.<br>於 Resource Allocation Graph 中多加入一種邊 &quot;chian edge&quot; 鏈結邊, Pi...Rj =&gt; 指 Pi 在未來會對 Rj 提出申請<ul><li>判別： <strong>Pi 正式對 Rj 提申請</strong><ol><li>先作暫時性配置<br><img src="PiToRj.png" alt=""></li><li>Check 是否有 cycle<ul><li>有 -&gt; Unsafe</li><li>無 -&gt; Safe</li></ul></li></ol></li><li>Ex: 若 P2 對 R2 正式提出申請, 是否可以？<br>圖：<img src="%E5%96%AE%E4%B8%80%E9%87%8Fex.png" alt=""><br>Sol: 有 cycle, 故 unsafe state, 所以申請駁回 (若 P1 則可以)</li></ul></li></ol><ol start="2"><li>Banker's algo. 題型<br>Ex: 系統有 5 個 process {P0...P4}, 三種 resource {A, B, C}, A = 10, B = 5, C = 7, 令時間 T0 時如下圖, 問若 P1 提出 Request1 = (1, 0, 2), 是否可配置？<br>圖：<img src="%E6%9A%AB%E6%99%82%E6%80%A7%E9%85%8D%E7%BD%AE1.png" alt=""><br>Sol:<ul><li><p>Step 1: Need = Max - Allocation (Need: 指 process i 最多尚需多少資源才能完成工作)</p></li><li><p>Step 2:<br>Request i (1, 0, 2) &lt;= Need i (1, 2, 2)<br>Request i (1, 0, 2) &lt;= Available i (3, 3, 2)</p></li><li><p>Step 3: 暫時性配置<br>圖：<img src="%E6%9A%AB%E6%99%82%E6%80%A7%E9%85%8D%E7%BD%AE2.png" alt=""></p></li><li><p>找執行順序：P1 -&gt; P3 -&gt; P4 -&gt; P0 -&gt; P2,<br>因為找到執行的順序, 故為 safe state =&gt; <strong>故申請核準</strong></p></li></ul></li></ol><hr><h3>Deadlock detection algo</h3><ul><li>資源皆單一量：<strong>修改資源分配圖 (&quot;Wait-for&quot; graph) =&gt; O(n^2)</strong></li><li>資源非單一量：<strong>deadlock detection algo. =&gt; O(m * n^2)</strong></li></ul><h4>Deadlock detection &amp; recovery (資源皆單一量 =&gt; 採&quot;Wait-for&quot; graph 等候圖)</h4><ul><li>Def: 定期偵測系統是否有 deadlock, 若有則須設法做 deadlock recovery 的動作</li><li>說明: 將 Resource Allocation Graph 中的<br><img src="desc.png" alt=""></li><li>Check: <code>有 cycle =&gt; 有 deadlock</code>, <code>No cycle =&gt; No deadlock</code></li><li>Ex:<img src="deadlockDetection.png" alt=""></li></ul><h4>Deadlock recovery</h4><ul><li>由 user 自己處理</li><li>由系統處理<ul><li>全砍：<ul><li>優點：簡單</li><li>缺點：成本高</li></ul></li><li>一次砍一個：<ul><li>優點：成本低</li><li>缺點：複雜</li></ul></li></ul></li></ul><hr><h2>deadlock free</h2><p>Def: 在此條件下, 系統沒有 deadlock 問題, 故不需對其做處理, <strong>欲滿足 deadlock free</strong>, 則：</p><ol><li>1 &lt;= Max i &lt;= m (資源數量)</li><li>總和(i=1至n) Max i &lt; m + n (n 為 process 數), <strong>process i 完成工作最多所需的資源數</strong></li></ol><p>Ex:</p><ul><li>6 台印表機 each process 完成工作最多需 ? 台 printer?</li><li>問系統中在 deadlock free 下, 最多可有多少 process ?<br>Sol:</li></ul><ol><li>1 &lt;= Max i &lt;= m =&gt; 1 &lt; <strong>2</strong> &lt;= 6</li><li>總和(i=1至n) Max i &lt; m + n =&gt; 2n &lt; 6 + n, 所以 n &lt; 6, 故 n 最大為 5</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.5 死結 Deadlock&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;四要件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deadlock 處理方式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deadlock Free&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Deadlock" scheme="https://pingjing0628.github.io/tags/Deadlock/"/>
    
      <category term="Deadlock free" scheme="https://pingjing0628.github.io/tags/Deadlock-free/"/>
    
      <category term="Starvation" scheme="https://pingjing0628.github.io/tags/Starvation/"/>
    
      <category term="Preventation" scheme="https://pingjing0628.github.io/tags/Preventation/"/>
    
      <category term="Avoidance" scheme="https://pingjing0628.github.io/tags/Avoidance/"/>
    
      <category term="Detection" scheme="https://pingjing0628.github.io/tags/Detection/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-死結deadlock-part1</title>
    <link href="https://pingjing0628.github.io/2021/06/18/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E6%AD%BB%E7%B5%90deadlock-part1/"/>
    <id>https://pingjing0628.github.io/2021/06/18/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E6%AD%BB%E7%B5%90deadlock-part1/</id>
    <published>2021-06-18T09:00:22.000Z</published>
    <updated>2022-09-19T12:54:46.364Z</updated>
    
    <content type="html"><![CDATA[<h1>3.5 死結 Deadlock</h1><h2>目錄</h2><ul><li><strong>四要件</strong></li><li>Deadlock 處理方式</li><li>Deadlock Free</li></ul><hr><h2>四要件</h2><ol><li><strong>Mutual Exclusion 互斥</strong><br>Def: 指資源同時只允許一個 process 使用之, ex: printer, card reader</li><li><strong>Hold &amp; Wait 持有並等待</strong><br>Def: 指一 process 取得部分資源, 又在等其他資源<br>圖：<img src="Hold&amp;wait.png" alt=""></li><li><strong>No preemptive</strong><br>Def: 指一旦 process 取得某資源, 則其他的 process 無法搶奪, 除非其自願放棄</li><li><strong>Circular waiting 循環式等待</strong><br>Def: 只存在一組 process, 形成如下的 waiting cycle:<br><img src="circularWaiting.png" alt="">Note: Pi -&gt; Pj =&gt; Process i 在等 Process j 手中的資源</li></ol><ul><li>Ex: 令資源具 Mutual Exclusiion 跟 No preemptive, 則<br><img src="deadlock.png" alt=""></li></ul><hr><h2>Compare</h2><table><thead><tr><th style="text-align:left">Description</th><th style="text-align:left">Deadlock</th><th style="text-align:left">Starvation</th></tr></thead><tbody><tr><td style="text-align:left">定義</td><td style="text-align:left">存在一組 process, 形成 wait cycle, 使 cycle 內之 process 皆不可使用 CPU (因為皆 wait)</td><td style="text-align:left">low priority 的 process 長期或無限期無法取得 CPU</td></tr><tr><td style="text-align:left">影響</td><td style="text-align:left">CPU utilization 跟 throughput 大幅下降</td><td style="text-align:left">不見得</td></tr><tr><td style="text-align:left">起因</td><td style="text-align:left">資源分配不當</td><td style="text-align:left">當有 priority 之分</td></tr><tr><td style="text-align:left">解決</td><td style="text-align:left">deadlock 預防, 避免, 偵測與恢復</td><td style="text-align:left">Aging Tech 老化現象</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.5 死結 Deadlock&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;四要件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Deadlock 處理方式&lt;/li&gt;
&lt;li&gt;Deadlock Free&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;四要件&lt;/h2
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Deadlock" scheme="https://pingjing0628.github.io/tags/Deadlock/"/>
    
      <category term="Deadlock free" scheme="https://pingjing0628.github.io/tags/Deadlock-free/"/>
    
      <category term="Starvation" scheme="https://pingjing0628.github.io/tags/Starvation/"/>
    
      <category term="Preventation" scheme="https://pingjing0628.github.io/tags/Preventation/"/>
    
      <category term="Avoidance" scheme="https://pingjing0628.github.io/tags/Avoidance/"/>
    
      <category term="Detection" scheme="https://pingjing0628.github.io/tags/Detection/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-行程-part3</title>
    <link href="https://pingjing0628.github.io/2021/06/12/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A1%8C%E7%A8%8B-part3/"/>
    <id>https://pingjing0628.github.io/2021/06/12/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A1%8C%E7%A8%8B-part3/</id>
    <published>2021-06-12T15:43:16.000Z</published>
    <updated>2022-09-19T12:54:59.531Z</updated>
    
    <content type="html"><![CDATA[<h1>3.4 行程</h1><h2>目錄</h2><ul><li>Process Definition</li><li>Program vs Process</li><li>Process STD</li><li>PCB, context switching</li><li>CPU Scheduling algorithm</li><li><strong>Thread 執行緒</strong></li></ul><hr><h2>Thread (執行緒) (為執行的最小單位)</h2><p><img src="processvsthread.png" alt=""></p><h2>Compare process and thread</h2><table><thead><tr><th style="text-align:left">Process</th><th style="text-align:left">Thread</th></tr></thead><tbody><tr><td style="text-align:left">Heavy weight process</td><td style="text-align:left">Light weight process</td></tr><tr><td style="text-align:left">各 process 無法共享：Memory space, O.S. Resource, Files</td><td style="text-align:left">同一 Task 中的 Threads 可共用</td></tr><tr><td style="text-align:left"><strong>Context Switching 重</strong></td><td style="text-align:left"><strong>Context Switching 輕</strong></td></tr><tr><td style="text-align:left">相當於一 Task 中, 只有 single thread</td><td style="text-align:left">有 <strong>multithread</strong> 多執行緒系統</td></tr><tr><td style="text-align:left">較不易發揮</td><td style="text-align:left">在 <strong>Multiprocessor 的架構</strong>, 可充分發揮其效能</td></tr><tr><td style="text-align:left">因為無共享 Memory, 故不需處理 Race condition</td><td style="text-align:left">會共享 Memory, 故須針對 <strong>Race Condition 競爭情況</strong> 作處理</td></tr></tbody></table><hr><h2>Thread (執行緒) 製作方式</h2><ul><li>User level: 由 user-level 自行處理, 藉由執行緒程式庫來對 thread 之運作加以管理, kernel 不需介入</li><li>Kernel level: 由 kernel-level 著手處理 thread 的相關運作<br><img src="thread%E8%A3%BD%E4%BD%9C%E6%96%B9%E5%BC%8F.png" alt=""></li></ul><hr><h2>Compare multitasking and multithreading</h2><p><img src="multitaskingvsmultithreading.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.4 行程&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Process Definition&lt;/li&gt;
&lt;li&gt;Program vs Process&lt;/li&gt;
&lt;li&gt;Process STD&lt;/li&gt;
&lt;li&gt;PCB, context switching&lt;/li
      
    
    </summary>
    
    
      <category term="Note" scheme="https://pingjing0628.github.io/categories/Note/"/>
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
      <category term="作業系統" scheme="https://pingjing0628.github.io/categories/Note/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Process" scheme="https://pingjing0628.github.io/tags/Process/"/>
    
      <category term="Thread" scheme="https://pingjing0628.github.io/tags/Thread/"/>
    
      <category term="Multitasking" scheme="https://pingjing0628.github.io/tags/Multitasking/"/>
    
      <category term="Multithreading" scheme="https://pingjing0628.github.io/tags/Multithreading/"/>
    
  </entry>
  
</feed>
