<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PinJing&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pingjing0628.github.io/"/>
  <updated>2022-04-20T15:00:18.686Z</updated>
  <id>https://pingjing0628.github.io/</id>
  
  <author>
    <name>PinJing Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chapter5-程式介紹-物件導向概論</title>
    <link href="https://pingjing0628.github.io/2022/04/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E6%A6%82%E8%AB%96/"/>
    <id>https://pingjing0628.github.io/2022/04/20/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E6%A6%82%E8%AB%96/</id>
    <published>2022-04-20T15:00:18.000Z</published>
    <updated>2022-04-20T15:00:18.686Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-C語言重點</title>
    <link href="https://pingjing0628.github.io/2021/07/08/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C%E8%AA%9E%E8%A8%80%E9%87%8D%E9%BB%9E/"/>
    <id>https://pingjing0628.github.io/2021/07/08/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-C%E8%AA%9E%E8%A8%80%E9%87%8D%E9%BB%9E/</id>
    <published>2021-07-08T09:10:18.000Z</published>
    <updated>2022-04-26T14:55:16.157Z</updated>
    
    <content type="html"><![CDATA[<h1>5.2 C 語言重點</h1><hr><h2>C Language</h2><ul><li>結構<ul><li>xxx.c</li><li>header: 表頭</li><li>body: object code</li></ul></li><li>Ex:<code># include &lt;stdio.h&gt;</code> =&gt; stdio.h 為 linker, 外部函式庫之 header file</li></ul><h2>變數 vs 常數</h2><table><thead><tr><th>Variable</th><th>Constant</th></tr></thead><tbody><tr><td>會隨著執行而更動的數值</td><td>不變</td></tr><tr><td>佔用 memory space 來存取</td><td>不需</td></tr><tr><td>int x;</td><td>ex: 'a' or 100</td></tr></tbody></table><ul><li>Note: 常數變數 (constant variable)<br>Define: <code>const int x = 10;</code></li></ul><h2>變數宣告</h2><p>格式： <code>type (space) variable;</code><br>ex: int x;</p><h2>Compare Static typed and Dynamic typed</h2><table><thead><tr><th>Static typed</th><th>Dynamic typed</th></tr></thead><tbody><tr><td>宣告時, 即需決定 data 之型態</td><td>不需, runtime 才決定</td></tr><tr><td>int x;</td><td>var x; x = 100;</td></tr><tr><td>java, C, C++</td><td>javascript, ruby</td></tr></tbody></table><h2>常見的 data type 介紹</h2><ol><li>boolean (布林):</li></ol><ul><li>只有兩種狀態:<ul><li>true</li><li>false</li></ul></li><li>Ex: <code>bool flag;</code></li></ul><ol start="2"><li>character (字元):</li></ol><ul><li>利用 &quot;ASCII&quot; 來存放</li><li>佔用 1 byte memory space</li><li>常見字元編碼<ul><li>'0' =&gt; (48)10</li><li>'A' =&gt; (65)10</li><li>'a' =&gt; (97)10</li></ul></li><li>Ex: <code>char c1;</code></li><li>Note:</li></ul><table><thead><tr><th>character</th><th>string</th></tr></thead><tbody><tr><td>由一字母或數字組成</td><td>由 1~多個組成</td></tr><tr><td>用單引號括住</td><td>用雙引號括住</td></tr><tr><td>'a', 'B'(對), &quot;B&quot;(錯)</td><td>&quot;hello&quot;(對), 'hello'(錯)</td></tr></tbody></table><ol start="3"><li>integer (整數):</li></ol><ul><li>利用 4 bytes 表示</li><li>Ex: <code>int x;</code></li><li>除法:<ul><li>&quot;/&quot; =&gt; 取商, <code>x = 6/4</code></li><li>&quot;%&quot; =&gt; 取餘, <code>y = 6%4</code></li></ul></li></ul><ol start="4"><li>浮點數:</li></ol><table><thead><tr><th>float</th><th>double</th></tr></thead><tbody><tr><td>single precision</td><td>double precision</td></tr><tr><td>32 bits, 佔用 4 bytes</td><td>使用 8 bytes</td></tr><tr><td>float f;</td><td>double d;</td></tr></tbody></table><ul><li>ex:<ol><li><code>float f1 = 3.2/4;</code> =&gt; 0.8</li><li><code>float f2 = 5/4;</code> =&gt; 1.0</li><li><code>float f3 = 5.0/4;</code> =&gt; 1.25</li><li><code>float f4 = (float)5/4;</code> =&gt; 1.25 =&gt; 強制將 5 視為浮點數, <strong>強制轉型 casting</strong></li></ol></li><li>Note:<ol><li>在 c, c++中, 運算是會以最大型別來求得結果<ul><li>ex: int * double + float = ? =&gt; output <strong>double</strong></li></ul></li><li>浮點數, 預設為 <strong>double</strong> 之型態 (因為失真少, 結尾誤差少)<ul><li>ex: 3.14 * 2.56 + 3.2 =&gt; double</li></ul></li></ol></li></ul><blockquote><p>NOTE: type range =&gt; byte &lt; short &lt; int &lt; long &lt; float &lt; double</p></blockquote><h2>變數種類</h2><table><thead><tr><th>local variable</th><th>global variable</th></tr></thead><tbody><tr><td>於 block 或 函式之中宣告</td><td>於 block 或 函式之外宣告</td></tr><tr><td>僅能在所屬的 block 之內使用</td><td>全部block都可用</td></tr><tr><td>於 block 一結束, 即清除</td><td>整個程式結束才清除</td></tr></tbody></table><ul><li>static variable</li></ul><h2>變數的存取順序</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">全域變數</span><br><span class="line">3.&#123;</span><br><span class="line">    2.&#123;</span><br><span class="line">        1.&#123;</span><br><span class="line">            print(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>先找自身區塊</li><li>若 1 無, 往外層找</li><li>若 2 無, 往 global 找</li></ol><ul><li><p>Note: dynamic scoping =&gt; 依程式執行時的呼叫順序 (runtime) 來決定找尋順序, <code>main() -&gt; A() -&gt; B()</code> =&gt; 找B找不到, 找A, 在找不到找 main</p></li><li><p>Ex1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 10; &#x2F;&#x2F;global</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    int y &#x3D; 5;</span><br><span class="line">    &#123;</span><br><span class="line">        int x &#x3D; 20;</span><br><span class="line">        int z &#x3D; 8;</span><br><span class="line">        printf(&quot;%d&quot;, x); &#x2F;&#x2F; x&#x3D;20, 用完即清除</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, x); &#x2F;&#x2F; x&#x3D;10</span><br><span class="line">    printf(&quot;%d&quot;, z); &#x2F;&#x2F; compile error</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 20;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int y &#x3D; 10;</span><br><span class="line">    fun(y);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">void fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int y &#x3D; 30;</span><br><span class="line">    printf(&quot;%d, %d&quot;, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Ans: (20, 30)</p></li><li><p>Note: 在 C 語言裡, 只要不是指標, 就是 call by-value</p></li><li><p>local variable =&gt; 與 function 一樣, 用 stack 放 =&gt; 後進先出</p></li></ul><h2>Standard I/O library 標準輸出/輸入函式庫</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.2 C 語言重點&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;C Language&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;結構
&lt;ul&gt;
&lt;li&gt;xxx.c&lt;/li&gt;
&lt;li&gt;header: 表頭&lt;/li&gt;
&lt;li&gt;body: object code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="C" scheme="https://pingjing0628.github.io/tags/C/"/>
    
      <category term="運算子" scheme="https://pingjing0628.github.io/tags/%E9%81%8B%E7%AE%97%E5%AD%90/"/>
    
      <category term="位元運算" scheme="https://pingjing0628.github.io/tags/%E4%BD%8D%E5%85%83%E9%81%8B%E7%AE%97/"/>
    
      <category term="Pointer" scheme="https://pingjing0628.github.io/tags/Pointer/"/>
    
      <category term="雙重指標" scheme="https://pingjing0628.github.io/tags/%E9%9B%99%E9%87%8D%E6%8C%87%E6%A8%99/"/>
    
      <category term="Structure Programming Language" scheme="https://pingjing0628.github.io/tags/Structure-Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5-程式介紹-基本介紹</title>
    <link href="https://pingjing0628.github.io/2021/07/05/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/"/>
    <id>https://pingjing0628.github.io/2021/07/05/Chapter5-%E7%A8%8B%E5%BC%8F%E4%BB%8B%E7%B4%B9-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/</id>
    <published>2021-07-05T09:30:35.000Z</published>
    <updated>2022-04-20T15:02:42.696Z</updated>
    
    <content type="html"><![CDATA[<h1>5.1 基本介紹</h1><hr><h2>Programming Language 程式語言</h2><table><thead><tr><th>年代</th><th>特徵1</th><th>特徵2</th><th>特徵3</th><th>特徵4</th><th>特徵5</th></tr></thead><tbody><tr><td>1GL (Machine Language)<strong>低階語言</strong></td><td>由 0, 1 組成</td><td>為機器能直接執行的語言</td><td>user 不易理解</td><td></td><td></td></tr><tr><td>2GL (Assembly Language)<strong>低階語言</strong></td><td>提供簡易的符號供 user 使用</td><td>用 &quot;assembler&quot; 將之轉成 object code</td><td>Ex: ADD R1 3 <strong>=&gt; 將 3 加到 Register R1 中</strong></td><td></td><td></td></tr><tr><td>3GL (High-Level Language)<strong>高階語言</strong></td><td>提供更多貼近 user 的指令</td><td>多為程序導向的程式語言 (procedural language -&gt; tell &quot;how&quot; to do)</td><td>Ex: <code>int i = 3 + 5;</code></td><td>代表：C (具 self-compile), PASCAL, FURTRAN, COBOL, BASIC, C++, JAVA, .NET</td><td>C 語言：  1. compile 完的 object code, 不能跨平台  2. 此邊是語法, 故可跨平台</td></tr><tr><td>4GL (Non-procedural Language) 非程序導向<strong>高階語言</strong></td><td>又稱為<strong>宣告式語言 (Declaractive Language)</strong> -&gt; tell &quot;what&quot; to do</td><td>代表：SQL, report generator</td><td>Ex: <code>Select height From student where height &gt;= 180</code></td><td></td><td></td></tr><tr><td>5GL (Natural Language) 自然語言<strong>高階語言</strong></td><td>使用到人工智慧的技術</td><td>為機器能直接執行的語言</td><td>代表：LISP, PROLOG</td><td></td><td></td></tr></tbody></table><h3>種類</h3><table><thead><tr><th>種類</th><th>代表性程式語言</th><th>備註</th></tr></thead><tbody><tr><td>Interpreter language 直譯</td><td>Basic, Java, Javascript, ASP, PHP, JSP, ruby, groovy, python</td><td></td></tr><tr><td>Compile language 編譯</td><td>C, C++, FURTRAN, PASCAL, COBAL -&gt; 先編譯成 object code</td><td>java, javascript 沒有關係</td></tr><tr><td>先 compile, 後 interpreter -&gt; p-code, java</td><td>跨平台 (cross-platform)</td><td></td></tr><tr><td>Object Oriented Programming (OOP)</td><td>java, C++, C#, .NET, javascript, ruby, python, groovy, VB, smalltalk, Ada</td><td></td></tr><tr><td>Functional Programming Language (函式編程語言) FPL</td><td>LISP, ML, F#</td><td>適用於平行運算, 以 function 為 first class, 各 function 間 No side effect</td></tr></tbody></table><h2>funtion (函式) =&gt; C, C++, Java</h2><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return type   function name  parameter list</span><br><span class="line">&#123;</span><br><span class="line">    function code (body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>return type</code> : 回傳型態 <strong>output</strong></li><li><code>function name</code>: in c, c++ 中 main 代表主程式</li><li><code>parameter List</code>: 參數串列, 接收外界呼叫時須引入的參數 <strong>input</strong></li><li><code>function code</code> <strong>process</strong></li></ol><h2>funtion calling (呼叫)</h2><ul><li>格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">funA()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    ...</span><br><span class="line">    funcB(a, b) &#x2F;&#x2F; (a, b 為 actual parameter 實際參數 AP)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funB(x, y) &#x2F;&#x2F; (x, y 為 foraml parameter 型式參數 FP)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>參數傳遞 (funcB in funcA)</li><li>funcB execute</li><li>funcB return</li></ol><h2>參數傳遞種類</h2><table><thead><tr><th>Call by value</th><th>Call by address</th><th>Call by name</th><th>Call by value-result</th></tr></thead><tbody><tr><td>AP 跟 FP 佔用不同的 memory space</td><td>操作相同 Memory space</td><td>AP 會直接取代 FP 之所在</td><td>在 function 最後結束時, 將 FP 寫回對應 AP 之內容</td></tr><tr><td>No side effect</td><td>有</td><td>有</td><td>有</td></tr><tr><td>binding 速度慢 (最慢)</td><td>最快</td><td>居中</td><td></td></tr><tr><td>不適合用於結構型資料的參數傳遞</td><td>適合</td><td></td><td></td></tr></tbody></table><ul><li>Ex1:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">    fun(a, b);</span><br><span class="line">    print(a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    x &#x3D; 3;</span><br><span class="line">    y &#x3D; 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>問分別採 1. call by value 2. call by address 3. call by value result, output = ? a = ? b = ?<br><strong>Sol:</strong></p><ol><li>a=10, b=20</li><li>x, y 為記錄 a, b 的位址, 並指回原變數。Ans: a=3, b=6</li><li><strong>最後結束時會將 FP 寫回對應 AP 之內容</strong>, 具 side effect(砍掉前，將最後的值抓回)。Ans: a=3, b=6</li></ol><ul><li>Ex2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 4, b &#x3D; 6;</span><br><span class="line">    fun(a, b, a+b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">    x &#x3D; 7;</span><br><span class="line">    y &#x3D; 10;</span><br><span class="line">    int t &#x3D; z * z;</span><br><span class="line">    printf(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>問採 1. call by name? 2. call by address?<br><strong>Sol:</strong></p><ol><li>87, 需注意 <code>a+b*a+b</code>先乘除後加減</li><li>100</li></ol><ul><li>Note:<br>採 <code>call by-address</code> 時, 若有運算式, 則此採 <strong>call by-value</strong> 來接收<br><code>call by-reference</code> 一般而言相同, 但在 c++ 中, 2 者完全不同<br><code>call by-name</code> 多做一件事, 所以居中</li></ul><h2>結構化程式三要求 Structure Programming Language SPL</h2><p>三要素：</p><ol><li>循序 sequential<br>指令會依序一一往下執行</li><li>選擇 selective/conditional<br>利用 &quot;判別式&quot; 來決定接下來的執行步驟為何<br><code>if...else...</code><br><code>switch...case...</code></li><li>重複 repeat/iteractive<br>利用 &quot;loop&quot; 來反覆執行部分的 step<br><code>for loop</code><br><code>while</code><br><code>do...while</code></li></ol><ul><li>SPL 中避免使用 &quot;跳躍&quot; 指令或動作<br><code>jump</code>, <code>goto</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;5.1 基本介紹&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Programming Language 程式語言&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;年代&lt;/th&gt;
&lt;th&gt;特徵1&lt;/th&gt;
&lt;th&gt;特徵2&lt;/th&gt;
&lt;th&gt;特徵3&lt;/th&gt;
&lt;th&gt;特徵4&lt;/t
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="Structure Programming Language" scheme="https://pingjing0628.github.io/tags/Structure-Programming-Language/"/>
    
      <category term="OOP" scheme="https://pingjing0628.github.io/tags/OOP/"/>
    
      <category term="Call by value" scheme="https://pingjing0628.github.io/tags/Call-by-value/"/>
    
      <category term="Call by address" scheme="https://pingjing0628.github.io/tags/Call-by-address/"/>
    
      <category term="Call by name" scheme="https://pingjing0628.github.io/tags/Call-by-name/"/>
    
      <category term="Call by value result" scheme="https://pingjing0628.github.io/tags/Call-by-value-result/"/>
    
  </entry>
  
  <entry>
    <title>Chapter4-系統程式-part2</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part2/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part2/</id>
    <published>2021-07-02T15:21:54.000Z</published>
    <updated>2021-07-05T09:27:00.563Z</updated>
    
    <content type="html"><![CDATA[<h1>4 系統程式 (System Program)</h1><hr><h2>補充 - Linking 的種類</h2><ul><li>Static Linking (like MACRO)</li><li>Dynamic Linking (like Subroutine)</li></ul><h3>Static Linking</h3><ul><li>指在 linking 時會將外部參考的函式皆搬到程式中, 成為程式的一部份, 故<strong>程式將較佔 space, 但後續執行不需去呼叫外部函式</strong></li><li>巨集 =&gt; 程式碼被撐大</li><li>Static Linking =&gt; 執行檔會被撐大</li><li>圖：<img src="staticLinking.png" alt=""></li></ul><h3>Dynamic Linking</h3><ul><li>Linking 時, 只將外部參考和外部函式所在做繫結, 不將外部函式載入, 故執行時在動態呼叫之</li><li>Ex: .dll =&gt; Dynamic Linking Library</li></ul><h3>Compare</h3><table><thead><tr><th>Static Linking</th><th>Dynamic Linking</th></tr></thead><tbody><tr><td>可執行檔較大</td><td>較小</td></tr><tr><td>不需外部呼叫 =&gt; 快</td><td>需要 =&gt; 慢</td></tr><tr><td>若外部程式改 =&gt; 需 relinking</td><td>不需</td></tr><tr><td>不受外在影響 =&gt; 較安全</td><td>受影響 (駭客可以改, 由於動態呼叫, 因此會被影響) =&gt; 較不安全</td></tr></tbody></table><h2>P-code compiler</h2><ul><li>Def: 為 pesudo-machine 之 object code<ul><li>類似中間碼</li><li>與機器獨立</li><li>高可攜性 =&gt; <strong>具跨平台 cross platform</strong></li></ul></li><li>圖：<img src="p-code.png" alt=""></li><li>優點：只要機器上有 P-code interpreter 即可執行 =&gt; 具可攜性</li><li>缺點：P-code 使用 interpreter 執行, 所以執行速度較慢</li><li>中間碼：類似目的碼, 由 0, 1 組成, 但和機器獨立</li></ul><h2>Java-compiler</h2><p><img src="java-compiler.png" alt=""></p><h2>JVM - Java Virtual Machine</h2><p><img src="jvm.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;4 系統程式 (System Program)&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;補充 - Linking 的種類&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Static Linking (like MACRO)&lt;/li&gt;
&lt;li&gt;Dynamic Linking (like Subrouti
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="System Program" scheme="https://pingjing0628.github.io/tags/System-Program/"/>
    
      <category term="Static Linking" scheme="https://pingjing0628.github.io/tags/Static-Linking/"/>
    
      <category term="Dynamic Linking" scheme="https://pingjing0628.github.io/tags/Dynamic-Linking/"/>
    
      <category term="P-code Compiler" scheme="https://pingjing0628.github.io/tags/P-code-Compiler/"/>
    
      <category term="Java Compiler" scheme="https://pingjing0628.github.io/tags/Java-Compiler/"/>
    
      <category term="JVM" scheme="https://pingjing0628.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Chapter4-系統程式-part1</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part1/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter4-%E7%B3%BB%E7%B5%B1%E7%A8%8B%E5%BC%8F-part1/</id>
    <published>2021-07-02T15:21:49.000Z</published>
    <updated>2021-07-05T09:28:47.004Z</updated>
    
    <content type="html"><![CDATA[<h1>4 系統程式 (System Program)</h1><hr><h2>Software License</h2><table><thead><tr><th>Software Licence</th><th>Def</th><th>licence</th><th>Open source code</th><th>Ex</th></tr></thead><tbody><tr><td><strong>Trial software</strong></td><td>試用一段時間, 若欲長期使用需付費</td><td>Yes</td><td>No</td><td>ACDSee</td></tr><tr><td><strong>Shareware</strong></td><td>同上, 但限制較寬鬆</td><td>Yes</td><td>No</td><td>WinRAR</td></tr><tr><td><strong>Freeware</strong></td><td>free</td><td>Yes</td><td>No</td><td>IE, MSN</td></tr><tr><td><strong>Public domain</strong></td><td>free</td><td>No</td><td>No</td><td>X</td></tr><tr><td><strong>Open software</strong></td><td>free</td><td>No</td><td>Yes</td><td>Redhat, Open Office</td></tr></tbody></table><h2>Open Source Software</h2><p>Def:</p><ul><li>指沒有 licence 限制, 可 free 使用, 且可拿到程式碼</li><li><strong>從 Open source 取得的程式, 修改後亦無 licence 所屬也為 Open source</strong></li></ul><h2>System Program</h2><h3><strong>Assembler (組譯器)</strong></h3><ul><li>Def: 將組合語言轉成 object code (<strong>目的碼, 為機器可識別之程式</strong>), 以便系統執行之</li><li>圖：<img src="assembler.png" alt=""></li></ul><h3><strong>Linker/Loader (鏈結器/載入器)</strong> =&gt; linking loader</h3><ul><li>欲將 object code 載入 memory 中, 過程需<ol><li><strong>linking (連結)</strong>: 將 object code 中的外部參考之宣告, 正式跟外部函式庫鏈結</li><li><strong>relocation (重定址)</strong>: 將程式中參考位址依實際 memory 所在重新計算其實際的位址</li><li><strong>loading (載入)</strong>: 正式將上述完成之 object code 載入 memory 中</li></ol></li></ul><h3><strong>Compiler (編譯器)</strong></h3><ul><li>Def: 將高階語言 (c, c++) 轉成低階的 object code</li><li>圖：<img src="compiler.png" alt=""></li><li>Compiler 過程：<ol><li>Lexical Analysis</li><li>Syntax Analysis</li><li>Semantic Analysis</li><li>Intermediate Code Optimization</li><li>Machine Dependent Code Generation and Optimization</li><li>Generate the Object Code<br>1.~ 4. =&gt; <strong>Machine Independent</strong><br>5.~ 6. =&gt; <strong>Machine Dependent</strong></li></ol></li><li>Lexical Analysis 語彙分析<ul><li>Scan the program and find out the token (語彙單元)<ol><li><strong>Terminal Symbol (終端符號)</strong> =&gt; keyword, 保留字</li><li><strong>Identifier (識別字)</strong> =&gt; 變數</li><li><strong>Liferal (常數)</strong> =&gt; 文, 數字</li></ol><ul><li>Ex: int(1) x(2) = (1) 20(3);(1)</li></ul></li><li>圖：<img src="lexical.png" alt=""></li></ul></li><li>Syntax Analysis 語法分析<ul><li>Def: 判別程式敘述是否合乎文法 (Grammer)<ul><li>合乎：建立出 <strong>parsing tree 或 syntax tree</strong></li><li>不合乎：output syntax tree</li></ul></li><li>圖：<img src="syntax.png" alt=""></li><li>文法 (Grammer)<ul><li>Note: 剖析工具: parser (剖析器)</li><li>Def: <code>G = &lt;N, T, P, S&gt;</code><ul><li>N: Non-terminal symbol set (非終端)</li><li>T: Terminal symbol set (終端)</li><li>P: Production rules (推衍規則)</li><li>S: Start symbol (S ∈ N) (起始)</li></ul></li><li>Ex:<br><code>G = &lt;N, T, P, S&gt;</code>, <code>N = {s, A, B}</code>, <code>T = {a, b}</code>,<br><code>P = {S -&gt; A|B; A -&gt; aA|a; B -&gt; bB|b;}</code> (-&gt; 為推衍符號),<br><code>S = s ∈ N</code> (S 為起始符號, s 為起始符號的名稱), 問 abaa, aaa 是否合乎文法？<br><strong>Sol:</strong><ol><li>S -&gt; A -&gt; aA -&gt; 此無法推出 b, 故不合乎文法</li><li>S -&gt; A -&gt; aA -&gt; aaA -&gt; aaa, 可推論出, 故合乎文法</li></ol></li></ul></li><li>Parsing tree 剖析樹<ul><li>Def: 剖析文法敘述所建立之樹</li><li>作法:<ul><li>N 必為 Tree 中的非終端節點 (degree &gt;= 1)</li><li>T 必為 Tree 中的終端節點 (degree = 0)</li></ul></li><li>Ex:<br><code>G = &lt;N, T, P, S&gt;</code>, <code>N = {E, T, F}</code>, <code>T = {+, -, *, /, id (,)}</code>,<br><code>P = {E -&gt; E+T|E-T|T; T -&gt; T*F|T/F|F; F -&gt; id|(E);}</code>, <code>S = E ∈ N</code>,<br>問<ol><li>id + id * id 合法建立剖析樹</li><li>id * (id - id / id)?</li></ol><ul><li>Note: 括號 &quot;()&quot;, 不可以被分割於 2 不同區塊之中<strong>Sol:</strong><br><img src="parsingTree.png" alt=""></li></ul></li></ul></li><li>Syntax tree 語法樹<ul><li>目的：<ul><li>簡化剖析樹</li><li>只保留 Terminal symbol</li><li>利用中序追蹤可還原運算式</li></ul></li><li>Note: <strong>括號不需考慮</strong> (因為已有 priority 之考量)</li></ul></li><li>文法種類<table><thead><tr><th>Note</th><th>Type</th><th>別名</th><th>自動機</th></tr></thead><tbody><tr><td><strong>自由度最大</strong></td><td>0</td><td>Unrestricted (不受限) grammer (AI)</td><td>Turing Machine (杜林機)</td></tr><tr><td><strong>如變數的宣告</strong></td><td>1</td><td>Context-sensitive (上下文相關) grammer</td><td></td></tr><tr><td><strong>高階語法</strong></td><td>2</td><td>Context-free (上下文無關) grammer</td><td></td></tr><tr><td></td><td>3</td><td>Regular grammer</td><td></td></tr></tbody></table></li></ul></li><li>Semantic Analysis 語意分析<ul><li>目的：依剖析結果, 呼叫對應的 semantic routine 或 action routine 以產生 <strong>intermediate code (中間碼)</strong> (<strong>類似目的碼一樣由 0, 1 組成, 但和機器獨立謂之</strong>)</li><li>圖：<img src="semantic.png" alt=""></li></ul></li><li>Intermediate Code Optimization 中間碼最佳化<ul><li>目的：<ol><li>精簡中間碼</li><li>所佔用 space 下降</li><li>效益提高</li></ol></li><li>常用技巧：<ol><li>刪除共通運算式<br><code>A = B + C * D + 2</code><br><code>F = 5 + (B + C + D) / 3</code><br>令 B, C, D 皆不變<br>α = B + C * D</li><li>先求出常數運算<br>Ex: <code>A = 3.14 * 2.56 / 3.2 + 8 - E</code><br>求 α = 3.14 * 2.56 / 3.2 + 8</li><li>布林運算式最佳化<ul><li>Ex1: if (A and B), A B 皆為 Condition (條件式)<br>若 A = false, B 不做 =&gt; 結果必為 false</li><li>Ex2: if (A or B), 若 A = true, B 不做 =&gt; 結果必為 True</li><li>Note: 此概念為：<ul><li>短路：short-circuit</li><li>又稱 <strong>&quot;捷徑運算&quot;</strong></li></ul></li></ul></li></ol></li></ul></li><li>程式中常見的 error<br><img src="error.png" alt=""></li></ul><h3><strong>Interpreter (直譯器)</strong></h3><ul><li>Def:<ul><li>不事先將 source code 轉成 object code</li><li>直接拿 source code 執行, 依原始程式 logical 順序進行</li><li>執行期間 interpreter 須留在 memory 之中</li></ul></li><li>圖：<img src="interpreter.png" alt=""></li></ul><h3>Compare Compiler vs Interpreter</h3><table><thead><tr><th>Compiler</th><th>Interpreter</th></tr></thead><tbody><tr><td>執行不需於 memory 中</td><td>需要</td></tr><tr><td>會事先產生 object code (<strong>有最佳化, 故效益佳</strong>)</td><td>不會, 直接依 logical 執行, 產生結果</td></tr><tr><td>全部 scan, 故比較沒有漏洞</td><td>較易有漏洞</td></tr><tr><td>修改 =&gt; recompile (彈性差)</td><td>不需 recompile (彈性佳)</td></tr><tr><td>開發時期較不適用</td><td>適用</td></tr><tr><td>找 bug 較不易</td><td>較易找到 bug 所在</td></tr><tr><td>初學者較不易</td><td>初學者較易上手</td></tr></tbody></table><hr><h3>Macro 巨集</h3><ul><li>Def: 開放式副程式 (Open subroutine)<br>將一連串的指令定義為巨集指令, 當 source code 轉換時, 遇到巨集呼叫, 就將對應的連串指令插入於呼叫處</li><li>圖：<img src="macro.png" alt=""></li><li>特性：<ol><li>巨集呼叫於<strong>程式轉換</strong>期間, 而非 <strong>runtime</strong></li><li>呼叫 Ｎ 次, 需插入巨集本文 N 次 =&gt; <strong>浪費空間</strong></li><li>執行階段, 不需做控制移轉 =&gt; <strong>快</strong></li><li>多此使用一單獨定義的常式 (定義一次, 可使用多次)</li></ol></li></ul><h3>Subroutine 副程式 =&gt; 又稱 close subroutine</h3><ul><li>Def: 於<strong>執行中</strong>, 當 subroutine 被呼叫才<strong>動態</strong>的去呼叫之, 並將資料及控制權移轉給他, 待完成, 再移轉回來</li><li>優點：只佔用一份 memory =&gt; 省 space</li><li>缺點：需做控制權移轉 =&gt; speed 下降</li></ul><h3>Compare Macro vs Subroutine</h3><table><thead><tr><th>MACRO</th><th>Subroutine</th></tr></thead><tbody><tr><td>Speed 快</td><td>Speed 慢</td></tr><tr><td>以空間換時間</td><td>以時間換空間</td></tr><tr><td>space 浪費</td><td>space 省</td></tr></tbody></table><h2>Summary</h2><p><img src="summary.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;4 系統程式 (System Program)&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Software License&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Software Licence&lt;/th&gt;
&lt;th&gt;Def&lt;/th&gt;
&lt;th&gt;licence&lt;/th&gt;
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="System Program" scheme="https://pingjing0628.github.io/tags/System-Program/"/>
    
      <category term="Software" scheme="https://pingjing0628.github.io/tags/Software/"/>
    
      <category term="Assembler" scheme="https://pingjing0628.github.io/tags/Assembler/"/>
    
      <category term="Linker/Loader" scheme="https://pingjing0628.github.io/tags/Linker-Loader/"/>
    
      <category term="Compiler" scheme="https://pingjing0628.github.io/tags/Compiler/"/>
    
      <category term="Interpreter" scheme="https://pingjing0628.github.io/tags/Interpreter/"/>
    
      <category term="Marco" scheme="https://pingjing0628.github.io/tags/Marco/"/>
    
      <category term="Subroutine" scheme="https://pingjing0628.github.io/tags/Subroutine/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-磁碟管理-part3</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part3/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part3/</id>
    <published>2021-07-01T16:10:14.000Z</published>
    <updated>2021-07-02T15:19:27.251Z</updated>
    
    <content type="html"><![CDATA[<h1>3.9 磁碟管理 (Disk Management)</h1><h2>目錄</h2><ul><li>Free space management<ul><li>Link list</li><li>Combination</li><li>Counting</li></ul></li><li>Allocation Method (配置方法)<ul><li>連續性配置 (contiguous allocation)</li><li>鏈結式配置 (linked allocation)<ul><li>FAT (file allocation table)</li></ul></li><li>索引配置 (index allocation)<ul><li>i-node</li></ul></li></ul></li><li>Disk structure**</li><li>Disk access time**</li><li>Disk scheduling**<ul><li>FCFS</li><li>SSTF</li><li>SCAN</li><li>C-SCAN</li><li>LOOK</li><li>C-LOOK</li></ul></li><li>補充</li><li><strong>RAID</strong></li><li><strong>RAID 的種類</strong><ul><li><strong>RAID1</strong></li><li><strong>RAID0+1</strong></li><li><strong>RAID2</strong></li><li><strong>RAID3 vs RAID4</strong></li><li><strong>RAID5</strong></li><li><strong>RAID6</strong></li></ul></li><li><strong>Summary</strong></li></ul><hr><h2>RAID Redundant Array of Independent Disks 磁碟陣列</h2><ul><li>Why RAID?<ol><li><strong>CPU 和 disk I/O 速度不對等</strong></li><li>資料安全性, 可靠性議題</li></ol></li><li>Solution:<ul><li>採用 &quot;<strong>data striping</strong>&quot; 資料切割：指將 data 分成幾個等分, 同時存到不同 disk 之中, <strong>以達平行 I/O 之效</strong></li></ul></li><li>RAID:<ul><li>Def: 指將多顆 physical disk, 組成一顆 logical disk 之後, 以達提高 I/O 效能跟增加資料的可靠性</li><li>圖：<img src="RAID.png" alt=""></li></ul></li></ul><h2>RAID 的種類</h2><ol><li><strong>RAID 0 (striping RAID)</strong></li></ol><ul><li>以效能導向</li><li><strong>速度最快的 RAID</strong></li><li><strong>沒有 fault tolerant</strong></li><li>Cost 低</li><li>至少需 2 顆 disk</li><li>圖：<img src="RAID0.png" alt=""></li></ul><ol start="2"><li><strong>RAID 1 (mirror RAID)</strong></li></ol><ul><li>至少有 &gt;= 2 顆 disk 存相同的 data</li><li>具 <strong>fault tolerant</strong> 特色</li><li>Cost 高 (浪費一半 space)</li><li>Read 效益不佳, write 較差</li><li>至少需 2 顆 disk (資料保護)</li><li>圖：<img src="RAID1.png" alt=""></li></ul><ol start="3"><li><strong>RAID 0+1 (01) speed 快 &gt; RAID 10</strong></li></ol><ul><li>兼具 speed up + fault tolerant</li><li>Cost 極高</li><li>至少需 4 顆 disk</li><li>補充：RAID 1+0 (10)<ul><li>先做 mirror, 在做 striping</li><li>相較下, 此種方法可靠性更佳, 故現在較常用此</li></ul></li><li>圖：<img src="RAID01.png" alt=""></li></ul><ol start="4"><li><strong>RAID 2</strong> (被 RAID 3 ~ 5 取代)</li></ol><ul><li>採用 &quot;ECC&quot; (Error Correcting Code) 技術, 達容錯效果</li></ul><ol start="5"><li><strong>RAID 3 vs RAID 4</strong>|RAID 3|RAID 4||--|--||以 &quot;bit&quot; 為切割單位 (太頻繁)|以 &quot;block&quot; 為單位||效能較差|效能較好|</li></ol><ul><li>共同特色：<ul><li>採 <strong>parity check</strong> 做 data 的可靠性機制</li><li>會有一顆專門放 parity 的 disk =&gt; <strong>會成為效能上的瓶頸</strong></li><li>同時允許一顆 disk 損壞依舊可以復原</li></ul></li><li>圖：<img src="RAID3&amp;4.png" alt=""></li></ul><ol start="6"><li><strong>RAID 5</strong> =&gt; 同 RAID 4, 但將 parity data 平均在各 disk 之上</li></ol><ul><li>圖：<img src="parityData.png" alt=""></li><li>小比較：<table><thead><tr><th>RAID</th><th>Speed</th><th>單位</th><th>parity data</th></tr></thead><tbody><tr><td>3</td><td>慢</td><td>bit</td><td>集中</td></tr><tr><td>4</td><td>中</td><td>block</td><td>集中</td></tr><tr><td>5</td><td>快</td><td>block</td><td>分散</td></tr></tbody></table></li></ul><ol start="7"><li><strong>RAID 6</strong></li></ol><ul><li>採 &quot;parity check&quot; + &quot;read soloman code&quot; =&gt; 可允許同時 2 顆 disk 損壞, 仍可恢復</li><li><strong>可靠性優於 RAID 3 ~ 5</strong></li></ul><h2>Summary</h2><table><thead><tr><th>RAID</th><th>至少 disk 數</th><th>Speed</th><th>Cost</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>快</td><td>低 -&gt; striping</td></tr><tr><td>1</td><td>2</td><td>慢</td><td>高 -&gt; mirror</td></tr><tr><td>0+1</td><td>4</td><td>快</td><td>最高</td></tr><tr><td>3</td><td>3</td><td>居中</td><td>居中 -&gt; parity check</td></tr><tr><td>4</td><td>3</td><td>居中</td><td>居中 -&gt; parity check</td></tr><tr><td>5</td><td>3</td><td>居中</td><td>居中 -&gt; parity check</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.9 磁碟管理 (Disk Management)&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Free space management
&lt;ul&gt;
&lt;li&gt;Link list&lt;/li&gt;
&lt;li&gt;Combination&lt;/li&gt;
&lt;li&gt;Counting&lt;/li
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="Disk Management" scheme="https://pingjing0628.github.io/tags/Disk-Management/"/>
    
      <category term="RAID" scheme="https://pingjing0628.github.io/tags/RAID/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-磁碟管理-part2</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part2/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part2/</id>
    <published>2021-07-01T16:10:10.000Z</published>
    <updated>2021-07-02T15:15:55.170Z</updated>
    
    <content type="html"><![CDATA[<h1>3.9 磁碟管理 (Disk Management)</h1><h2>目錄</h2><ul><li>Free space management<ul><li>Link list</li><li>Combination</li><li>Counting</li></ul></li><li>Allocation Method (配置方法)<ul><li>連續性配置 (contiguous allocation)</li><li>鏈結式配置 (linked allocation)<ul><li>FAT (file allocation table)</li></ul></li><li>索引配置 (index allocation)<ul><li>i-node</li></ul></li></ul></li><li><strong>Disk structure</strong></li><li><strong>Disk access time</strong></li><li><strong>Disk scheduling</strong><ul><li><strong>FCFS</strong></li><li><strong>SSTF</strong></li><li><strong>SCAN</strong></li><li><strong>C-SCAN</strong></li><li><strong>LOOK</strong></li><li><strong>C-LOOK</strong></li></ul></li><li><strong>補充</strong></li><li>RAID</li><li>RAID 的種類<ul><li>RAID1</li><li>RAID0+1</li><li>RAID2</li><li>RAID3 vs RAID4</li><li>RAID5</li><li>RAID6</li></ul></li><li>Summary</li></ul><hr><h2>Disk structure</h2><ul><li>圖：<img src="diskStructure.png" alt=""></li><li>track 的水平集合 =&gt; surface (磁面)</li><li>track 的垂直集合 =&gt; cylinder (磁柱) 圓柱體</li><li>順序 小 -&gt; 大 =&gt; sector &lt; cluster &lt; track &lt; {surface, cylinder}</li><li>Ex: cylinder = 10, tracks = 20<ul><li>each track has 320 sector</li><li>each sector 的 size = 512 bytes<br>What's the disk total size?<br>Sol:<br><code>10 * 20 * 320 * 512 bytes</code><br><code>= 32000 KB</code><br>約等於 32 MB</li></ul></li></ul><h2>Disk access time</h2><ul><li><p>由下列組成：</p><ol><li>Seek time 搜尋時間：將 Header (讀寫頭) 移到指定的 Track 上方 (最耗時)</li><li>Rotation time 旋轉時間 (Latency 延遲)：將 data 轉到 Header 的下方 (耗時 中等)</li><li>Transfer time 傳輸時間：正式由 Header 讀取 data 做 disk  &lt;-&gt; Memory 傳輸 (耗時 小)</li></ol></li><li><p>Ex: seek time 平均需 8ms, 而 disk 為 7200RPM(轉), 問平均 disk access time = ?<br>RPM = Rotate Per Minute: 7200/60 = 120/secSol:<br>seek time + rotate (平均) = 8ms + 1/120 sec * 1/2 = 8ms + 1/240 sec<br><img src="Ex.png" alt=""></p></li></ul><h2>Disk Scheduling</h2><ul><li>Def: 指當有多個 access request, 在不同的 disk 之上, 則 Header 之移動服務順序為何</li><li><strong>策略採 &quot;Disk Scheduling algorithm&quot;</strong><ol><li><strong>FCFS (FIFO) (First Come First Service)</strong><ul><li>Ex: track 0~99, header = 15, access request - 81, 47, 90, 18, 5<br>Sol: <img src="FCFS.png" alt=""></li></ul></li><li><strong>SSTF (Shortest Seek Time First)(不見得為最佳解)</strong><ul><li>Ex: <img src="SSTF.png" alt=""></li></ul></li><li><strong>SCAN (掃描法)</strong>: 來回於兩端移動, 遇到 access request 即停下來服務之</li><li><strong>C-SCAN</strong> =&gt; 同 SCAN, 但 &quot;單向服務&quot;<ul><li>圖：<img src="C-SCAN.png" alt=""></li></ul></li><li><strong>LOOK</strong>: 跟 SCAN 相似, 但<strong>不見得碰底, 沒服務則往回走</strong><ul><li>較有效率, 但也就較複雜, 需額外空間處理</li><li>圖：<img src="LOOK.png" alt=""></li></ul></li><li><strong>C-LOOK</strong>: 同 LOOK, 但 &quot;單向服務&quot;<ul><li>圖：<img src="C-LOOK.png" alt=""></li></ul></li></ol></li></ul><h2>補充</h2><table><thead><tr><th>說明</th><th>傳統 (IDE, SCSI, SATA)</th><th>固態硬體 SSD(Solid State Drive)</th></tr></thead><tbody><tr><td>比較 1</td><td>Header 採機械式移動 =&gt; 慢 (seek 是 sequential)</td><td>採用 &quot;電子式&quot; =&gt; 快 (random access)</td></tr><tr><td>比較 2</td><td>抗震性差</td><td>抗震性佳 =&gt; 適用於行動裝置上</td></tr><tr><td>比較 3</td><td>成本低</td><td>成本高</td></tr><tr><td>比較 4</td><td>容量高</td><td>容量小</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.9 磁碟管理 (Disk Management)&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Free space management
&lt;ul&gt;
&lt;li&gt;Link list&lt;/li&gt;
&lt;li&gt;Combination&lt;/li&gt;
&lt;li&gt;Counting&lt;/li
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="Disk Management" scheme="https://pingjing0628.github.io/tags/Disk-Management/"/>
    
      <category term="Disk structure" scheme="https://pingjing0628.github.io/tags/Disk-structure/"/>
    
      <category term="Disk scheduling" scheme="https://pingjing0628.github.io/tags/Disk-scheduling/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-磁碟管理-part1</title>
    <link href="https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part1/"/>
    <id>https://pingjing0628.github.io/2021/07/02/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A3%81%E7%A2%9F%E7%AE%A1%E7%90%86-part1/</id>
    <published>2021-07-01T16:08:39.000Z</published>
    <updated>2021-07-02T14:11:15.289Z</updated>
    
    <content type="html"><![CDATA[<h1>3.9 磁碟管理 (Disk Management)</h1><h2>目錄</h2><ul><li><strong>Free space management</strong><ul><li><strong>Link list</strong></li><li><strong>Combination</strong></li><li><strong>Counting</strong></li></ul></li><li><strong>Allocation Method (配置方法)</strong><ul><li><strong>連續性配置 (contiguous allocation)</strong></li><li><strong>鏈結式配置 (linked allocation)</strong><ul><li><strong>FAT (file allocation table)</strong></li></ul></li><li><strong>索引配置 (index allocation)</strong><ul><li><strong>i-node</strong></li></ul></li></ul></li><li>Disk structure</li><li>Disk access time</li><li>Disk scheduling<ul><li>FCFS</li><li>SSTF</li><li>SCAN</li><li>C-SCAN</li><li>LOOK</li><li>C-LOOK</li></ul></li><li>補充</li><li>RAID</li><li>RAID 的種類<ul><li>RAID1</li><li>RAID0+1</li><li>RAID2</li><li>RAID3 vs RAID4</li><li>RAID5</li><li>RAID6</li></ul></li><li>Summary</li></ul><hr><h2>Free Space Management</h2><ol><li><strong>Bit Vector (位元向量)</strong></li></ol><ul><li>圖：<img src="bitVector.png" alt=""></li><li>Def: 給各 block 一個 bit, 當 bit<ul><li>bit = 0, 則 free block</li><li>bit = 1, 則 use</li></ul></li><li>Ex: <code>011001110001</code></li><li>優點：<ol><li>easy to implement</li><li>找連續可用的 block 容易</li></ol></li><li>缺點：當 block 太多, 則 bit vector 不適用</li></ul><ol start="2"><li><strong>Link list (鏈結串列)</strong></li></ol><ul><li>Def: 將 free block 以 link 方式串接</li><li>Ex: <img src="linkList.png" alt=""></li><li>優點：insert / delete free block 容易</li><li>缺點：<ol><li>檔案配置不便</li><li>link broken, data lose</li></ol></li></ul><ol start="3"><li><strong>Combination (組合)</strong></li></ol><ul><li>Def: 將一 Node 給予多個格子合併而成</li><li><img src="combination.png" alt=""></li><li>Ex: <img src="combinationEx.png" alt=""></li></ul><ol start="4"><li><strong>Counting (計數法)</strong></li></ol><ul><li>Def: 在 linked list 中 Node 加入一空間, 放連續 free block 之數量 (<strong>連續的 free block 越多, 串列越短</strong>)</li><li>Ex: <img src="countingEx.png" alt=""></li></ul><hr><h2>Allocation Method (配置方法)</h2><ol><li><strong>連續性配置 (contiguous allocation)</strong></li></ol><ul><li>Def: 檔案大小 = n blocks 時, O.S. 需找到連續 free block &gt;= n, 方可配置</li><li>優點：<ol><li>search time 短 =&gt; 因為 data 鄰近度</li><li>support sequential 及 random access =&gt; 處理快</li></ol></li><li>缺點：<ol><li>有 external 碎裂</li><li>檔案大小無法任意擴充</li><li>file size 需事先宣告<br>(2, 3 會導致沒有彈性)</li></ol></li><li><strong>Solution:</strong><ol><li><strong>Repack (壓縮), 但極度耗時</strong></li><li><strong>disk defragmentation 磁碟重組: 將 file 的分配重組, 以求能達:</strong><ul><li>access time 下降 =&gt; 速度快</li><li>連續空間變多 =&gt; 外部碎裂下降</li></ul></li></ol></li><li>圖：<img src="contiguous.png" alt=""></li></ul><ol start="2"><li><strong>鏈結式配置 (linked allocation)</strong></li></ol><ul><li>Def: 檔案大小 = n blocks 時, O.S. 需找到 free block &gt;= n, 即可配置</li><li>優點：<ol><li>No external 碎裂</li><li>檔案可以擴充</li><li>file size 不需事先宣告<br>(2, 3 有彈性)</li></ol></li><li>缺點：<ol><li>search time 長 (因為 data 不見得於鄰近處)</li><li>support sequential 較慢, 不支援 random access</li></ol></li><li>圖：<img src="linked.png" alt=""></li><li><strong>FAT (file allocation table)</strong><ul><li>Def:<ul><li>用於 Dos, OS/2 之中</li><li>FAT Stored in the disk, 紀錄各 file block 的 link 關係</li></ul></li><li>Ex: <img src="FATEx.png" alt=""></li><li>Note: windows PC 版用 &quot;NTFS&quot; 格式</li><li>圖：<img src="FAT.png" alt=""></li></ul></li></ul><ol start="3"><li><strong>索引配置 (index allocation)</strong></li></ol><ul><li>Def: 各 file 皆有自己的 index block, 用以指向其 block 對應到 disk block 的編號為何</li><li>Ex: <img src="indexEx.png" alt=""></li><li>優點：結合 Contiguous Allocation &amp; Linked Allocation 的優點 =&gt; speed up 又有彈性</li><li>缺點：<ol><li>index block 需佔用額外空間</li><li>index block 大小不易決定</li></ol></li><li><strong>i-node (unix-like 常用)</strong><ul><li>概念：<img src="i-node.png" alt=""></li><li>說明：<br>1 ~ 12: direct index block (最重要的)<br>13: single indirect index block<br>14: double indirect index block<br>15: triple indirect index block</li><li>Ex:<br>1~10: direct block<br>11: single indirect block<br>12: double indirect block<br>13: triple indirect block<hr>each data block = 4 bytes<br>each index block = 4 k<br>each index size = 4<br>total data size = ?<br><strong>Sol:</strong><br><code>10 * 4 bytes</code> + <code>4k/4 * 4 bytes</code> +<br><code>k * k * 4 bytes</code> + <code>k * k * k * 4 bytes</code><br>= <code>40 bytes + 4kB + 4k^2B + 4k^3B</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.9 磁碟管理 (Disk Management)&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Free space management&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Link list&lt;/strong&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="Disk Management" scheme="https://pingjing0628.github.io/tags/Disk-Management/"/>
    
      <category term="Free space management" scheme="https://pingjing0628.github.io/tags/Free-space-management/"/>
    
      <category term="Bit vector" scheme="https://pingjing0628.github.io/tags/Bit-vector/"/>
    
      <category term="Linked list" scheme="https://pingjing0628.github.io/tags/Linked-list/"/>
    
      <category term="Combination" scheme="https://pingjing0628.github.io/tags/Combination/"/>
    
      <category term="Counting" scheme="https://pingjing0628.github.io/tags/Counting/"/>
    
      <category term="Allocation Method" scheme="https://pingjing0628.github.io/tags/Allocation-Method/"/>
    
      <category term="FAT" scheme="https://pingjing0628.github.io/tags/FAT/"/>
    
      <category term="i-node" scheme="https://pingjing0628.github.io/tags/i-node/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-虛擬記憶體-part2</title>
    <link href="https://pingjing0628.github.io/2021/06/24/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94-part2/"/>
    <id>https://pingjing0628.github.io/2021/06/24/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94-part2/</id>
    <published>2021-06-24T14:43:52.000Z</published>
    <updated>2021-07-01T16:08:07.237Z</updated>
    
    <content type="html"><![CDATA[<h1>3.8 虛擬記憶體 (Virtual Memory)</h1><ul><li>目的：允許 program size &gt; physical memory size, 而程式仍能執行</li><li>作法：(部分載入) =&gt; <strong>有需要才載入</strong><br>方法：<br>1. Dynamic Loading =&gt; 為 <strong>programmer</strong> 的負擔<br>2. Virtual Memory =&gt; 為 <strong>O.S.</strong> 的負擔</li></ul><h2>目錄</h2><ul><li>Dynamic Loading 動態載入</li><li>Virtual Memory</li><li>Virtual Memory Definition</li><li><strong>Virtual Memory實施方式</strong><ul><li><strong>Demand Paging</strong></li><li><strong>Demand Segment</strong></li><li><strong>Page Fault 處理</strong></li><li><strong>Virtual Memory Performance 評估</strong><ul><li><strong>P 的影響因素</strong><ol><li><strong>frame 數量</strong></li><li><strong>page size 大小</strong></li><li><strong>Program Structure</strong></li><li><strong>Page Replacement algorithm</strong><ol><li><strong>FIFO</strong></li><li><strong>OPT</strong></li><li><strong>LRU</strong></li><li><strong>LRU 近似法則</strong></li><li><strong>Frequency of reference</strong></li></ol></li></ol></li></ul></li><li><strong>Demand Paging 的問題：「Thrashing」猛移/輾轉</strong><ul><li><strong>防止 Thrashing 作法</strong></li></ul></li></ul></li></ul><hr><h2>Virtual Memory 實施方式</h2><ol><li>Demand Paging<ul><li>Def:<ul><li>執行初期只載入部分的 page (有需要, 才載入)</li><li>當遇到 &quot;所需 page 不在 memory 之中&quot;, 則通知 O.S. 做 **page fault (頁面缺失)**處理, <strong>將 lose page 載入 memory 之中</strong></li></ul></li><li>作法：<ul><li>在 P.T. 上加入 V/I Bit , 使 memory 可達部分載入之效</li><li><strong>V: Valid (存在 Memory)</strong></li><li><strong>I: Invalid (不存在)</strong></li></ul></li><li>圖：  <img src="demandPaging.png" alt=""></li></ul></li><li>Demand Segment</li></ol><h3>Page Fault 處理</h3><ol><li>產生 page fault interrupt 訊號給系統</li><li>find: 找一 free frame</li><li>swap in: 將 lose page 載入 memory 中</li><li>updates: 改 page table 內容</li><li>將控制權交還 user</li></ol><hr><h2>Virtual Memory Performance 評估</h2><p>=&gt; 由 Memory 存取時間來決定 (effect memory access time)<br>=&gt; <strong><code>(1 - P) x ma + P x PFPT</code></strong></p><ul><li><code>(1 - P) x ma</code> 命中所需<ul><li>1 - P 小較好</li><li>ma 短</li></ul></li><li><code>P x PFPT</code> 沒命中<ul><li>PFPT 長</li><li><strong>結論 P 越低越好</strong></li></ul></li><li>P: page fault ratio</li><li>ma: memory access time (硬體不能改)</li><li>PFPT: page fault processing time (不能改)</li></ul><h3>P 的影響因素為</h3><ol><li>frame 數量<br><img src="P1.png" alt=""></li><li>page size 大小<ul><li>當 page size 越小, 則：</li><li>缺點：<ol><li>Page Table 大小上升</li><li>I/O 次數 上升</li><li>Page fault ratio 上升</li></ol></li><li>優點：<ol><li>內部碎裂下降</li><li>單一 I/O 量 下降</li></ol></li></ul></li><li>Program Structure:<br>=&gt; 說明：program 的設計跟撰寫的 logical 結構亦會影響 P 的大小</li><li><strong>Page Replacement (頁面置換)</strong> algorithm<ul><li>Def: 當 page fault 時, 又系統的 free frame 已無, 則需：<ol><li><strong>挑出一 victim page (V.P)</strong></li><li><strong>將 Victim Page swap out</strong></li><li><strong>將 Lose Page swap in</strong></li></ol></li><li>挑選策略分為：<ol><li><strong>FIFO</strong></li><li><strong>OPT</strong></li><li><strong>LRU</strong></li><li><strong>LRU 近似法則</strong></li><li><strong>Frequency of reference</strong></li></ol></li></ul></li></ol><h4>1. FIFO - First In First Out</h4><ul><li>先到達, 先被置換</li><li>特色：<ul><li>easy to implement</li><li>效益不佳 (page fault ratio 太高, I/O 就多, 效益一定不好)</li><li>有 <strong>Belady's 異常</strong><ul><li>一般：frame 數給越多 =&gt; page fault ratio 下降</li><li>在 Belady's 之下：frame 數給越多 =&gt; page fault ratio 上升</li></ul></li></ul></li><li>Ex: 採 FIFO, 且用 pure demand paging, page fault 幾次？<br><img src="exFIFO.png" alt=""></li></ul><h4>2. OPT (Optimal) 最佳法則</h4><ul><li>Def: 替換掉 <strong>未來長期不用</strong>的</li><li>特質：<ol><li>效益最佳 (因為 page fault ratio 最小)</li><li>No Belady's 異常</li><li>要預測未來不易 (實作困難)</li><li>拿來當作理論的依據</li></ol></li><li>Note: demand paging 載入方式<ul><li>pure =&gt; 不先載入, 一開始會有 page fault</li><li>prepaging =&gt; 做預先載入</li></ul></li><li>Ex: 呈上例才 OPT<br><img src="OPT.png" alt=""></li></ul><h4>3. LRU (Least Recently Used) =&gt; 看過去的歷史 (Stack)</h4><ul><li>Def: 替換<strong>過去</strong>長期不用的 page</li><li>特色：<ol><li>效果不錯</li><li>No Belady's 異常</li><li>需 Hardware Support (大量硬體)</li></ol></li><li>作法：<ol><li>Counting (計數法)<br>紀錄 page 的參考時間, 替換掉最久的 page</li><li><strong>Stack (堆疊法)</strong><br>採 stack 方式, 最近用的於 top 端, 最底層為下次 swap 之 page</li></ol></li><li>Ex: LRU<br><img src="LRU.png" alt=""></li></ul><h4>4. LRU 近似法則</h4><ul><li>Def: 由於 LRU 近 <strong>花費大量的 Hardware</strong>, 故採用 LRU 近似法來模擬 LRU 之效</li><li>作法：<ol><li>Second Chance<ul><li>Def: FIFO + 1 個 Reference Bit (0 =&gt; 沒被參考, 1 =&gt; 有被參考)</li><li>挑選策略：<ul><li><strong>先用 FIFO 找出 page: P</strong></li><li><strong>check page: P</strong><ul><li><strong>若 R.B = 1 =&gt; 改為 0, 往下找</strong></li><li><strong>若 R.B = 0 =&gt; 此為 victim page</strong></li></ul></li></ul></li><li>Ex: <img src="secondChance.png" alt=""></li><li>Special Case:<ul><li>當 R.B 全為 0, 或 R.B 全為 1, 代表 =&gt; 退化成 FIFO (可能有 Belady's)</li></ul></li></ul></li><li>Enhanced Second Chance<ul><li>Def: 將 Second Chance + 1 個 Modification Bit (M.B)(想要讓效能變更快)</li><li>Note: M.B<ul><li>=0, 代表 page 沒有更動過</li><li>=1, 代表 page 有更動過</li></ul></li><li>當 Victim page 之 M.B = 0, 代表內容沒變, 故不需 swap out =&gt; <strong>performance 上升</strong></li><li>圖：<img src="enhanceChance1.png" alt=""></li><li>挑選策略：<img src="enhanceChance2.png" alt=""></li><li>Ex: 問 victim page, 採 second chance 挑, enhanced second chance 挑？<br><img src="LRU%E8%BF%91%E4%BC%BCex.png" alt=""><br>採 second chance 挑 2<br>enhanced second chance 挑 4</li></ul></li></ol></li></ul><h4>5. Frequency of reference</h4><ul><li>紀錄各 page 被參考的次數</li><li>方式：<ol><li>LFU =&gt; 挑參考值最小的當 victim page</li><li>MFU =&gt; 挑參考值最大的當 victim page</li></ol></li></ul><hr><h2>Demand Paging 的問題：「Thrashing」猛移/輾轉</h2><ul><li>Def: 於 demand paging 下, 當 <strong>process frame 不足</strong>產生 page fault 又 <strong>memory 的 frame</strong>亦不足, 此時需搶奪其他 process 的 frame, 導致：<ul><li><strong>CPU utilization 下降</strong></li><li><strong>O.S. 引入更多 process</strong></li><li><strong>Page fault 更嚴重</strong></li><li>圖：<img src="thrashing1.png" alt=""></li></ul></li><li>問：<ol><li>CPU 使用率 10%, How to do ?</li><li>呈上得知 page fault ratio 90%, How to do ?<br>Sol:<ol><li><strong>Multiprogramming Degree 上升 (引入更多 process)</strong></li><li><strong>Multiprogramming Degree 下降 (收回一些 process)</strong></li></ol></li></ol></li></ul><h3>防止 Thrashing 作法</h3><ol><li>控制 page fault ratio <strong>合理 range</strong><ul><li>圖：<img src="thrashing2.png" alt=""></li></ul></li><li>採 <strong>Working Set Model</strong>(工作集模式)<ul><li>Def: 利用程式執行時有 **&quot;局部性&quot;**之特性, 將各 process 於此 working set 所需之 frame 加以配置, 避免 Thrashing<ul><li><strong>Locality: 指程式於一特定時間會集中執行部分的區塊, 而不是 uniform 的執行</strong></li></ul></li><li>分：<ul><li>Temporal (時間)<ul><li>ex: loop, subroutine, stack, counter</li><li>用到的不久後還會被用到</li></ul></li><li>Spatial (空間)<ul><li>ex: array, 范紐曼, sequential code</li><li>我被用了, 鄰近的空間很容易也被用到</li></ul></li></ul></li><li>Note:<ul><li>O(某符號): Working Set Window<br>Working set (W.S.) =&gt; 指 O 中不同的 page 之集合<br>Working set size (W.S.S) =&gt; 為 W.S 之大小</li></ul></li><li><strong>判別：令</strong> <img src="thrashing3.png" alt=""><ul><li>n: process 數</li><li>M: physical free frame 的數量</li></ul><ol><li>若 <code>D &lt;= M</code> =&gt; 依各 process 的 W.S.S 配置 frames 數量</li><li><code>D &gt; M</code> =&gt; stop 部分 process, go to 1.</li></ol></li><li>Ex:<br>P1: 1 2 2 1 | 3 4 2 2 | 3 4 1 5<br>P2: 2 2 1 3 | 3 3 3 3 | 4 2 4 2<br>P3: 1 2 3 4 | 4 3 3 3 | 3 2 2 1<br>O(某符號) = 4<br>Sol:<br>P1:<br>W.S. = {1, 2}<br>W.S.S = 2<br>P2:<br>W.S. = {1, 2, 3}<br>W.S.S = 3<br>P3:<br>W.S. = {1, 2, 3, 4}<br>W.S.S = 4<br>Total: 9</li><li>優點：<ol><li>防止 Thrashing</li><li>對 Prepaging 很有幫助</li></ol></li><li>缺點：<ol><li>Working set 的追蹤不易</li><li>Working set 之間的 Transfer time 拉長</li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.8 虛擬記憶體 (Virtual Memory)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;目的：允許 program size &amp;gt; physical memory size, 而程式仍能執行&lt;/li&gt;
&lt;li&gt;作法：(部分載入) =&amp;gt; &lt;strong&gt;有需要才載入&lt;/
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="Virtual Memory" scheme="https://pingjing0628.github.io/tags/Virtual-Memory/"/>
    
      <category term="Demand Paging" scheme="https://pingjing0628.github.io/tags/Demand-Paging/"/>
    
      <category term="Page Fault" scheme="https://pingjing0628.github.io/tags/Page-Fault/"/>
    
      <category term="Virtual Memory Performance" scheme="https://pingjing0628.github.io/tags/Virtual-Memory-Performance/"/>
    
      <category term="FIFO" scheme="https://pingjing0628.github.io/tags/FIFO/"/>
    
      <category term="LRU" scheme="https://pingjing0628.github.io/tags/LRU/"/>
    
      <category term="OPT" scheme="https://pingjing0628.github.io/tags/OPT/"/>
    
      <category term="Thrashing" scheme="https://pingjing0628.github.io/tags/Thrashing/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-虛擬記憶體-part1</title>
    <link href="https://pingjing0628.github.io/2021/06/24/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94-part1/"/>
    <id>https://pingjing0628.github.io/2021/06/24/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94-part1/</id>
    <published>2021-06-24T14:42:29.000Z</published>
    <updated>2021-07-01T10:39:40.938Z</updated>
    
    <content type="html"><![CDATA[<h1>3.8 虛擬記憶體 (Virtual Memory)</h1><ul><li>目的：允許 program size &gt; physical memory size, 而程式仍能執行</li><li>作法：(部分載入) =&gt; <strong>有需要才載入</strong><br>方法：<br>1. Dynamic Loading =&gt; 為 <strong>programmer</strong> 的負擔<br>2. Virtual Memory =&gt; 為 <strong>O.S.</strong> 的負擔</li></ul><h2>目錄</h2><ul><li><strong>Dynamic Loading 動態載入</strong></li><li><strong>Virtual Memory</strong></li><li><strong>Virtual Memory Definition</strong></li><li>Virtual Memory實施方式<ul><li>Demand Paging</li><li>Demand Segment</li><li>Page Fault 處理</li><li>Virtual Memory Performance 評估<ul><li>P 的影響因素<ol><li>frame 數量</li><li>page size 大小</li><li>Program Structure</li><li>Page Replacement algorithm<ol><li>FIFO</li><li>OPT</li><li>LRU</li><li>LRU 近似法則</li><li>Frequency of reference</li></ol></li></ol></li></ul></li><li>Demand Paging 的問題：「Thrashing」猛移/輾轉<ul><li>防止 Thrashing 作法</li></ul></li></ul></li></ul><hr><h2>Dynamic Loading 動態載入</h2><ul><li>執行之初只載入所需的部分頁面</li><li>當 subroutine 被呼叫時, 再將之載入到其他不需用的 subroutine 的所在位址, 以 <strong>覆寫</strong> 利用原 Memory space <strong>=&gt; 為 Overlay 之技巧</strong></li><li>圖：<img src="dynamicLoading.png" alt=""></li></ul><h2>Virtual Memory</h2><ul><li>圖：<img src="virtualMem.png" alt=""></li></ul><h2>Virtual Memory Definition</h2><ul><li><strong>正在執行中</strong>的區塊才載入 Memory</li><li>將 Logical 和 Physical address 分開<strong>且 Logical 可大於 Physical 之 address</strong></li><li>在系統會於 <strong>次儲存媒體</strong>(主要 storage 為 main memory, 次要為 <strong>disk</strong> or CD-ROM)挪用一塊空間模擬(<strong>swap space</strong>)成 Memory</li><li>執行時允許<strong>動態</strong>的 swap in/out</li><li>優點：<ol><li>Program 不受限於 physical memory</li><li>Programmer 可專心寫程式即可</li><li>各 process 佔用 memory space 下降 <strong>=&gt;可列入更多 process, 即 Multiprogramming Degree 上升</strong></li><li>單次 I/O 量下降, 但 I/O 次數上升(缺),存取效能下降(因為需I/O)(缺)</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.8 虛擬記憶體 (Virtual Memory)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;目的：允許 program size &amp;gt; physical memory size, 而程式仍能執行&lt;/li&gt;
&lt;li&gt;作法：(部分載入) =&amp;gt; &lt;strong&gt;有需要才載入&lt;/
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="Virtual Memory" scheme="https://pingjing0628.github.io/tags/Virtual-Memory/"/>
    
      <category term="Dynamic Loading" scheme="https://pingjing0628.github.io/tags/Dynamic-Loading/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-記憶體管理</title>
    <link href="https://pingjing0628.github.io/2021/06/22/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86/"/>
    <id>https://pingjing0628.github.io/2021/06/22/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86/</id>
    <published>2021-06-22T12:44:03.000Z</published>
    <updated>2021-06-30T14:26:04.509Z</updated>
    
    <content type="html"><![CDATA[<h1>3.7 記憶體管理 (Memory Management)</h1><p>圖：<img src="%E8%A8%98%E6%86%B6%E9%AB%94.png" alt=""></p><hr><h2>Memory Allocation Strategy 記憶體配置策略</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">定義</th><th style="text-align:center">Time</th><th style="text-align:center">Space 使用率</th></tr></thead><tbody><tr><td style="text-align:left">First Fit</td><td style="text-align:left">從頭找, 當 free block size &gt;= n, 即可配置</td><td style="text-align:center">佳</td><td style="text-align:center">佳</td></tr><tr><td style="text-align:left">Best Fit</td><td style="text-align:left">從頭到尾, 找出所有符合 free block size &gt;= n, 且差異小者</td><td style="text-align:center">差</td><td style="text-align:center">佳</td></tr><tr><td style="text-align:left">Worst Fit</td><td style="text-align:left">從頭到尾, 找出所有符合 free block size &gt;= n, 且差異大者</td><td style="text-align:center">差</td><td style="text-align:center">差</td></tr></tbody></table><ul><li>Ex:<img src="allocation.png" alt=""></li></ul><h3>First Fit 的小問題</h3><p>經長期配置後, 前面的片段都會只剩下一小部分, 後續的 search 每次皆須經過<br>=&gt; Solution: 採用 &quot;<strong>Next Fit</strong>&quot;<br>Def: 利用 First Fit 概念, 但會從 <strong>上次配置的下一個節點開始 search</strong></p><h2>Memory 中常發生的問題</h2><ol><li>外部碎裂：External Fragmentation<br>Def: 指 process 所需的 Memory 大小小於 memory 總可用空間, 但卻不能配置 (因為空間不連續, <strong>空間夠但不能給</strong>)<br>Solution:<ol><li>Multiple Base/Limit 暫存器</li><li>Compaction 壓縮</li><li>Page Memory Management 分頁式</li></ol></li><li>內部碎裂：Internal Fragmentation<br>Def: 給予的 Memory 大小較 process 所需空間大 (給太多, 你不用別人也不能用), 造成空間上的浪費<br>Solution:<ol><li>Segment Memory Management 分段式</li></ol></li></ol><h3>Multiple Base/ Limit register set. 多重基底限制暫存器</h3><p><img src="baseLimit.png" alt=""></p><h3>Compaction 壓縮</h3><ul><li><p>圖：<img src="compaction.png" alt=""></p></li><li><p>困難：</p><ol><li>壓縮策略不易制定</li><li>Process 皆需支援 <strong>Dynamic Binding</strong> (只要一 process 不支援, 則無法採用)</li></ol></li></ul><h3>Paged Memory Management 分頁式</h3><ul><li><p>觀念：</p><ol><li>Physical memory 視為一組頁框 (frame) 之集合, <strong>各 frame 大小一致</strong></li><li>Logical memory 視為一組頁面 (page) 之集合, <strong>&quot;page size = 一 frame size&quot;</strong></li></ol></li><li><p>圖：<img src="paged.png" alt=""></p></li><li><p>配置策略：</p><ol><li>Page 間採 &quot;不連續&quot; 存放</li><li>Process 為 n 個 page 時, 當 free frames &gt;= n 個即可配置 (No 外部碎裂, 夠就一定可以給)</li><li>O.S. 替各 process 準備一 page table, 存放 <strong>page 跟 frame 之對應</strong></li></ol></li><li><p>例：一 program = 19k, frame size = 4k, 則</p><ol><li>需多少 page?</li><li>內部碎裂 = ?</li><li>Page Table 的 entry size = 4 bytes, 問 Page Table 大小 ?<br>Sol:<ol><li>5 個, 需整數</li><li>5 * 4k = 20k, 20k - 19k = 1k</li><li><code>19k -&gt; page size = 4k</code>, <code>5 * 4 bytes = 20 bytes</code></li></ol></li></ol></li></ul><h4>Logical address 對應 Physical address 的方式</h4><ul><li>圖：<img src="logical%E5%B0%8D%E6%87%89.png" alt=""></li><li>Ex: 8 frames, each frame size = 4, 一 process 的 Page Table 如下：問<ol><li>logical address 7 跟 13 的 physical address = ?</li><li>logical 跟 physical address 表示需幾 bits ?<br>Sol:</li><li><img src="ex%E8%A7%A3%E6%B3%951.png" alt=""></li><li><img src="ex%E8%A7%A3%E6%B3%952.png" alt=""></li></ol></li></ul><h4>Page table 的存放製作方式</h4><ol><li>存 register<ul><li>優點：速度快</li><li>缺點：容量大, 不適用 register 小</li></ul></li><li>存 memory<ul><li>優點：容量大, 適用</li><li>缺點：每次需做 2 次的 memory 存取 (第一次抓 P.T, 第二次抓 data)</li><li>作法： <img src="%E5%AD%98%E6%94%BE2.png" alt=""></li></ul></li><li><strong>TLB 方式 Translation look-aside Buffer</strong><ul><li>由高速的關聯是暫存器組成</li><li>其各個的內容為：<ul><li>key: 存 page number (p)</li><li>value: 存 frame number (f)</li></ul></li><li>只存常用的 p, f 之對應 <strong>(目前執行中的 process 方可存入 TLB 之中)</strong> (當如果只要有 process 更換或做了 context switching, TLB 內容需全部 refresh)</li><li><strong>採 TLB 之 effect memory access time 有效記憶體存取時間</strong><ul><li>公式：<code>h * (ta + ma) + (1 - h) * (ta + 2ma)</code><ul><li><code>h * (ta + ma)</code> 為<strong>命中所需時間</strong></li><li><code>(1 - h) * (ta + 2ma)</code> 為 <strong>沒命中</strong></li><li>h = hit ratio</li><li>ta = TLB access time</li><li>ma = Memory access time</li></ul></li><li>Note: <code>h * (ta + ma) + (1 - h) * (ta + 2ma)</code> =&gt; <strong>4-level page table</strong></li></ul></li></ul></li></ol><h3>Segment memory management 分段式記憶體管理</h3><ul><li>觀念：<ol><li>將 logical memory 視為一組 segment 之集合, <strong>各 segment 大小不一致</strong></li><li>和 user 對 memory 的看法一致, segment 可能是 main, subroutine...等</li></ol></li><li>圖：<img src="segmentManagement.png" alt=""></li><li>配置策略：<ol><li>Segment 之間採不連續性存放</li><li>單一 Segment 採 &quot;連續性&quot;配置 (<strong>有外部碎裂</strong>)</li><li>O.S. 會替各 process 準備一 Segment Table, 其中<ul><li>Base: 存段的起始位址</li><li>Limit: 段的大小</li></ul></li></ol></li></ul><hr><h2>Summary</h2><table><thead><tr><th style="text-align:left">分析</th><th style="text-align:center">Paged</th><th style="text-align:center">Segment</th></tr></thead><tbody><tr><td style="text-align:left">優點</td><td style="text-align:center">No 外部碎裂</td><td style="text-align:center">No 內部碎裂</td></tr><tr><td style="text-align:left">缺點</td><td style="text-align:center">有內部碎裂</td><td style="text-align:center">有外部碎裂</td></tr></tbody></table><ul><li><p><strong>相同點</strong>:</p><ol><li>支援 Memory 共享</li><li>支援 Memory 保護</li><li>支援 dynamic loading, linking, binding (動態繫結, 在執行期間可動態去翻轉記憶體位置)</li><li>需額外的 hardware support</li><li>執行較慢 (因為 logical -&gt; physical address)</li></ol></li><li><p>圖：<img src="summary.png" alt=""></p></li></ul><h2>Compare</h2><table><thead><tr><th style="text-align:center">Paged</th><th style="text-align:center">Segment</th></tr></thead><tbody><tr><td style="text-align:center">No 外部碎裂, 有內部碎裂</td><td style="text-align:center">No 內部碎裂, 有外部碎裂</td></tr><tr><td style="text-align:center">Page size 一致</td><td style="text-align:center">Segment 大小不一致</td></tr><tr><td style="text-align:center">和 user 看法不一致</td><td style="text-align:center">較一致</td></tr><tr><td style="text-align:center">需給單一量的 logical address</td><td style="text-align:center">需給 s, d (2 個量)</td></tr><tr><td style="text-align:center">不需做 d &lt; limit 之 check</td><td style="text-align:center">需 check d &lt; limit</td></tr><tr><td style="text-align:center">Memory 共享, 保護, 較不易</td><td style="text-align:center">較容易</td></tr></tbody></table><hr><h2>Page segment memory management 分頁是分段記憶體管理</h2><ul><li>觀念： 先分段, 在分頁 -&gt; 最終存 page</li><li>圖：<img src="%E5%88%86%E9%A0%81%E5%88%86%E6%AE%B5.png" alt=""></li><li>優點：<ol><li>No 外部碎裂</li><li>單一段可以 &quot;不連續性存放&quot;</li></ol></li><li>缺點：<ol><li>有內部碎裂</li><li>Table size 相當大 (因為 Segment Table 及 Page Table 皆需)</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.7 記憶體管理 (Memory Management)&lt;/h1&gt;
&lt;p&gt;圖：
&lt;img src=&quot;%E8%A8%98%E6%86%B6%E9%AB%94.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Memory Allocation Strategy 記憶體配
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="Memory Management" scheme="https://pingjing0628.github.io/tags/Memory-Management/"/>
    
      <category term="Page Memory Management" scheme="https://pingjing0628.github.io/tags/Page-Memory-Management/"/>
    
      <category term="Segment Memory Management" scheme="https://pingjing0628.github.io/tags/Segment-Memory-Management/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-程序間的溝通-part2</title>
    <link href="https://pingjing0628.github.io/2021/06/20/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A8%8B%E5%BA%8F%E9%96%93%E7%9A%84%E6%BA%9D%E9%80%9A-part2/"/>
    <id>https://pingjing0628.github.io/2021/06/20/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A8%8B%E5%BA%8F%E9%96%93%E7%9A%84%E6%BA%9D%E9%80%9A-part2/</id>
    <published>2021-06-20T03:41:23.000Z</published>
    <updated>2021-06-22T12:37:59.657Z</updated>
    
    <content type="html"><![CDATA[<h1>3.6 程序間的溝通 (Process Communication)</h1><p>又稱為 <strong>inter-process communication</strong> IPC<br>方法有兩種：</p><ol><li>Shared Memory</li><li>Message Passing<br>圖：<img src="3.6.png" alt=""></li></ol><h2>目錄</h2><ul><li>Shared Memory</li><li><strong>Message Passing</strong></li></ul><hr><h2>Message Passing (訊息傳遞)</h2><ul><li>Def: 當 process 之間不易採用 Shared Memory, 則可採 Message Passing</li><li>步驟:<ol><li>先建立雙方連結</li><li>將 Message send 到收方</li><li>待收方處理後將結果接收 (receive)<br><img src="messagePass.png" alt=""></li></ol></li><li>可分為:<ul><li>直接通訊:<ul><li>對稱: 收, 送雙方皆須指名<br>ex: <code>send (process, message), receive (process, message)</code></li><li>非對稱: 送方須指名, 收方不需<br>ex: <code>send (process, message), receive (id, message)</code>, id 為接收後帶入送方的身份</li></ul></li><li>間接通訊:<ul><li>圖: <img src="messagepass2.png" alt=""></li></ul></li></ul></li></ul><ul><li>Ex: 用 Message Passing 解決 Producer (生產者 P1) / Consumer (消費者 P2) 問題 (<strong>直接通訊, 對稱式</strong>)</li></ul><pre><code>// 拿筷子wait (right);wait (left);C.S. // eatingsignal (right);siganl (left);R.S. // 放下筷子</code></pre><p><strong>Hold and wait</strong><br><strong>Circular waiting</strong><br><strong>當同時執行時, 會有 deadlock 現象, 故違反 progress</strong></p><p><strong>流程：... produce item; ...-&gt; 1. send(consumer, item); ...-&gt; 2. receive(producer, item); ...-&gt; 3. consume item;</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.6 程序間的溝通 (Process Communication)&lt;/h1&gt;
&lt;p&gt;又稱為 &lt;strong&gt;inter-process communication&lt;/strong&gt; IPC&lt;br&gt;
方法有兩種：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shared Memory&lt;/l
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Message Passing" scheme="https://pingjing0628.github.io/tags/Message-Passing/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-程序間的溝通-part1</title>
    <link href="https://pingjing0628.github.io/2021/06/20/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A8%8B%E5%BA%8F%E9%96%93%E7%9A%84%E6%BA%9D%E9%80%9A-part1/"/>
    <id>https://pingjing0628.github.io/2021/06/20/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E7%A8%8B%E5%BA%8F%E9%96%93%E7%9A%84%E6%BA%9D%E9%80%9A-part1/</id>
    <published>2021-06-20T03:41:20.000Z</published>
    <updated>2021-06-22T12:34:09.006Z</updated>
    
    <content type="html"><![CDATA[<h1>3.6 程序間的溝通 (Process Communication)</h1><p>又稱為 <strong>inter-process communication</strong> IPC<br>方法有兩種：</p><ol><li>Shared Memory</li><li>Message Passing<br>圖：<img src="3.6.png" alt=""></li></ol><h2>目錄</h2><ul><li><strong>Shared Memory</strong></li><li>Message Passing</li></ul><hr><h2>Shared Memory 分享記憶體</h2><p>Def: 指多個 process 藉由共用相同的 memory space 達到行程間溝通之效 (Multiprocessor)<br>問題：<strong>Race Condition 競爭情況</strong><br>Def: 相同的運作. 因執行順序不同, 造成處理的結果不同謂之<br>解決：<strong>Critical Section 臨界區間</strong><br>Def: 為一程式片段, 用來提供多 process 共用一 memory space 時的存取控管機制 =&gt; <strong>避免 race conditional</strong></p><h3>Critical Section Design</h3><p>格式：<br><img src="C.S.png" alt=""><br>良好的 C.S Design 需滿足：</p><ol><li>Mutual exclusion (互斥)：指同一時間只允許一個 process 進入 C.S.</li><li>Progress (可進行性)：不想進 C.S. 的 process, 不能影響其他欲進入 C.S. 之 process<ul><li>若有多個 process 欲進入 C.S., 則挑選的時間是有限的 =&gt; <strong>避免 deadlock</strong></li></ul></li><li>Bounded waiting (有限性等待)：指 n 個 process 存在於進入 C.S., 最多只需 wait n-1 次 =&gt; <strong>公平, No starvation</strong></li></ol><h3>C.S. Design 目錄</h3><ul><li>algo<ul><li>2 process =&gt; 3 algos (<strong>turn, flag</strong>)</li><li>2 process =&gt; 1 algos (<strong>turn + flag</strong>)</li></ul></li><li>Semaphore<ul><li>Binary</li><li>Counting</li></ul></li></ul><hr><h3>2 個 process 的 C.S. Design</h3><h4>algorithm1:</h4><ul><li>資料結構 (宣告變數)：<br><code>var turn: integer (0~1);</code></li><li>Pi 之程式片段：<br><img src="algo1.png" alt=""></li><li>分析：<ol><li>滿足 mutual exclusion (互斥)<br>說明：<br>當 Pi, Pj 皆欲進入 C.S., 又 turn 不會同時為 i, j (因為 i 不等於 j), 故只能一個 process 進入 C.S.</li><li>不滿足 progress (可進行性)<br>說明：<br>當 Pj 於 R.S. 中 (因為 j 就是不想上廁所), 但 <code>turn = j</code>, 此時若 Pi 想進入 C.S., 將被卡在 while loop 中無法進入 (因為違反 progress)</li></ol></li></ul><h4>algorithm2:</h4><ul><li><p>資料結構：<br><code>var flag [0...1] of Boolean;</code><br><img src="algo2Data.png" alt=""></p></li><li><p>Pi 之程式片段：<br><img src="algo2.png" alt=""></p></li><li><p>分析：</p><ol><li>滿足 mutual exclusion (互斥)<br>說明：<br>若欲使 Pi, Pj 同時進入 C.S., 則 <code>flag[i] = flag[j] = false</code>, 又當欲進入 C.S. 一開始 flag, 會改為 true, 故上述情況不可能存在</li><li>不滿足 progress (可進行性)<br>說明：<br>當 Pi, Pj 皆欲進入 C.S., 則 <code>flag[i] = flag[j] = true</code>, 此時 2 者皆會卡在 while loop 中 =&gt; deadlock, 故違反 progress</li></ol></li><li><p>中山<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag[i] &#x3D; true;</span><br><span class="line">while (flag[j]) do no-op;</span><br></pre></td></tr></table></figure>若交換上述兩行程式, 會發生什麼事？<br>Ans: 違反互斥性, 變成先問對方在舉手</p></li></ul><h4>algorithm3:</h4><ul><li><p>資料結構：<br><img src="algo3Data.png" alt=""></p></li><li><p>Pi 之程式片段：<br><img src="algo3.png" alt=""></p></li><li><p>分析：</p><ol><li>滿足 mutual exclusion (互斥)<br>說明：<br>當 2 process 皆欲進入 C.S., 則 <code>flag[i] = flag[j] = true</code>, 但 turn 不會同時為 i, j (因為 i 不等於 j), 故只有一 process 可進入 C.S.</li><li>滿足 progress (可進行性)<br>說明：<ul><li>當 Pj 不想進入 C.S., 又 <code>turn = j</code>, 且此時 <code>flag[j] = false</code>, 故當 Pi 想進入, 可以順利通過 while loop</li><li>當 2 process 皆欲進入 C.S., 此時視 turn 的值為 i 或 j, 指向者可進入 C.S., 所以 No deadlock</li></ul></li><li>滿足 Bounded Waiting (有限性等待)<br>說明：<br>當 Pi, Pj 皆欲進入 C.S., 而 <code>turn = j</code>時, 則 Pj 可進入, 若 Pj 離開後立即再度欲進入 C.S., 則：<br><code>flag[j] = true;</code><br><code>turn = i</code><br>因為 <code>turn = i</code>, 故下次必由 Pj 進入 C.S. 中</li></ol></li></ul><hr><h3>多 process 的 C.S. Design =&gt; Bakery's algorithm</h3><ul><li><p>資料結構：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var choosing: Array[0....n-1] of Boolean;</span><br><span class="line">    number: Array[0....n-1] of Integer; (initial 皆為 0)</span><br></pre></td></tr></table></figure></p></li><li><p>數字假設：</p><ol><li><code>(a, b) &lt; (c, d)</code>, if<ol><li><code>a &lt; c</code> or</li><li><code>a = c</code> 且 <code>b &lt; d</code></li></ol></li><li><code>Max(X0...Xn-1)</code> =&gt; 取 X0 ~ Xn-1 中最大值</li></ol></li><li><p>Pi 之程式片段：<img src="%E5%A4%9Aprocess.png" alt=""></p></li></ul><hr><h3>Semaphore (號誌) (可有互斥的效果)</h3><ul><li>Def: 為解決同步問題的一種機制, 本身為一整數型別 (通常初始為 1), <strong>會提供 2 個 atomically execution (不可分割, 指過程中不能被中斷) 的運作</strong><ul><li>signal</li><li>wait</li></ul></li><li>圖：<br><img src="semaphore.png" alt=""></li><li>Note:<br>Semaphore 初始值為 1 時, 則狀態永遠為 0 或 1, 故 Pj 謂之 <strong>Binary Semaphore (二元號誌)</strong></li></ul><h3>Counting Semaphore (計數號誌)</h3><p>Def: 有別於 Binary Semaphore, 於 counting semaphore 之中, 值可能為 1, 0, -1, -2....-n, <strong>若值為 -n, 代表有 n 個 process 卡在 wait 之中</strong><br>=&gt; 製作方式：</p><ol><li>用 Block, wakeup 製作</li><li>用 Binary Semaphore 製作</li></ol><h4>&lt;法一&gt;：用 Block, wakeup 及 Queue 製作</h4><ul><li>作法：將 Semaphore 定義成一 Record (紀錄) (like class)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type countingSemaphore: record</span><br><span class="line">    value: integer; &#x2F;&#x2F;initial &#x3D; 1</span><br><span class="line">    L: Queue;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li></ul><p><img src="way1.png" alt=""></p><h4>&lt;法二&gt;：用 Binary Semaphore 製作出 counting semaphore</h4><ul><li>資料結構：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var c: integer; initial &#x3D; 1 &#x2F;&#x2F; 計數器, like value, c 當 signal &amp; wait</span><br><span class="line">    S1: Binary Semaphore; initial &#x3D; 1 &#x2F;&#x2F; 對 C 做存取控制</span><br><span class="line">    S2: Binary Semaphore; initial &#x3D; 0 &#x2F;&#x2F; 用來模擬 block, wakeup 之效</span><br></pre></td></tr></table></figure></li></ul><p><img src="way2.png" alt=""></p><h4>Compare</h4><table><thead><tr><th style="text-align:left">Compare</th><th style="text-align:left">busy waiting (spinlock 盤旋鎖) 製作 counting semaphore (簡單的會使用)</th><th style="text-align:left">Block, wakeup 製作 (複雜的通常用)</th></tr></thead><tbody><tr><td style="text-align:left">優點</td><td style="text-align:left">wait 時不會有 context switching, 若為片刻等待, 適用</td><td style="text-align:left">wait 時不會用至 CPU</td></tr><tr><td style="text-align:left">缺點</td><td style="text-align:left">在 waiting 過程中, 會不斷的耗用 CPU 的資源, 所以浪費 CPU</td><td style="text-align:left">需 context switching</td></tr></tbody></table><hr><h3>思考</h3><p><img src="think.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.6 程序間的溝通 (Process Communication)&lt;/h1&gt;
&lt;p&gt;又稱為 &lt;strong&gt;inter-process communication&lt;/strong&gt; IPC&lt;br&gt;
方法有兩種：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shared Memory&lt;/l
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Shared Memory" scheme="https://pingjing0628.github.io/tags/Shared-Memory/"/>
    
      <category term="Critical Section" scheme="https://pingjing0628.github.io/tags/Critical-Section/"/>
    
      <category term="Semaphore" scheme="https://pingjing0628.github.io/tags/Semaphore/"/>
    
      <category term="Counting Semaphore" scheme="https://pingjing0628.github.io/tags/Counting-Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-死結deadlock-part2</title>
    <link href="https://pingjing0628.github.io/2021/06/19/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E6%AD%BB%E7%B5%90deadlock-part2/"/>
    <id>https://pingjing0628.github.io/2021/06/19/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E6%AD%BB%E7%B5%90deadlock-part2/</id>
    <published>2021-06-19T03:16:05.000Z</published>
    <updated>2021-06-19T08:53:02.834Z</updated>
    
    <content type="html"><![CDATA[<h1>3.5 死結 Deadlock</h1><h2>目錄</h2><ul><li>四要件</li><li><strong>Deadlock 處理方式</strong></li><li><strong>Deadlock Free</strong></li></ul><hr><h2>deadlock 處理</h2><ol><li>Preventation 預防：欲使 deadlock 不會發生<br>作法：大破四要件之一</li><li>Avoidance 避免：利用避免演算法確保資源分配不會產生 deadlock<br>作法：Banker's algo. check 安全否</li><li>Detection &amp; Recovery 偵測, 若有恢復</li></ol><h3>Deadlock Preventation =&gt; 打破四要件之一 (打破其中一個即可)</h3><ol><li><strong>打破 &quot;互斥&quot;</strong></li></ol><ul><li><strong>難達成, 因為此為資源先天的限制</strong>, ex: 印表機</li></ul><ol start="2"><li><strong>打破 &quot;Hold and Wait&quot;</strong> (要就全拿, 不要就都不拿)</li></ol><ul><li>作法 1: process 若無法取得, 所需的所有資源, 則需空手</li><li>作法 2: 提出申請時, 需將手中持有的資源 release</li><li>圖：<img src="%E6%89%93%E7%A0%B4Hold&amp;wait.png" alt=""></li></ul><ol start="3"><li><strong>打破 &quot;No preemptive&quot; =&gt; 將之改為 preemptive</strong></li></ol><ul><li>不建議, 因為資源先天限制, ex: 印表機, 印了 3 行被搶奪</li></ul><ol start="4"><li><strong>打破 Circular Waiting</strong></li></ol><ul><li>作法 1:<ul><li>給予各 resource 一獨立編號</li><li>資源申請須以編號遞增的方式提出</li><li>圖：<img src="%E6%89%93%E7%A0%B4circular1.png" alt=""><img src="%E6%89%93%E7%A0%B4circular2.png" alt=""></li></ul></li><li>反證：令仍然會有 Circular waiting, 假設滿足 2 條件下, 則存在如下的 waiting cycle:<img src="%E5%8F%8D%E8%AD%89.png" alt=""></li></ul><h3>Deadlock Avoidance</h3><ul><li>圖：<img src="deadlockAvoidance.png" alt=""></li><li>Note:<ul><li>Safe state (安全狀態):<br>指可以找到 &gt;= 1 組執行順序, 確保所有的 process 皆可執行完畢<br>Ex: 5 process (P0 ~ P4) =&gt; <code>P2-&gt;P4-&gt;P1-&gt;P0-&gt;P3</code></li><li>Unsafe state:<br>指找不到上述一組執行的順序謂之<br>Ex: <code>P2-&gt;P4-&gt;.....?</code></li></ul></li></ul><h4>Avoidance algo.</h4><ul><li><p>資源皆單一量 =&gt; 修改資源分配圖</p></li><li><p>資源非單一量 =&gt; Banker's algo. <code>m * n^2</code>, O(n^2) 效率較佳</p><ul><li>m = 資源種類數 (印表機, disk, 螢幕) , n = process 數量</li></ul></li><li><p>Note: Resource Allocation Graph 資源分配圖<br>Def: 一圖形 G = &lt;V, E&gt;, 其中 V 為頂點, E 為邊</p><ul><li>V 分為：<img src="V.png" alt=""></li><li>E 分為：<img src="E.png" alt=""></li><li>在 Resource Allocation Graph 中的性質<ol><li>當資源皆為單一量 -&gt; 有 cycle, 有 deadlock</li><li>當資源非單一量 -&gt; 有 cycle, &quot;不見得有 deadlock&quot;<ul><li>圖：<img src="resourceAllocate.png" alt=""></li></ul></li></ol></li></ul></li></ul><ol><li>資源皆為單一量的 avoidance algo.<br>於 Resource Allocation Graph 中多加入一種邊 &quot;chian edge&quot; 鏈結邊, Pi...Rj =&gt; 指 Pi 在未來會對 Rj 提出申請<ul><li>判別： <strong>Pi 正式對 Rj 提申請</strong><ol><li>先作暫時性配置<br><img src="PiToRj.png" alt=""></li><li>Check 是否有 cycle<ul><li>有 -&gt; Unsafe</li><li>無 -&gt; Safe</li></ul></li></ol></li><li>Ex: 若 P2 對 R2 正式提出申請, 是否可以？<br>圖：<img src="%E5%96%AE%E4%B8%80%E9%87%8Fex.png" alt=""><br>Sol: 有 cycle, 故 unsafe state, 所以申請駁回 (若 P1 則可以)</li></ul></li></ol><ol start="2"><li>Banker's algo. 題型<br>Ex: 系統有 5 個 process {P0...P4}, 三種 resource {A, B, C}, A = 10, B = 5, C = 7, 令時間 T0 時如下圖, 問若 P1 提出 Request1 = (1, 0, 2), 是否可配置？<br>圖：<img src="%E6%9A%AB%E6%99%82%E6%80%A7%E9%85%8D%E7%BD%AE1.png" alt=""><br>Sol:<ul><li><p>Step 1: Need = Max - Allocation (Need: 指 process i 最多尚需多少資源才能完成工作)</p></li><li><p>Step 2:<br>Request i (1, 0, 2) &lt;= Need i (1, 2, 2)<br>Request i (1, 0, 2) &lt;= Available i (3, 3, 2)</p></li><li><p>Step 3: 暫時性配置<br>圖：<img src="%E6%9A%AB%E6%99%82%E6%80%A7%E9%85%8D%E7%BD%AE2.png" alt=""></p></li><li><p>找執行順序：P1 -&gt; P3 -&gt; P4 -&gt; P0 -&gt; P2,<br>因為找到執行的順序, 故為 safe state =&gt; <strong>故申請核準</strong></p></li></ul></li></ol><hr><h3>Deadlock detection algo</h3><ul><li>資源皆單一量：<strong>修改資源分配圖 (&quot;Wait-for&quot; graph) =&gt; O(n^2)</strong></li><li>資源非單一量：<strong>deadlock detection algo. =&gt; O(m * n^2)</strong></li></ul><h4>Deadlock detection &amp; recovery (資源皆單一量 =&gt; 採&quot;Wait-for&quot; graph 等候圖)</h4><ul><li>Def: 定期偵測系統是否有 deadlock, 若有則須設法做 deadlock recovery 的動作</li><li>說明: 將 Resource Allocation Graph 中的<br><img src="desc.png" alt=""></li><li>Check: <code>有 cycle =&gt; 有 deadlock</code>, <code>No cycle =&gt; No deadlock</code></li><li>Ex:<img src="deadlockDetection.png" alt=""></li></ul><h4>Deadlock recovery</h4><ul><li>由 user 自己處理</li><li>由系統處理<ul><li>全砍：<ul><li>優點：簡單</li><li>缺點：成本高</li></ul></li><li>一次砍一個：<ul><li>優點：成本低</li><li>缺點：複雜</li></ul></li></ul></li></ul><hr><h2>deadlock free</h2><p>Def: 在此條件下, 系統沒有 deadlock 問題, 故不需對其做處理, <strong>欲滿足 deadlock free</strong>, 則：</p><ol><li>1 &lt;= Max i &lt;= m (資源數量)</li><li>總和(i=1至n) Max i &lt; m + n (n 為 process 數), <strong>process i 完成工作最多所需的資源數</strong></li></ol><p>Ex:</p><ul><li>6 台印表機 each process 完成工作最多需 ? 台 printer?</li><li>問系統中在 deadlock free 下, 最多可有多少 process ?<br>Sol:</li></ul><ol><li>1 &lt;= Max i &lt;= m =&gt; 1 &lt; <strong>2</strong> &lt;= 6</li><li>總和(i=1至n) Max i &lt; m + n =&gt; 2n &lt; 6 + n, 所以 n &lt; 6, 故 n 最大為 5</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.5 死結 Deadlock&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;四要件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deadlock 處理方式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deadlock Free&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Deadlock" scheme="https://pingjing0628.github.io/tags/Deadlock/"/>
    
      <category term="Deadlock free" scheme="https://pingjing0628.github.io/tags/Deadlock-free/"/>
    
      <category term="Starvation" scheme="https://pingjing0628.github.io/tags/Starvation/"/>
    
      <category term="Preventation" scheme="https://pingjing0628.github.io/tags/Preventation/"/>
    
      <category term="Avoidance" scheme="https://pingjing0628.github.io/tags/Avoidance/"/>
    
      <category term="Detection" scheme="https://pingjing0628.github.io/tags/Detection/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-死結deadlock-part1</title>
    <link href="https://pingjing0628.github.io/2021/06/18/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E6%AD%BB%E7%B5%90deadlock-part1/"/>
    <id>https://pingjing0628.github.io/2021/06/18/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E6%AD%BB%E7%B5%90deadlock-part1/</id>
    <published>2021-06-18T09:00:22.000Z</published>
    <updated>2021-06-19T06:20:48.753Z</updated>
    
    <content type="html"><![CDATA[<h1>3.5 死結 Deadlock</h1><h2>目錄</h2><ul><li><strong>四要件</strong></li><li>Deadlock 處理方式</li><li>Deadlock Free</li></ul><hr><h2>四要件</h2><ol><li><strong>Mutual Exclusion 互斥</strong><br>Def: 指資源同時只允許一個 process 使用之, ex: printer, card reader</li><li><strong>Hold &amp; Wait 持有並等待</strong><br>Def: 指一 process 取得部分資源, 又在等其他資源<br>圖：<img src="Hold&amp;wait.png" alt=""></li><li><strong>No preemptive</strong><br>Def: 指一旦 process 取得某資源, 則其他的 process 無法搶奪, 除非其自願放棄</li><li><strong>Circular waiting 循環式等待</strong><br>Def: 只存在一組 process, 形成如下的 waiting cycle:<br><img src="circularWaiting.png" alt="">Note: Pi -&gt; Pj =&gt; Process i 在等 Process j 手中的資源</li></ol><ul><li>Ex: 令資源具 Mutual Exclusiion 跟 No preemptive, 則<br><img src="deadlock.png" alt=""></li></ul><hr><h2>Compare</h2><table><thead><tr><th style="text-align:left">Description</th><th style="text-align:left">Deadlock</th><th style="text-align:left">Starvation</th></tr></thead><tbody><tr><td style="text-align:left">定義</td><td style="text-align:left">存在一組 process, 形成 wait cycle, 使 cycle 內之 process 皆不可使用 CPU (因為皆 wait)</td><td style="text-align:left">low priority 的 process 長期或無限期無法取得 CPU</td></tr><tr><td style="text-align:left">影響</td><td style="text-align:left">CPU utilization 跟 throughput 大幅下降</td><td style="text-align:left">不見得</td></tr><tr><td style="text-align:left">起因</td><td style="text-align:left">資源分配不當</td><td style="text-align:left">當有 priority 之分</td></tr><tr><td style="text-align:left">解決</td><td style="text-align:left">deadlock 預防, 避免, 偵測與恢復</td><td style="text-align:left">Aging Tech 老化現象</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.5 死結 Deadlock&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;四要件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Deadlock 處理方式&lt;/li&gt;
&lt;li&gt;Deadlock Free&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;四要件&lt;/h2
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Deadlock" scheme="https://pingjing0628.github.io/tags/Deadlock/"/>
    
      <category term="Deadlock free" scheme="https://pingjing0628.github.io/tags/Deadlock-free/"/>
    
      <category term="Starvation" scheme="https://pingjing0628.github.io/tags/Starvation/"/>
    
      <category term="Preventation" scheme="https://pingjing0628.github.io/tags/Preventation/"/>
    
      <category term="Avoidance" scheme="https://pingjing0628.github.io/tags/Avoidance/"/>
    
      <category term="Detection" scheme="https://pingjing0628.github.io/tags/Detection/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-行程-part3</title>
    <link href="https://pingjing0628.github.io/2021/06/12/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A1%8C%E7%A8%8B-part3/"/>
    <id>https://pingjing0628.github.io/2021/06/12/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A1%8C%E7%A8%8B-part3/</id>
    <published>2021-06-12T15:43:16.000Z</published>
    <updated>2021-06-19T06:14:33.069Z</updated>
    
    <content type="html"><![CDATA[<h1>3.4 行程</h1><h2>目錄</h2><ul><li>Process Definition</li><li>Program vs Process</li><li>Process STD</li><li>PCB, context switching</li><li>CPU Scheduling algorithm</li><li><strong>Thread 執行緒</strong></li></ul><hr><h2>Thread (執行緒) (為執行的最小單位)</h2><p><img src="processvsthread.png" alt=""></p><h2>Compare process and thread</h2><table><thead><tr><th style="text-align:left">Process</th><th style="text-align:left">Thread</th></tr></thead><tbody><tr><td style="text-align:left">Heavy weight process</td><td style="text-align:left">Light weight process</td></tr><tr><td style="text-align:left">各 process 無法共享：Memory space, O.S. Resource, Files</td><td style="text-align:left">同一 Task 中的 Threads 可共用</td></tr><tr><td style="text-align:left"><strong>Context Switching 重</strong></td><td style="text-align:left"><strong>Context Switching 輕</strong></td></tr><tr><td style="text-align:left">相當於一 Task 中, 只有 single thread</td><td style="text-align:left">有 <strong>multithread</strong> 多執行緒系統</td></tr><tr><td style="text-align:left">較不易發揮</td><td style="text-align:left">在 <strong>Multiprocessor 的架構</strong>, 可充分發揮其效能</td></tr><tr><td style="text-align:left">因為無共享 Memory, 故不需處理 Race condition</td><td style="text-align:left">會共享 Memory, 故須針對 <strong>Race Condition 競爭情況</strong> 作處理</td></tr></tbody></table><hr><h2>Thread (執行緒) 製作方式</h2><ul><li>User level: 由 user-level 自行處理, 藉由執行緒程式庫來對 thread 之運作加以管理, kernel 不需介入</li><li>Kernel level: 由 kernel-level 著手處理 thread 的相關運作<br><img src="thread%E8%A3%BD%E4%BD%9C%E6%96%B9%E5%BC%8F.png" alt=""></li></ul><hr><h2>Compare multitasking and multithreading</h2><p><img src="multitaskingvsmultithreading.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.4 行程&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Process Definition&lt;/li&gt;
&lt;li&gt;Program vs Process&lt;/li&gt;
&lt;li&gt;Process STD&lt;/li&gt;
&lt;li&gt;PCB, context switching&lt;/li
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Process" scheme="https://pingjing0628.github.io/tags/Process/"/>
    
      <category term="Thread" scheme="https://pingjing0628.github.io/tags/Thread/"/>
    
      <category term="Multitasking" scheme="https://pingjing0628.github.io/tags/Multitasking/"/>
    
      <category term="Multithreading" scheme="https://pingjing0628.github.io/tags/Multithreading/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-行程-part2</title>
    <link href="https://pingjing0628.github.io/2021/06/12/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A1%8C%E7%A8%8B-part2/"/>
    <id>https://pingjing0628.github.io/2021/06/12/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A1%8C%E7%A8%8B-part2/</id>
    <published>2021-06-12T15:33:58.000Z</published>
    <updated>2021-06-17T12:25:01.453Z</updated>
    
    <content type="html"><![CDATA[<h1>3.4 行程</h1><h2>目錄</h2><ul><li>Process Definition</li><li>Program vs Process</li><li>Process STD</li><li>PCB, context switching</li><li><strong>CPU Scheduling algorithm</strong></li><li>Thread 執行緒</li></ul><hr><h2>CPU Scheduling algorithms</h2><p>=&gt; 針對 <strong>STS</strong> 從 <strong>Ready Queue</strong> 挑出一 process 獲得 CPU 之挑選策略方法</p><ul><li>FIFO</li><li>SJF</li><li>SRJF</li><li>Priority</li><li>RR</li><li>Multilevel Queue</li><li>Multilevel Feedback Queue</li></ul><hr><ol><li><strong>FIFO First-In First-Out</strong><br>Def: 愈先到達 Ready Queue 的 process, 先獲得 CPU</li></ol><ul><li><p>Non-preemptive (不可搶奪)<br>優點：</p><ul><li>公平性 (Fair)</li><li>easy to implement</li><li><strong>No starvation 飢餓</strong><br>Def: 指 low priority 之 process 長期或無限期無法取得 CPU 之服務</li></ul><p>缺點：</p><ul><li>效益不佳 (因為 A.W.T &amp; A.T.T 慢)</li><li>會有 <strong>convoy effect (護衛效應)</strong><br>指多個 process 在 wait 一個需長時間執行之 process =&gt; <strong>造成 A.W.T 大幅上升</strong></li><li>Note:<br>A.W.T: Average Waiting time<br>A.T.T: Average Turnaround time (結束時間)</li></ul></li><li><p>Example: CPU Scheduling algorithms 的衡量準則 (performance criteria 效能準則)<br>Sol:</p><ol><li>CPU utilization -&gt; 看 CPU 使用率</li><li>CPU throughput -&gt; 看 CPU 單位生產量</li><li><strong>Waiting time 等候時間</strong><br>Def: 自 process 交付系統到結束, 總共在 Ready Queue 等了多久</li><li><strong>Turnaround time 回覆時間</strong><br>Def: 自 process 交付系統到結束, 總共需多少時間</li><li>Response time (反應)<br>Def: 指 process 自交付系統到第一次獲得回應的時間 -&gt; <strong>interactive system care about this</strong><br>Note: <code>1. ~ 2.</code> 愈高愈好, <code>3. ~ 5.</code>時間愈短愈好</li></ol></li><li><p>Ex: 採 FIFO,</p><table><thead><tr><th style="text-align:center">Process</th><th style="text-align:center">CPU Burst time (CPU 花費時間)</th><th style="text-align:center">CPU arrive time</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">24</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">3</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">3</td><td style="text-align:center">0</td></tr></tbody></table><p>Sol:<br>A.W.T = <code>(0 + 24 + 27) / 3 = 17</code><br>A.T.T = <code>(24 + 27 + 30) / 3 = 27</code></p></li></ul><ol start="2"><li><strong>SJF (Shortest Job First) 最短工作先做</strong><br>Def: 指所需的 CPU 時間愈短, 愈先獲得 CPU 之服務</li></ol><ul><li><strong>Non-preemptive</strong><br>優點：<ul><li>效益最佳 (A.W.T &amp; A.T.T 短)</li><li>No convoy effect</li><li><strong>適用於 LTS</strong>缺點：</li><li>No fair</li><li>可能會有 <strong>starvation</strong></li><li>不適用於 STS (預測 process 時間耗時) -&gt; 一般拿來當理論依據值</li></ul></li></ul><ol start="3"><li><strong>SRJF (Shortest Remaining Time Job First) 最短剩餘時間工作先做</strong><br>Def: 同 2. , 但為 preemtpive, 且 Context Switching 較重</li></ol><ul><li><p>ex:</p><table><thead><tr><th style="text-align:center">Process</th><th style="text-align:center">CPU Burst time (CPU 花費時間)</th><th style="text-align:center">CPU arrive time</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">8</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">9</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">5</td><td style="text-align:center">3</td></tr></tbody></table><p>分別採 SJF &amp; SRJF, 求 A.W.T &amp; A.T.T = ?<br><img src="%E6%B5%81%E7%A8%8B.png" alt="">Sol:</p><ol><li>SJF<br><img src="exSJF.png" alt=""><br>A.W.T = <code>(0 - 0 + 8 - 1 + 17 - 2 + 12 - 3) / 4 = 7.75</code><br>A.T.T = <code>(8 - 0 + 12 - 1 + 26 - 2 + 17 - 3) / 4 = 14.25</code></li><li>SRJF<img src="exSRJF.png" alt=""><br>A.W.T = <code>(0 - 0 + 10 - 1 + 1 - 1 + 17 - 2 + 5 - 3) / 4 = 6.5</code><br>A.T.T = <code>(17 - 0 + 5 - 1 + 26 - 2 + 10 - 3) / 4 = 13</code></li></ol></li><li><p>Compare</p><table><thead><tr><th style="text-align:center">Preemptive (SRJF)</th><th style="text-align:center">Non-preemptive scheduling (SJF)</th></tr></thead><tbody><tr><td style="text-align:center">Process 取得 CPU 後, 過程可能被其他 process 將 CPU 搶走</td><td style="text-align:center">一旦 process 取得 CPU, 除非自願放棄, 否則其他process 不能搶</td></tr><tr><td style="text-align:center"><strong>適用於即時, 交談式</strong></td><td style="text-align:center"><strong>對 job 較公平</strong>, <strong>Reponse time 較可預期</strong></td></tr><tr><td style="text-align:center"><strong>Context switching 重 (缺點)</strong></td><td style="text-align:center"><strong>Context switching 輕 (優點)</strong></td></tr><tr><td style="text-align:center"><strong>A.W.T &amp; A.T.T 短 (優點)</strong></td><td style="text-align:center"><strong>A.W.T &amp; A.T.T 長 (缺點)</strong></td></tr></tbody></table></li></ul><ol start="4"><li><strong>Priority Scheduling (優先權排列法則)</strong><br>Def: priority 愈高者, 愈先取得 CPU 之服務</li></ol><ul><li>Special case:<ol><li>Arrive time 越短, Priority 越高 =&gt; FIFO</li><li>CPU Burst time 越短, Priority 越高 =&gt; SJF</li></ol></li><li>又可分為：<ul><li>Preemptive =&gt; 易造成 starvation<ul><li><strong>Solution: 採 &quot;Aging Technique&quot; (老化技術)</strong><br>Def: 指每隔一段時間逐步將 low priority 之 process 的 優先權提高</li></ul></li><li>Non-preemptive =&gt; 當 priority 相同 =&gt; 採 FIFO</li></ul></li><li>Ex: 採 priority 求 A.W.T &amp; A.T.T ?<table><thead><tr><th style="text-align:center">Process</th><th style="text-align:center">CPU Burst time (CPU 花費時間)</th><th style="text-align:center">Priority (編號小, priority 高)</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">10</td><td style="text-align:center">3 No.3</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">1</td><td style="text-align:center">1 No.2</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">2</td><td style="text-align:center">3 No.4</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">1</td><td style="text-align:center">4 No.5</td></tr><tr><td style="text-align:center">P5</td><td style="text-align:center">5</td><td style="text-align:center">2 No.2</td></tr></tbody></table>Sol:<br><img src="expriority.png" alt=""><br>A.W.T = <code>(6 + 0 + 16 + 18 + 1) / 5 = 8.2</code><br>A.T.T = <code>(16 + 1 + 18 + 19 + 6) / 5 = 12</code></li></ul><ol start="5"><li><strong>Round-Robin (R.R)</strong></li></ol><ul><li><p>Def: 指輪流給各 process 一固定時間</p><ul><li>時間到就得將 CPU 交由下一個 process 執行</li><li>具下列特色：<ol><li>Fair</li><li>preemptive</li><li>Non-starvation</li></ol></li></ul></li><li><p>Special Case:</p><ol><li>CPU time slice (時間週期) 約等於無限 =&gt; <strong>FIFO</strong></li><li>CPU time slice 極小 =&gt; <strong>CPU Sharing</strong>, <strong>But Context Switching 非常重</strong></li></ol></li><li><p>Ex: 採 R.R time slice = 5, 求 A.W.T &amp; A.T.T ?</p><table><thead><tr><th style="text-align:center">Process</th><th style="text-align:center">CPU Burst time (CPU 花費時間)</th><th style="text-align:center">CPU arrive time</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">8</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">7</td><td style="text-align:center">6</td></tr></tbody></table><p>Sol:<br><img src="exRR.png" alt="">A.W.T = <code>(0 - 0 + 7 - 5 + 5 - 3 + 10 - 6) / 3 = 8/3</code><br>A.T.T = <code>(10 + 7 - 3 + 17 - 6) / 3 = 25/3</code></p></li></ul><ol start="6"><li><strong>Multilevel Queue (多重佇列)</strong></li></ol><ul><li>Def:<ul><li>將 Ready Queue 拆成多個 Queue</li><li>Queue 之間採 preemptive priority scheduling</li><li>各 Queue 可採用自己的排班法則</li></ul></li><li>優點：可依 process 屬性將之放置到適當的位置</li><li>缺點：此方法下, process 無法於 Queue 之間移動, 故會有 <strong>starvation</strong> 之問題</li><li>圖：<img src="multilevelQueue.png" alt=""></li></ul><ol start="7"><li><strong>Multilevel Feedback Queue (多層回饋佇列)</strong><br>Def: 同 6. , 但 <strong>process 可於 Queue 之間挪動</strong><br>策略：<ol><li>於下層的 process 每隔一段時間往上一層移動</li><li>於上層的 process 不需 CPU 時逐步往下層移動</li></ol></li></ol><hr><ul><li>Summary<img src="summary.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.4 行程&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Process Definition&lt;/li&gt;
&lt;li&gt;Program vs Process&lt;/li&gt;
&lt;li&gt;Process STD&lt;/li&gt;
&lt;li&gt;PCB, context switching&lt;/li
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Process" scheme="https://pingjing0628.github.io/tags/Process/"/>
    
      <category term="CPU Scheduling" scheme="https://pingjing0628.github.io/tags/CPU-Scheduling/"/>
    
      <category term="algorithm" scheme="https://pingjing0628.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-行程-part1</title>
    <link href="https://pingjing0628.github.io/2021/06/12/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A1%8C%E7%A8%8B-part1/"/>
    <id>https://pingjing0628.github.io/2021/06/12/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E8%A1%8C%E7%A8%8B-part1/</id>
    <published>2021-06-12T15:14:09.000Z</published>
    <updated>2021-06-16T08:50:32.270Z</updated>
    
    <content type="html"><![CDATA[<h1>3.4 行程</h1><h2>目錄</h2><ul><li><strong>Process Definition</strong></li><li><strong>Program vs Process</strong></li><li><strong>Process STD</strong></li><li><strong>PCB, context switching</strong></li><li>CPU Scheduling algorithm</li><li>Thread 執行緒</li></ul><hr><h2>Process Definition</h2><p>執行中的程式 (即：程式碼 + 當前執行環境)</p><ul><li>執行環境為：<ul><li>CPU register 暫存器</li><li>Programming counter 程式計數器</li><li>Stack</li><li>Process state 狀態</li><li>Data section</li><li>Code section</li></ul></li></ul><hr><h3>Program and Process Compare</h3><table><thead><tr><th style="text-align:center">Program</th><th style="text-align:center">Process</th></tr></thead><tbody><tr><td style="text-align:center">Passive 被動</td><td style="text-align:center">Active 主動</td></tr><tr><td style="text-align:center">A field stored in the disk</td><td style="text-align:center">有 programming counter</td></tr></tbody></table><hr><h2>Process STD (State Transitive Diagram) 行程狀態轉換圖</h2><h2><img src="STD.png" alt=""></h2><h2>Scheduler 種類</h2><ol><li><strong>LTS (Long Term Scheduler)</strong><br>Def: 從 Job Queue 挑選 Job 進入 Memory 之中, 使其來到 Ready 的狀態<br>特色：<ol><li>執行頻率不高</li><li>可控制 Multiprogramming Degree (分支度) 大小</li><li>可挑 I/O 和 CPU bounded job 為一適當比例</li><li>批次常用, 分時, 即時少用</li></ol></li><li><strong>STS (Short Term Scheduler)</strong><br>Def: 從 Ready Queue 挑一 process, 使之獲得 CPU, 進入 Running 狀態<br>特色：<ol><li>執行頻率高</li><li>各系統皆使用 (因為每個系統皆有 CPU, 因此需要)</li></ol></li><li><strong>MTS (Medium Term Scheduler)</strong><br>Def: 當 Memory 不足時, 由 MTS 挑部分的 process 將之 swap out, 待日後 Memory 有空間時, 再將之 swap in<br>MTS 所挑選的部分為：1. priority 低的 process 2. waiting time 過長<br>圖：<img src="MTS.png" alt=""></li></ol><hr><h2>PCB (Process Control Block)</h2><p>Def: 為方便管理 process 的相關資訊, 故將之集合成一記錄區塊, 謂之 PCB<br>圖：<img src="PCB.png" alt=""></p><hr><h2>Context Switching (內文轉換)</h2><p>Def: 當 process P1 需 wait I/O 時, 則 CPU 將切換給 P2, 此時需將 P1 的 PCB 保存, P2 的 PCB 載入<br>影響 context switching 效能大多為硬體的層次如：</p><ul><li>CPU register 數量</li><li>Memory access speed</li><li>是否提供特殊指令<br>圖示：<img src="contextSwitching.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.4 行程&lt;/h1&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Process Definition&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Program vs Process&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proce
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Process" scheme="https://pingjing0628.github.io/tags/Process/"/>
    
      <category term="STD" scheme="https://pingjing0628.github.io/tags/STD/"/>
    
      <category term="Scheduler" scheme="https://pingjing0628.github.io/tags/Scheduler/"/>
    
      <category term="PCB" scheme="https://pingjing0628.github.io/tags/PCB/"/>
    
      <category term="context switching" scheme="https://pingjing0628.github.io/tags/context-switching/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-作業系統結構</title>
    <link href="https://pingjing0628.github.io/2021/06/06/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%B5%90%E6%A7%8B/"/>
    <id>https://pingjing0628.github.io/2021/06/06/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%B5%90%E6%A7%8B/</id>
    <published>2021-06-06T15:12:32.000Z</published>
    <updated>2021-06-12T15:12:47.469Z</updated>
    
    <content type="html"><![CDATA[<h1>3.3 作業系統結構</h1><p><img src="structure.png" alt=""></p><hr><h2>Command Interpreter 命令直譯器</h2><ul><li>Def: 接收 user 輸入命令, 加以判別：<ol><li>正確 =&gt; 呼叫對應的 <strong>&quot;Command procedure&quot;</strong></li><li>不正確 =&gt; Output error</li></ol></li><li>分為:</li></ul><ol><li><strong>Intergrated part of O.S.</strong> =&gt; command procedure 整合到 O.S. 之中<br>優點：速度快 (因為所有 command procedure 已於 O.S., 故在 Monitor Area (Memory) 之中)<br>缺點：可擴充性低 (彈性差)</li><li><strong>Isolated part of O.S.</strong> =&gt; 將 command procedure 獨立於 O.S. 之外<br>優點：可擴充性佳 (彈性好)<br>缺點：速度較慢 (因為可能需做 I/O &lt;-&gt; Memory 的傳輸)</li></ol><hr><h2>System Call 系統呼叫</h2><p>Def: 作為 user program 與 O.S. 溝通的介面</p><ul><li>類似 function 或 subroutine, 但為系統所擁有</li></ul><hr><h2>Kernel 核心程式</h2><ul><li>負責多個 process 運作上的協調, 管理等</li><li>負責底層 Hardware 資源的分配及管理<br>分為：巨核心 和 微核心<img src="kernel_compare.png" alt=""></li></ul><hr><h2>Virtual Machine 虛擬機器</h2><ul><li>Def: 藉由模擬技術, 創造一份與底層硬體完全一致的 copy (複製), 以達 Virtual Machine 之效</li><li>可利用資源共享的技術產生許多 Virtual Machine:<ol><li>CPU Scheduling =&gt; 共享 CPU</li><li>用 &quot;Virtual Memory&quot; =&gt; 共享 Memory Space</li><li>用 Spooling =&gt; 共用 I/O Device</li></ol></li><li>Virtual Machine 種類：<ul><li>type 1: 原生型 Virtual Machine =&gt; 概念同上, 各 Virtual Machine 直接面對底層的硬體<br>優點：Virtual Machine 可直接跟 Hardware 溝通 =&gt; 效率佳<br>缺點：Virtual Machine 間缺乏統一管理的機制, 故較不便<br>圖：<img src="%E5%8E%9F%E7%94%9F%E5%9E%8B.png" alt=""></li><li>type2: 寄生型 Virtual Machine =&gt; 各 Virtual Machine 會由一 O.S. 統一管理<br>優點：具統一管理各 Virtual Machine 機制, 所以較方便<br>缺點：Virtual Machine 須經中介者, 方可跟 hardware 溝通, 所以效率較差<br>圖：<img src="%E5%AF%84%E7%94%9F%E5%9E%8B.png" alt=""></li></ul></li><li>Note: 在 Cloud 的 Iaas 之下, 資源的 <strong>&quot;Virtualization&quot;</strong> 大為盛行, 一般會採用 Virtual Machine 的技術, 使得<strong>資源利用率</strong>發揮最大效益</li></ul><hr><h2>Bootstrap Loader 靴帶載入程式 (BIOS - Basic Input Output System)</h2><p>Def: 為一小程式, 於開機時執行, 一般放於 ROM 中 (space 小), 執行過程會帶出 O.S. Kernel 所在, 以便後續開機做來可順利運行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.3 作業系統結構&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;structure.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Command Interpreter 命令直譯器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Def: 接收 user 輸入命令, 加以判別：
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="Kernel" scheme="https://pingjing0628.github.io/tags/Kernel/"/>
    
      <category term="Virtual Machine" scheme="https://pingjing0628.github.io/tags/Virtual-Machine/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3-作業系統-電腦系統結構</title>
    <link href="https://pingjing0628.github.io/2021/06/03/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E9%9B%BB%E8%85%A6%E7%B3%BB%E7%B5%B1%E7%B5%90%E6%A7%8B/"/>
    <id>https://pingjing0628.github.io/2021/06/03/Chapter3-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-%E9%9B%BB%E8%85%A6%E7%B3%BB%E7%B5%B1%E7%B5%90%E6%A7%8B/</id>
    <published>2021-06-03T09:50:24.000Z</published>
    <updated>2021-06-06T15:10:55.479Z</updated>
    
    <content type="html"><![CDATA[<h1>3.2 電腦系統結構</h1><h2>I/O process 方式</h2><h3>Polling I/O (詢問式) 又稱 busy wait 或 &quot;programmed I/O&quot;</h3><p>Def:</p><ul><li>當一 process 需 wait I/O, <strong>過程中 CPU 需不斷反覆詢問 I/O 是否完成</strong></li><li>若過程中將 CPU 切換給其他 process, 可能造成<strong>資料遺失</strong>的現象</li></ul><h3>Interrupt I/O (中斷式)</h3><p>Def: 當 process 需 wait I/O 由 <strong>Device Controller 負責監督 I/O 是否完成</strong>, 若完成則通知 O.S. 接手處理 5 ~ 8<br><img src="interrupt_IO.png" alt="">Note: 過程中 CPU 不需介入故可切給另一 process 專心處理之<br>Interrupt vector table<img src="interrupt_IO_ISR.png" alt=""><strong>ISR: Interrupt Service Routine(中斷服務常式)</strong></p><p><img src="interrupt_vs_dma.png" alt=""></p><p>說明：</p><ul><li>採 interrupt 時, &quot;I/O 和 Mem 傳輸&quot;, CPU 需參與監督, 改良後 next</li><li>採 DMA (Direct Memory Access 直接記憶體存取)Def: 由 DMA Controller 負責 I/O 和 Mem. 傳輸 <strong>(CPU 不需介入)</strong></li></ul><h3>DMA 會採用 &quot;Cycle stealing&quot; 的技術</h3><ul><li>週期竊取: 偷取 FO 和 WM 此 2 週期說明：<img src="cycle_stealing.png" alt=""><br>Note: DMA 適用於高速的 I/O Device (ex: disk)</li></ul><h3>Summary</h3><p><img src="summary.png" alt=""></p><h2>中斷種類</h2><p><img src="%E4%B8%AD%E6%96%B7%E7%A8%AE%E9%A1%9E.png" alt=""><br>Note: (Non-maskable interrupt) =&gt; NMI 不可遮蔽式中斷</p><ul><li>為 Priority 最高的 interrupt</li><li>O.S. 需無條件接收, 且立即執行之 (Hardware error)</li></ul><h2>Hardware Protection</h2><h3>I/O protection</h3><ul><li><p>目的：避免 user program 直接存取 I/O resource</p></li><li><p>圖示：<img src="hardware_protection.png" alt=""></p></li><li><p>作法：</p><ol><li>採用 <strong>&quot;Dual Mode&quot;</strong>, 將 I/O 相關的指令, 設為特權指令</li><li>避免 user program 去改變中斷向量表或 ISR</li></ol></li><li><p>Dual Mode (雙重模式)<img src="dual_mode.png" alt=""></p></li><li><p>Ex: 下列哪些為特權指令(O.S.)？</p><ol><li>setup timer</li><li>read clock</li><li>clear mem,</li><li>close interrupt</li><li>mode switch<br>Sol: 1, 3, 4, 5</li></ol></li></ul><h3>CPU protection</h3><ul><li>目的：避免 CPU 長期被某個 process 持有</li><li>作法：設定一個 Timer (計時器), 一旦 process 取得 CPU 就開始倒數, 當時間為 0 , 則換其他 process 執行</li></ul><h3>Memory protection</h3><ul><li>目的：避免 user program 之執行影響到其他的 user program 或 monitor program (O.S.) 之執行</li><li>圖：<img src="memory_protection_pur.png" alt=""></li><li>分成：<ol><li>Monitor Area Protection</li><li>User Area Protection</li></ol></li></ul><h4>1. Monitor Area Protection</h4><ul><li>作法：採用 **&quot;Fence Register&quot;**紀錄 M.A.大小</li><li>Problem: M.A. 的大小會更動(因為 error routine 是動態載入), 故所有的 user program 需動態更新位址, 需有 Dynamic Binding (只要沒有就不行,程式不會動)</li><li>Solution:<img src="memory_protection_sol.png" alt=""></li></ul><h4>2. User Program Area Protection</h4><ul><li>作法：採用 <strong>&quot;base/limit&quot; register</strong>來記錄各 user program 的起始位址跟 U.P. 的大小</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;3.2 電腦系統結構&lt;/h1&gt;
&lt;h2&gt;I/O process 方式&lt;/h2&gt;
&lt;h3&gt;Polling I/O (詢問式) 又稱 busy wait 或 &amp;quot;programmed I/O&amp;quot;&lt;/h3&gt;
&lt;p&gt;Def:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當一 pro
      
    
    </summary>
    
    
      <category term="計算機概論" scheme="https://pingjing0628.github.io/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E6%A6%82%E8%AB%96/"/>
    
    
      <category term="O.S" scheme="https://pingjing0628.github.io/tags/O-S/"/>
    
      <category term="中斷" scheme="https://pingjing0628.github.io/tags/%E4%B8%AD%E6%96%B7/"/>
    
      <category term="Hardware protection" scheme="https://pingjing0628.github.io/tags/Hardware-protection/"/>
    
  </entry>
  
</feed>
